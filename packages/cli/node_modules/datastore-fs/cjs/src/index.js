'use strict';

Object.defineProperty(exports, '__esModule', { value: true });

var fs = require('fs');
var glob = require('it-glob');
var mkdirp = require('mkdirp');
var path = require('path');
var util = require('util');
var interfaceDatastore = require('interface-datastore');
var datastoreCore = require('datastore-core');
var map = require('it-map');
var parallel = require('it-parallel-batch');
var fwa = require('fast-write-atomic');

function _interopDefaultLegacy (e) { return e && typeof e === 'object' && 'default' in e ? e : { 'default': e }; }

var fs__default = /*#__PURE__*/_interopDefaultLegacy(fs);
var glob__default = /*#__PURE__*/_interopDefaultLegacy(glob);
var mkdirp__default = /*#__PURE__*/_interopDefaultLegacy(mkdirp);
var path__default = /*#__PURE__*/_interopDefaultLegacy(path);
var map__default = /*#__PURE__*/_interopDefaultLegacy(map);
var parallel__default = /*#__PURE__*/_interopDefaultLegacy(parallel);
var fwa__default = /*#__PURE__*/_interopDefaultLegacy(fwa);

const writeAtomic = util.promisify(fwa__default['default']);
async function writeFile(path, contents) {
  try {
    await writeAtomic(path, contents);
  } catch (err) {
    if (err.code === 'EPERM' && err.syscall === 'rename') {
      await fs__default['default'].promises.access(path, fs__default['default'].constants.F_OK | fs__default['default'].constants.W_OK);
      return;
    }
    throw err;
  }
}
class FsDatastore extends datastoreCore.BaseDatastore {
  constructor(location, opts) {
    super();
    this.path = path__default['default'].resolve(location);
    this.opts = Object.assign({}, {
      createIfMissing: true,
      errorIfExists: false,
      extension: '.data',
      deleteManyConcurrency: 50,
      getManyConcurrency: 50,
      putManyConcurrency: 50
    }, opts);
  }
  open() {
    try {
      if (!fs__default['default'].existsSync(this.path)) {
        throw datastoreCore.Errors.notFoundError(new Error(`Datastore directory: ${ this.path } does not exist`));
      }
      if (this.opts.errorIfExists) {
        throw datastoreCore.Errors.dbOpenFailedError(new Error(`Datastore directory: ${ this.path } already exists`));
      }
      return Promise.resolve();
    } catch (err) {
      if (err.code === 'ERR_NOT_FOUND' && this.opts.createIfMissing) {
        mkdirp__default['default'].sync(this.path, { fs: fs__default['default'] });
        return Promise.resolve();
      }
      throw err;
    }
  }
  close() {
    return Promise.resolve();
  }
  _encode(key) {
    const parent = key.parent().toString();
    const dir = path__default['default'].join(this.path, parent);
    const name = key.toString().slice(parent.length);
    const file = path__default['default'].join(dir, name + this.opts.extension);
    return {
      dir: dir,
      file: file
    };
  }
  _decode(file) {
    const ext = this.opts.extension;
    if (path__default['default'].extname(file) !== ext) {
      throw new Error(`Invalid extension: ${ path__default['default'].extname(file) }`);
    }
    const keyname = file.slice(this.path.length, -ext.length).split(path__default['default'].sep).join('/');
    return new interfaceDatastore.Key(keyname);
  }
  async putRaw(key, val) {
    const parts = this._encode(key);
    let file = parts.file;
    if (this.opts.extension.length) {
      file = parts.file.slice(0, -this.opts.extension.length);
    }
    await mkdirp__default['default'](parts.dir, { fs: fs__default['default'] });
    await writeFile(file, val);
  }
  async put(key, val) {
    const parts = this._encode(key);
    try {
      await mkdirp__default['default'](parts.dir, { fs: fs__default['default'] });
      await writeFile(parts.file, val);
    } catch (err) {
      throw datastoreCore.Errors.dbWriteFailedError(err);
    }
  }
  async *putMany(source) {
    yield* parallel__default['default'](map__default['default'](source, ({key, value}) => {
      return async () => {
        await this.put(key, value);
        return {
          key,
          value
        };
      };
    }), this.opts.putManyConcurrency);
  }
  async getRaw(key) {
    const parts = this._encode(key);
    let file = parts.file;
    if (this.opts.extension.length) {
      file = file.slice(0, -this.opts.extension.length);
    }
    let data;
    try {
      data = await fs__default['default'].promises.readFile(file);
    } catch (err) {
      throw datastoreCore.Errors.notFoundError(err);
    }
    return data;
  }
  async get(key) {
    const parts = this._encode(key);
    let data;
    try {
      data = await fs__default['default'].promises.readFile(parts.file);
    } catch (err) {
      throw datastoreCore.Errors.notFoundError(err);
    }
    return data;
  }
  async *getMany(source) {
    yield* parallel__default['default'](map__default['default'](source, key => {
      return async () => {
        return this.get(key);
      };
    }), this.opts.getManyConcurrency);
  }
  async *deleteMany(source) {
    yield* parallel__default['default'](map__default['default'](source, key => {
      return async () => {
        await this.delete(key);
        return key;
      };
    }), this.opts.deleteManyConcurrency);
  }
  async has(key) {
    const parts = this._encode(key);
    try {
      await fs__default['default'].promises.access(parts.file);
    } catch (err) {
      return false;
    }
    return true;
  }
  async delete(key) {
    const parts = this._encode(key);
    try {
      await fs__default['default'].promises.unlink(parts.file);
    } catch (err) {
      if (err.code === 'ENOENT') {
        return;
      }
      throw datastoreCore.Errors.dbDeleteFailedError(err);
    }
  }
  async *_all(q) {
    let prefix = q.prefix || '**';
    prefix = prefix.replace(/^\/+/, '');
    const pattern = `${ prefix }/*${ this.opts.extension }`.split(path__default['default'].sep).join('/');
    const files = glob__default['default'](this.path, pattern, { absolute: true });
    for await (const file of files) {
      try {
        const buf = await fs__default['default'].promises.readFile(file);
        const pair = {
          key: this._decode(file),
          value: buf
        };
        yield pair;
      } catch (err) {
        if (err.code !== 'ENOENT') {
          throw err;
        }
      }
    }
  }
  async *_allKeys(q) {
    let prefix = q.prefix || '**';
    prefix = prefix.replace(/^\/+/, '');
    const pattern = `${ prefix }/*${ this.opts.extension }`.split(path__default['default'].sep).join('/');
    const files = glob__default['default'](this.path, pattern, { absolute: true });
    yield* map__default['default'](files, f => this._decode(f));
  }
}

exports.FsDatastore = FsDatastore;
