import fs from 'fs';
import glob from 'it-glob';
import mkdirp from 'mkdirp';
import path from 'path';
import { promisify } from 'util';
import { Key } from 'interface-datastore';
import {
  BaseDatastore,
  Errors
} from 'datastore-core';
import map from 'it-map';
import parallel from 'it-parallel-batch';
import fwa from 'fast-write-atomic';
const writeAtomic = promisify(fwa);
async function writeFile(path, contents) {
  try {
    await writeAtomic(path, contents);
  } catch (err) {
    if (err.code === 'EPERM' && err.syscall === 'rename') {
      await fs.promises.access(path, fs.constants.F_OK | fs.constants.W_OK);
      return;
    }
    throw err;
  }
}
export class FsDatastore extends BaseDatastore {
  constructor(location, opts) {
    super();
    this.path = path.resolve(location);
    this.opts = Object.assign({}, {
      createIfMissing: true,
      errorIfExists: false,
      extension: '.data',
      deleteManyConcurrency: 50,
      getManyConcurrency: 50,
      putManyConcurrency: 50
    }, opts);
  }
  open() {
    try {
      if (!fs.existsSync(this.path)) {
        throw Errors.notFoundError(new Error(`Datastore directory: ${ this.path } does not exist`));
      }
      if (this.opts.errorIfExists) {
        throw Errors.dbOpenFailedError(new Error(`Datastore directory: ${ this.path } already exists`));
      }
      return Promise.resolve();
    } catch (err) {
      if (err.code === 'ERR_NOT_FOUND' && this.opts.createIfMissing) {
        mkdirp.sync(this.path, { fs: fs });
        return Promise.resolve();
      }
      throw err;
    }
  }
  close() {
    return Promise.resolve();
  }
  _encode(key) {
    const parent = key.parent().toString();
    const dir = path.join(this.path, parent);
    const name = key.toString().slice(parent.length);
    const file = path.join(dir, name + this.opts.extension);
    return {
      dir: dir,
      file: file
    };
  }
  _decode(file) {
    const ext = this.opts.extension;
    if (path.extname(file) !== ext) {
      throw new Error(`Invalid extension: ${ path.extname(file) }`);
    }
    const keyname = file.slice(this.path.length, -ext.length).split(path.sep).join('/');
    return new Key(keyname);
  }
  async putRaw(key, val) {
    const parts = this._encode(key);
    let file = parts.file;
    if (this.opts.extension.length) {
      file = parts.file.slice(0, -this.opts.extension.length);
    }
    await mkdirp(parts.dir, { fs: fs });
    await writeFile(file, val);
  }
  async put(key, val) {
    const parts = this._encode(key);
    try {
      await mkdirp(parts.dir, { fs: fs });
      await writeFile(parts.file, val);
    } catch (err) {
      throw Errors.dbWriteFailedError(err);
    }
  }
  async *putMany(source) {
    yield* parallel(map(source, ({key, value}) => {
      return async () => {
        await this.put(key, value);
        return {
          key,
          value
        };
      };
    }), this.opts.putManyConcurrency);
  }
  async getRaw(key) {
    const parts = this._encode(key);
    let file = parts.file;
    if (this.opts.extension.length) {
      file = file.slice(0, -this.opts.extension.length);
    }
    let data;
    try {
      data = await fs.promises.readFile(file);
    } catch (err) {
      throw Errors.notFoundError(err);
    }
    return data;
  }
  async get(key) {
    const parts = this._encode(key);
    let data;
    try {
      data = await fs.promises.readFile(parts.file);
    } catch (err) {
      throw Errors.notFoundError(err);
    }
    return data;
  }
  async *getMany(source) {
    yield* parallel(map(source, key => {
      return async () => {
        return this.get(key);
      };
    }), this.opts.getManyConcurrency);
  }
  async *deleteMany(source) {
    yield* parallel(map(source, key => {
      return async () => {
        await this.delete(key);
        return key;
      };
    }), this.opts.deleteManyConcurrency);
  }
  async has(key) {
    const parts = this._encode(key);
    try {
      await fs.promises.access(parts.file);
    } catch (err) {
      return false;
    }
    return true;
  }
  async delete(key) {
    const parts = this._encode(key);
    try {
      await fs.promises.unlink(parts.file);
    } catch (err) {
      if (err.code === 'ENOENT') {
        return;
      }
      throw Errors.dbDeleteFailedError(err);
    }
  }
  async *_all(q) {
    let prefix = q.prefix || '**';
    prefix = prefix.replace(/^\/+/, '');
    const pattern = `${ prefix }/*${ this.opts.extension }`.split(path.sep).join('/');
    const files = glob(this.path, pattern, { absolute: true });
    for await (const file of files) {
      try {
        const buf = await fs.promises.readFile(file);
        const pair = {
          key: this._decode(file),
          value: buf
        };
        yield pair;
      } catch (err) {
        if (err.code !== 'ENOENT') {
          throw err;
        }
      }
    }
  }
  async *_allKeys(q) {
    let prefix = q.prefix || '**';
    prefix = prefix.replace(/^\/+/, '');
    const pattern = `${ prefix }/*${ this.opts.extension }`.split(path.sep).join('/');
    const files = glob(this.path, pattern, { absolute: true });
    yield* map(files, f => this._decode(f));
  }
}