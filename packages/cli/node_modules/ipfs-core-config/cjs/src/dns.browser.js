'use strict';

Object.defineProperty(exports, '__esModule', { value: true });

var tlru = require('./utils/tlru.js');
var PQueue = require('p-queue');
var HTTP = require('ipfs-utils/src/http.js');

function _interopDefaultLegacy (e) { return e && typeof e === 'object' && 'default' in e ? e : { 'default': e }; }

var PQueue__default = /*#__PURE__*/_interopDefaultLegacy(PQueue);
var HTTP__default = /*#__PURE__*/_interopDefaultLegacy(HTTP);

const cache = new tlru.TLRU(1000);
const ttl = 60 * 1000;
const Queue = PQueue__default["default"].default ? PQueue__default["default"].default : PQueue__default["default"];
const httpQueue = new Queue({ concurrency: 4 });
const ipfsPath = response => {
  if (response.Path)
    return response.Path;
  throw new Error(response.Message);
};
async function resolveDnslink(fqdn, opts) {
  const resolve = async (fqdn, opts = {}) => {
    const searchParams = new URLSearchParams(opts);
    searchParams.set('arg', fqdn);
    const query = searchParams.toString();
    if (!opts.nocache && cache.has(query)) {
      const response = cache.get(query);
      return ipfsPath(response);
    }
    const response = await httpQueue.add(async () => {
      const res = await HTTP__default["default"].get('https://ipfs.io/api/v0/dns', { searchParams });
      const query = new URL(res.url).search.slice(1);
      const json = await res.json();
      cache.set(query, json, ttl);
      return json;
    });
    return ipfsPath(response);
  };
  return resolve(fqdn, opts);
}

exports.resolveDnslink = resolveDnslink;
