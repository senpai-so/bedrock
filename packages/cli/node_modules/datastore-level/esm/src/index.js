import { Key } from 'interface-datastore';
import {
  BaseDatastore,
  Errors
} from 'datastore-core';
import filter from 'it-filter';
import map from 'it-map';
import take from 'it-take';
import sort from 'it-sort';
import Level from 'level';
export class LevelDatastore extends BaseDatastore {
  constructor(path, opts) {
    super();
    this.path = path;
    this.opts = opts;
    if (opts && opts.db) {
      this.database = opts.db;
      delete opts.db;
    } else {
      this.database = Level;
    }
  }
  _initDb() {
    return new Promise((resolve, reject) => {
      this.db = this.database(this.path, {
        ...this.opts,
        valueEncoding: 'binary',
        compression: false
      }, err => {
        if (err) {
          return reject(err);
        }
        resolve(this.db);
      });
    });
  }
  async open() {
    try {
      if (this.db) {
        await this.db.open();
      } else {
        this.db = await this._initDb();
      }
    } catch (err) {
      throw Errors.dbOpenFailedError(err);
    }
  }
  async put(key, value) {
    try {
      await this.db.put(key.toString(), value);
    } catch (err) {
      throw Errors.dbWriteFailedError(err);
    }
  }
  async get(key) {
    let data;
    try {
      data = await this.db.get(key.toString());
    } catch (err) {
      if (err.notFound)
        throw Errors.notFoundError(err);
      throw Errors.dbWriteFailedError(err);
    }
    return data;
  }
  async has(key) {
    try {
      await this.db.get(key.toString());
    } catch (err) {
      if (err.notFound)
        return false;
      throw err;
    }
    return true;
  }
  async delete(key) {
    try {
      await this.db.del(key.toString());
    } catch (err) {
      throw Errors.dbDeleteFailedError(err);
    }
  }
  close() {
    return this.db && this.db.close();
  }
  batch() {
    const ops = [];
    return {
      put: (key, value) => {
        ops.push({
          type: 'put',
          key: key.toString(),
          value: value
        });
      },
      delete: key => {
        ops.push({
          type: 'del',
          key: key.toString()
        });
      },
      commit: () => {
        return this.db.batch(ops);
      }
    };
  }
  query(q) {
    let it = this._query({
      values: true,
      prefix: q.prefix
    });
    if (Array.isArray(q.filters)) {
      it = q.filters.reduce((it, f) => filter(it, f), it);
    }
    if (Array.isArray(q.orders)) {
      it = q.orders.reduce((it, f) => sort(it, f), it);
    }
    const {offset, limit} = q;
    if (offset) {
      let i = 0;
      it = filter(it, () => i++ >= offset);
    }
    if (limit) {
      it = take(it, limit);
    }
    return it;
  }
  queryKeys(q) {
    let it = map(this._query({
      values: false,
      prefix: q.prefix
    }), ({key}) => key);
    if (Array.isArray(q.filters)) {
      it = q.filters.reduce((it, f) => filter(it, f), it);
    }
    if (Array.isArray(q.orders)) {
      it = q.orders.reduce((it, f) => sort(it, f), it);
    }
    const {offset, limit} = q;
    if (offset) {
      let i = 0;
      it = filter(it, () => i++ >= offset);
    }
    if (limit) {
      it = take(it, limit);
    }
    return it;
  }
  _query(opts) {
    const iteratorOpts = {
      keys: true,
      keyAsBuffer: true,
      values: opts.values
    };
    if (opts.prefix != null) {
      const prefix = opts.prefix.toString();
      iteratorOpts.gte = prefix;
      iteratorOpts.lt = prefix + 'Ã¿';
    }
    return levelIteratorToIterator(this.db.iterator(iteratorOpts));
  }
}
function levelIteratorToIterator(li) {
  return {
    [Symbol.asyncIterator]() {
      return {
        next: () => new Promise((resolve, reject) => {
          li.next((err, key, value) => {
            if (err)
              return reject(err);
            if (key == null) {
              return li.end(err => {
                if (err)
                  return reject(err);
                resolve({
                  done: true,
                  value: undefined
                });
              });
            }
            resolve({
              done: false,
              value: {
                key: new Key(key, false),
                value
              }
            });
          });
        }),
        return: () => new Promise((resolve, reject) => {
          li.end(err => {
            if (err)
              return reject(err);
            resolve({
              done: true,
              value: undefined
            });
          });
        })
      };
    }
  };
}