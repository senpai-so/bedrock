export type ConnectionType = 0 | 1 | 2 | 3 | 4;
export type PBPeer = {
    id: Uint8Array;
    addrs: Uint8Array[];
    connection: ConnectionType;
};
export type PeerData = import('../types').PeerData;
/**
 * @typedef {0|1|2|3|4} ConnectionType
 *
 * @typedef {object} PBPeer
 * @property {Uint8Array} id
 * @property {Uint8Array[]} addrs
 * @property {ConnectionType} connection
 *
 * @typedef {import('../types').PeerData} PeerData
 */
/**
 * Represents a single DHT control message.
 */
export class Message {
    /**
     * Decode from protobuf
     *
     * @param {Uint8Array} raw
     */
    static deserialize(raw: Uint8Array): Message;
    /**
     * @param {import('./dht').Message.MessageType} type
     * @param {Uint8Array} key
     * @param {number} level
     */
    constructor(type: import('./dht').Message.MessageType, key: Uint8Array, level: number);
    type: Proto.Message.MessageType;
    key: Uint8Array;
    _clusterLevelRaw: number;
    /** @type {PeerData[]} */
    closerPeers: PeerData[];
    /** @type {PeerData[]} */
    providerPeers: PeerData[];
    /** @type {import('libp2p-record').Record | undefined} */
    record: import("libp2p-record/dist/src/record") | undefined;
    set clusterLevel(arg: number);
    /**
     * @type {number}
     */
    get clusterLevel(): number;
    /**
     * Encode into protobuf
     */
    serialize(): Uint8Array;
}
export namespace Message {
    export { MESSAGE_TYPE as TYPES };
    export { CONNECTION_TYPE as CONNECTION_TYPES };
}
export const MESSAGE_TYPE: typeof Proto.Message.MessageType;
export const MESSAGE_TYPE_LOOKUP: string[];
import Proto = require("./dht");
declare const CONNECTION_TYPE: typeof Proto.Message.ConnectionType;
export {};
//# sourceMappingURL=index.d.ts.map