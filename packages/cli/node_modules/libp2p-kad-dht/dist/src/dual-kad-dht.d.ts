export type Libp2p = import('libp2p');
export type PeerStore = import('libp2p/src/peer-store');
export type Datastore = import('interface-datastore').Datastore;
export type Dialer = import('libp2p/src/dialer');
export type Registrar = import('libp2p/src/registrar');
export type CID = import('multiformats/cid').CID;
export type Multiaddr = import('multiaddr').Multiaddr;
export type KadDHT = import('./kad-dht').KadDHT;
export type DHT = import('./types').DHT;
export type QueryEvent = import('./types').QueryEvent;
export type SendingQueryEvent = import('./types').SendingQueryEvent;
export type PeerResponseEvent = import('./types').PeerResponseEvent;
export type FinalPeerEvent = import('./types').FinalPeerEvent;
export type QueryErrorEvent = import('./types').QueryErrorEvent;
export type ProviderEvent = import('./types').ProviderEvent;
export type ValueEvent = import('./types').ValueEvent;
export type AddingPeerEvent = import('./types').AddingPeerEvent;
export type DialingPeerEvent = import('./types').DialingPeerEvent;
export type KadDHTOps = {
    /**
     * - the libp2p instance
     */
    libp2p: Libp2p;
    /**
     * - libp2p registrar handle protocol
     */
    protocol?: string | undefined;
    /**
     * - k-bucket size (default 20)
     */
    kBucketSize: number;
    /**
     * - If true, the DHT will not respond to queries. This should be true if your node will not be dialable. (default: false)
     */
    clientMode: boolean;
    /**
     * - validators object with namespace as keys and function(key, record, callback)
     */
    validators: import('libp2p-interfaces/src/types').DhtValidators;
    /**
     * - selectors object with namespace as keys and function(key, records)
     */
    selectors: object;
    /**
     * - how often to search the network for peers close to ourselves
     */
    querySelfInterval: number;
};
/**
 * @typedef {import('libp2p')} Libp2p
 * @typedef {import('libp2p/src/peer-store')} PeerStore
 * @typedef {import('interface-datastore').Datastore} Datastore
 * @typedef {import('libp2p/src/dialer')} Dialer
 * @typedef {import('libp2p/src/registrar')} Registrar
 * @typedef {import('multiformats/cid').CID} CID
 * @typedef {import('multiaddr').Multiaddr} Multiaddr
 * @typedef {import('./kad-dht').KadDHT} KadDHT
 * @typedef {import('./types').DHT} DHT
 * @typedef {import('./types').QueryEvent} QueryEvent
 * @typedef {import('./types').SendingQueryEvent} SendingQueryEvent
 * @typedef {import('./types').PeerResponseEvent} PeerResponseEvent
 * @typedef {import('./types').FinalPeerEvent} FinalPeerEvent
 * @typedef {import('./types').QueryErrorEvent} QueryErrorEvent
 * @typedef {import('./types').ProviderEvent} ProviderEvent
 * @typedef {import('./types').ValueEvent} ValueEvent
 * @typedef {import('./types').AddingPeerEvent} AddingPeerEvent
 * @typedef {import('./types').DialingPeerEvent} DialingPeerEvent
 *
 * @typedef {object} KadDHTOps
 * @property {Libp2p} libp2p - the libp2p instance
 * @property {string} [protocol = '/ipfs/kad/1.0.0'] - libp2p registrar handle protocol
 * @property {number} kBucketSize - k-bucket size (default 20)
 * @property {boolean} clientMode - If true, the DHT will not respond to queries. This should be true if your node will not be dialable. (default: false)
 * @property {import('libp2p-interfaces/src/types').DhtValidators} validators - validators object with namespace as keys and function(key, record, callback)
 * @property {object} selectors - selectors object with namespace as keys and function(key, records)
 * @property {number} querySelfInterval - how often to search the network for peers close to ourselves
 */
/**
 * A DHT implementation modelled after Kademlia with S/Kademlia modifications.
 * Original implementation in go: https://github.com/libp2p/go-libp2p-kad-dht.
 */
export class DualKadDHT extends EventEmitter {
    /**
     * Create a new KadDHT.
     *
     * @param {KadDHT} wan
     * @param {KadDHT} lan
     * @param {Libp2p} libp2p
     */
    constructor(wan: KadDHT, lan: KadDHT, libp2p: Libp2p);
    _wan: import("./kad-dht").KadDHT;
    _lan: import("./kad-dht").KadDHT;
    _libp2p: import("libp2p");
    /**
     * Is this DHT running.
     */
    isStarted(): boolean;
    /**
     * Whether we are in client or server mode
     */
    enableServerMode(): void;
    /**
     * Whether we are in client or server mode
     */
    enableClientMode(): void;
    /**
     * Start listening to incoming connections.
     */
    start(): Promise<void>;
    /**
     * Stop accepting incoming connections and sending outgoing
     * messages.
     */
    stop(): Promise<void>;
    /**
     * Store the given key/value pair in the DHT
     *
     * @param {Uint8Array} key
     * @param {Uint8Array} value
     * @param {object} [options] - put options
     * @param {AbortSignal} [options.signal]
     * @param {number} [options.minPeers] - minimum number of peers required to successfully put (default: closestPeers.length)
     */
    put(key: Uint8Array, value: Uint8Array, options?: {
        signal?: AbortSignal | undefined;
        minPeers?: number | undefined;
    } | undefined): AsyncGenerator<import("./types").SendingQueryEvent | import("./types").PeerResponseEvent | import("./types").QueryErrorEvent | import("./types").ProviderEvent | import("./types").ValueEvent | import("./types").AddingPeerEvent | import("./types").DialingPeerEvent, void, unknown>;
    /**
     * Get the value that corresponds to the passed key
     *
     * @param {Uint8Array} key
     * @param {object} [options]
     * @param {AbortSignal} [options.signal]
     * @param {number} [options.queryFuncTimeout]
     */
    get(key: Uint8Array, options?: {
        signal?: AbortSignal | undefined;
        queryFuncTimeout?: number | undefined;
    } | undefined): AsyncGenerator<import("./types").QueryEvent, void, unknown>;
    /**
     * Announce to the network that we can provide given key's value
     *
     * @param {CID} key
     * @param {object} [options]
     * @param {AbortSignal} [options.signal]
     */
    provide(key: CID, options?: {
        signal?: AbortSignal | undefined;
    } | undefined): AsyncGenerator<import("./types").SendingQueryEvent | import("./types").PeerResponseEvent | import("./types").QueryErrorEvent | import("./types").ProviderEvent | import("./types").ValueEvent | import("./types").AddingPeerEvent | import("./types").DialingPeerEvent, void, unknown>;
    /**
     * Search the dht for up to `K` providers of the given CID.
     *
     * @param {CID} key
     * @param {object} [options] - findProviders options
     * @param {number} [options.maxNumProviders=5] - maximum number of providers to find
     * @param {AbortSignal} [options.signal]
     * @param {number} [options.queryFuncTimeout]
     */
    findProviders(key: CID, options?: {
        maxNumProviders?: number | undefined;
        signal?: AbortSignal | undefined;
        queryFuncTimeout?: number | undefined;
    } | undefined): AsyncGenerator<import("./types").QueryEvent, void, undefined>;
    /**
     * Search for a peer with the given ID
     *
     * @param {PeerId} id
     * @param {object} [options]
     * @param {AbortSignal} [options.signal]
     * @param {number} [options.queryFuncTimeout]
     */
    findPeer(id: PeerId, options?: {
        signal?: AbortSignal | undefined;
        queryFuncTimeout?: number | undefined;
    } | undefined): AsyncGenerator<import("./types").QueryEvent, void, unknown>;
    /**
     * Kademlia 'node lookup' operation.
     *
     * @param {Uint8Array} key
     * @param {object} [options]
     * @param {AbortSignal} [options.signal]
     * @param {number} [options.queryFuncTimeout]
     */
    getClosestPeers(key: Uint8Array, options?: {
        signal?: AbortSignal | undefined;
        queryFuncTimeout?: number | undefined;
    } | undefined): AsyncGenerator<import("./types").QueryEvent, void, undefined>;
    /**
     * Get the public key for the given peer id
     *
     * @param {PeerId} peer
     * @param {object} [options]
     * @param {AbortSignal} [options.signal]
     */
    getPublicKey(peer: PeerId, options?: {
        signal?: AbortSignal | undefined;
    } | undefined): Promise<import("libp2p-crypto").PublicKey>;
    refreshRoutingTable(): Promise<void>;
}
import { EventEmitter } from "events";
import PeerId = require("peer-id");
//# sourceMappingURL=dual-kad-dht.d.ts.map