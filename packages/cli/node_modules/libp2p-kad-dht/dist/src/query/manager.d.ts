export type PeerId = import('peer-id');
export type Metrics = import('../types').Metrics;
/**
 * Keeps track of all running queries
 */
export class QueryManager {
    /**
     * Creates a new QueryManager
     *
     * @param {object} params
     * @param {PeerId} params.peerId
     * @param {boolean} params.lan
     * @param {Metrics} [params.metrics]
     * @param {number} [params.disjointPaths]
     * @param {number} [params.alpha]
     */
    constructor({ peerId, lan, metrics, disjointPaths, alpha }: {
        peerId: PeerId;
        lan: boolean;
        metrics?: import("../types").Metrics | undefined;
        disjointPaths?: number | undefined;
        alpha?: number | undefined;
    });
    _peerId: import("peer-id");
    _disjointPaths: number;
    _controllers: Set<any>;
    _running: boolean;
    _alpha: number;
    _lan: boolean;
    _metrics: import("../types").Metrics | undefined;
    _queries: number;
    /**
     * Starts the query manager
     */
    start(): void;
    /**
     * Stops all queries
     */
    stop(): void;
    /**
     * @template T
     *
     * @param {Uint8Array} key
     * @param {PeerId[]} peers
     * @param {import('./types').QueryFunc} queryFunc
     * @param {object} [options]
     * @param {AbortSignal} [options.signal]
     * @param {number} [options.queryFuncTimeout]
     *
     * @returns {AsyncIterable<import('../types').QueryEvent>}
     */
    run<T>(key: Uint8Array, peers: PeerId[], queryFunc: import('./types').QueryFunc, options?: {
        signal?: AbortSignal | undefined;
        queryFuncTimeout?: number | undefined;
    } | undefined): AsyncIterable<import('../types').QueryEvent>;
}
//# sourceMappingURL=manager.d.ts.map