export type Libp2p = import('libp2p');
export type PeerStore = import('libp2p/src/peer-store');
export type Datastore = import('interface-datastore').Datastore;
export type Dialer = import('libp2p/src/dialer');
export type Registrar = import('libp2p/src/registrar');
export type CID = import('multiformats/cid').CID;
export type Multiaddr = import('multiaddr').Multiaddr;
export type PeerId = import('peer-id');
export type DHT = import('./types').DHT;
export type PeerData = import('./types').PeerData;
export type QueryEvent = import('./types').QueryEvent;
export type SendingQueryEvent = import('./types').SendingQueryEvent;
export type PeerResponseEvent = import('./types').PeerResponseEvent;
export type FinalPeerEvent = import('./types').FinalPeerEvent;
export type QueryErrorEvent = import('./types').QueryErrorEvent;
export type ProviderEvent = import('./types').ProviderEvent;
export type ValueEvent = import('./types').ValueEvent;
export type AddingPeerEvent = import('./types').AddingPeerEvent;
export type DialingPeerEvent = import('./types').DialingPeerEvent;
export type KadDHTOps = {
    /**
     * - the libp2p instance
     */
    libp2p: Libp2p;
    /**
     * - libp2p registrar handle protocol
     */
    protocol?: string | undefined;
    /**
     * - k-bucket size (default 20)
     */
    kBucketSize: number;
    /**
     * - If true, the DHT will not respond to queries. This should be true if your node will not be dialable. (default: false)
     */
    clientMode: boolean;
    /**
     * - validators object with namespace as keys and function(key, record, callback)
     */
    validators: import('libp2p-interfaces/src/types').DhtValidators;
    /**
     * - selectors object with namespace as keys and function(key, records)
     */
    selectors: object;
    /**
     * - how often to search the network for peers close to ourselves
     */
    querySelfInterval: number;
    lan: boolean;
    bootstrapPeers: PeerData[];
};
/**
 * A DHT implementation modelled after Kademlia with S/Kademlia modifications.
 * Original implementation in go: https://github.com/libp2p/go-libp2p-kad-dht.
 */
export class KadDHT extends EventEmitter {
    /**
     * Create a new KadDHT.
     *
     * @param {KadDHTOps} opts
     */
    constructor({ libp2p, kBucketSize, clientMode, validators, selectors, querySelfInterval, lan, protocol, bootstrapPeers }: KadDHTOps);
    _running: boolean;
    _log: debug.Debugger & {
        error: debug.Debugger;
    };
    /**
     * Local reference to the libp2p instance
     *
     * @type {Libp2p}
     */
    _libp2p: Libp2p;
    /**
     * Registrar protocol
     *
     * @type {string}
     */
    _protocol: string;
    /**
     * k-bucket size
     *
     * @type {number}
     */
    _kBucketSize: number;
    /**
     * Whether we are in client or server mode
     */
    _clientMode: boolean;
    /**
     * Will be added to the routing table on startup
     */
    _bootstrapPeers: import("./types").PeerData[];
    /**
     * The routing table.
     *
     * @type {RoutingTable}
     */
    _routingTable: RoutingTable;
    /**
     * Provider management
     *
     * @type {Providers}
     */
    _providers: Providers;
    /**
     * @type {boolean}
     */
    _lan: boolean;
    _validators: {
        pk: {
            func: (key: Uint8Array, publicKey: Uint8Array) => Promise<void>;
            sign: boolean;
        };
    };
    _selectors: {
        pk: (k: Uint8Array, records: Uint8Array[]) => number;
    };
    _network: Network;
    /**
     * Keeps track of running queries
     *
     * @type {QueryManager}
     */
    _queryManager: QueryManager;
    _peerRouting: PeerRouting;
    _contentFetching: ContentFetching;
    _contentRouting: ContentRouting;
    _routingTableRefresh: RoutingTableRefresh;
    _rpc: RPC;
    _topologyListener: TopologyListener;
    _querySelf: QuerySelf;
    /**
     * @param {PeerData} peerData
     */
    onPeerConnect(peerData: PeerData): Promise<void>;
    /**
     * Is this DHT running.
     */
    isStarted(): boolean;
    /**
     * Is this DHT in server mode
     */
    isServer(): boolean;
    /**
     * Whether we are in client or server mode
     */
    enableServerMode(): void;
    /**
     * Whether we are in client or server mode
     */
    enableClientMode(): void;
    /**
     * Start listening to incoming connections.
     */
    start(): Promise<void>;
    /**
     * Stop accepting incoming connections and sending outgoing
     * messages.
     */
    stop(): Promise<void>;
    /**
     * Store the given key/value pair in the DHT
     *
     * @param {Uint8Array} key
     * @param {Uint8Array} value
     * @param {object} [options] - put options
     * @param {AbortSignal} [options.signal]
     * @param {number} [options.minPeers] - minimum number of peers required to successfully put (default: closestPeers.length)
     */
    put(key: Uint8Array, value: Uint8Array, options?: {
        signal?: AbortSignal | undefined;
        minPeers?: number | undefined;
    } | undefined): AsyncGenerator<import("./types").SendingQueryEvent | import("./types").PeerResponseEvent | import("./types").QueryErrorEvent | import("./types").ProviderEvent | import("./types").ValueEvent | import("./types").AddingPeerEvent | import("./types").DialingPeerEvent, void, undefined>;
    /**
     * Get the value that corresponds to the passed key
     *
     * @param {Uint8Array} key
     * @param {object} [options]
     * @param {AbortSignal} [options.signal]
     * @param {number} [options.queryFuncTimeout]
     */
    get(key: Uint8Array, options?: {
        signal?: AbortSignal | undefined;
        queryFuncTimeout?: number | undefined;
    } | undefined): AsyncGenerator<import("./types").QueryEvent, void, unknown>;
    /**
     * Announce to the network that we can provide given key's value
     *
     * @param {CID} key
     * @param {object} [options]
     * @param {AbortSignal} [options.signal]
     */
    provide(key: CID, options?: {
        signal?: AbortSignal | undefined;
    } | undefined): AsyncGenerator<import("./types").SendingQueryEvent | import("./types").PeerResponseEvent | import("./types").QueryErrorEvent | import("./types").ProviderEvent | import("./types").ValueEvent | import("./types").AddingPeerEvent | import("./types").DialingPeerEvent, void, undefined>;
    /**
     * Search the dht for up to `K` providers of the given CID.
     *
     * @param {CID} key
     * @param {object} [options] - findProviders options
     * @param {number} [options.maxNumProviders=5] - maximum number of providers to find
     * @param {AbortSignal} [options.signal]
     * @param {number} [options.queryFuncTimeout]
     */
    findProviders(key: CID, options?: {
        maxNumProviders?: number | undefined;
        signal?: AbortSignal | undefined;
        queryFuncTimeout?: number | undefined;
    } | undefined): AsyncGenerator<import("./types").QueryEvent, void, unknown>;
    /**
     * Search for a peer with the given ID
     *
     * @param {PeerId} id
     * @param {object} [options]
     * @param {AbortSignal} [options.signal]
     * @param {number} [options.queryFuncTimeout]
     */
    findPeer(id: PeerId, options?: {
        signal?: AbortSignal | undefined;
        queryFuncTimeout?: number | undefined;
    } | undefined): AsyncGenerator<import("./types").QueryEvent, void, unknown>;
    /**
     * Kademlia 'node lookup' operation.
     *
     * @param {Uint8Array} key
     * @param {object} [options]
     * @param {AbortSignal} [options.signal]
     * @param {number} [options.queryFuncTimeout]
     */
    getClosestPeers(key: Uint8Array, options?: {
        signal?: AbortSignal | undefined;
        queryFuncTimeout?: number | undefined;
    } | undefined): AsyncGenerator<import("./types").QueryEvent, void, undefined>;
    /**
     * Get the public key for the given peer id
     *
     * @param {PeerId} peer
     * @param {object} [options]
     * @param {AbortSignal} [options.signal]
     */
    getPublicKey(peer: PeerId, options?: {
        signal?: AbortSignal | undefined;
    } | undefined): Promise<crypto.PublicKey | undefined>;
    refreshRoutingTable(): Promise<void>;
}
import { EventEmitter } from "events";
import { RoutingTable } from "./routing-table";
import { Providers } from "./providers";
import { Network } from "./network";
import { QueryManager } from "./query/manager";
import { PeerRouting } from "./peer-routing";
import { ContentFetching } from "./content-fetching";
import { ContentRouting } from "./content-routing";
import { RoutingTableRefresh } from "./routing-table/refresh";
import { RPC } from "./rpc";
import { TopologyListener } from "./topology-listener";
import { QuerySelf } from "./query-self";
import crypto = require("libp2p-crypto");
//# sourceMappingURL=kad-dht.d.ts.map