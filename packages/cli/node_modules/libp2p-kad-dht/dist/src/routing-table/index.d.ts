export type KBucketPeer = import('./types').KBucketPeer;
export type KBucket = import('./types').KBucket;
export type KBucketTree = import('./types').KBucketTree;
export type PeerId = import('peer-id');
export type Metrics = import('../types').Metrics;
/**
 * A wrapper around `k-bucket`, to provide easy store and
 * retrieval for peers.
 */
export class RoutingTable {
    /**
     * @param {object} params
     * @param {import('peer-id')} params.peerId
     * @param {import('../types').Dialer} params.dialer
     * @param {boolean} params.lan
     * @param {Metrics} [params.metrics]
     * @param {number} [params.kBucketSize=20]
     * @param {number} [params.pingTimeout=10000]
     */
    constructor({ peerId, dialer, kBucketSize, pingTimeout, lan, metrics }: {
        peerId: import('peer-id');
        dialer: import('../types').Dialer;
        lan: boolean;
        metrics?: import("../types").Metrics | undefined;
        kBucketSize?: number | undefined;
        pingTimeout?: number | undefined;
    });
    _log: debug.Debugger & {
        error: debug.Debugger;
    };
    _peerId: import("peer-id");
    _dialer: import("../types").Dialer;
    _kBucketSize: number;
    _pingTimeout: number;
    _lan: boolean;
    _metrics: import("../types").Metrics | undefined;
    /** @type {KBucketTree} */
    kb: KBucketTree;
    /** @type {Date[]} */
    commonPrefixLengthRefreshedAt: Date[];
    /**
     * Called on the `ping` event from `k-bucket` when a bucket is full
     * and cannot split.
     *
     * `oldContacts.length` is defined by the `numberOfNodesToPing` param
     * passed to the `k-bucket` constructor.
     *
     * `oldContacts` will not be empty and is the list of contacts that
     * have not been contacted for the longest.
     *
     * @param {KBucketPeer[]} oldContacts
     * @param {KBucketPeer} newContact
     */
    _onPing(oldContacts: KBucketPeer[], newContact: KBucketPeer): void;
    _pingQueue: Queue<import("p-queue/dist/priority-queue").default, import("p-queue").DefaultAddOptions>;
    _running: boolean;
    start(): Promise<void>;
    stop(): Promise<void>;
    /**
     * Amount of currently stored peers.
     */
    get size(): number;
    /**
     * Find a specific peer by id.
     *
     * @param {PeerId} peer
     */
    find(peer: PeerId): Promise<import("peer-id") | undefined>;
    /**
     * Retrieve the closest peers to the given key.
     *
     * @param {Uint8Array} key
     */
    closestPeer(key: Uint8Array): import("peer-id") | undefined;
    /**
     * Retrieve the `count`-closest peers to the given key.
     *
     * @param {Uint8Array} key
     * @param {number} [count] - defaults to kBucketSize
     */
    closestPeers(key: Uint8Array, count?: number | undefined): import("peer-id")[];
    /**
     * Add or update the routing table with the given peer.
     *
     * @param {PeerId} peer
     */
    add(peer: PeerId): Promise<void>;
    /**
     * Remove a given peer from the table.
     *
     * @param {PeerId} peer
     */
    remove(peer: PeerId): Promise<void>;
}
import { default as Queue } from "p-queue";
//# sourceMappingURL=index.d.ts.map