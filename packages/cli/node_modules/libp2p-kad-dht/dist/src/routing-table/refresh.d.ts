export type KBucketPeer = import('./types').KBucketPeer;
export type KBucket = import('./types').KBucket;
export type KBucketTree = import('./types').KBucketTree;
/**
 * A wrapper around `k-bucket`, to provide easy store and
 * retrieval for peers.
 */
export class RoutingTableRefresh {
    /**
     * @param {object} params
     * @param {import('../peer-routing').PeerRouting} params.peerRouting
     * @param {import('./').RoutingTable} params.routingTable
     * @param {boolean} params.lan
     * @param {number} [params.refreshInterval]
     * @param {number} [params.refreshQueryTimeout]
     */
    constructor({ peerRouting, routingTable, refreshInterval, refreshQueryTimeout, lan }: {
        peerRouting: import('../peer-routing').PeerRouting;
        routingTable: import('./').RoutingTable;
        lan: boolean;
        refreshInterval?: number | undefined;
        refreshQueryTimeout?: number | undefined;
    });
    _log: debug.Debugger & {
        error: debug.Debugger;
    };
    _peerRouting: import("../peer-routing").PeerRouting;
    _routingTable: import("./").RoutingTable;
    _refreshInterval: number;
    _refreshQueryTimeout: number;
    /** @type {Date[]} */
    commonPrefixLengthRefreshedAt: Date[];
    /**
     * To speed lookups, we seed the table with random PeerIds. This means
     * when we are asked to locate a peer on the network, we can find a KadId
     * that is close to the requested peer ID and query that, then network
     * peers will tell us who they know who is close to the fake ID
     *
     * @param {boolean} [force=false]
     */
    refreshTable(force?: boolean | undefined): Promise<void>;
    start(): Promise<void>;
    stop(): Promise<void>;
    _refreshTimeoutId: NodeJS.Timeout | undefined;
    /**
     * @param {number} cpl
     * @param {Date} lastRefresh
     * @param {boolean} force
     */
    _refreshCommonPrefixLength(cpl: number, lastRefresh: Date, force: boolean): Promise<void>;
    /**
     * @param {number} maxCommonPrefix
     */
    _getTrackedCommonPrefixLengthsForRefresh(maxCommonPrefix: number): Date[];
    /**
     *
     * @param {number} targetCommonPrefixLength
     */
    _generateRandomPeerId(targetCommonPrefixLength: number): Promise<PeerId>;
    /**
     * @param {Uint8Array} localKadId
     * @param {number} randomPrefix
     * @param {number} targetCommonPrefixLength
     */
    _makePeerId(localKadId: Uint8Array, randomPrefix: number, targetCommonPrefixLength: number): Promise<Uint8Array>;
    /**
     * returns the maximum common prefix length between any peer in the table
     * and the current peer
     */
    _maxCommonPrefix(): number;
    /**
     * Returns the number of peers in the table with a given prefix length
     *
     * @param {number} prefixLength
     */
    _numPeersForCpl(prefixLength: number): number;
    /**
     * Yields the common prefix length of every peer in the table
     */
    _prefixLengths(): Generator<number, void, unknown>;
}
import PeerId = require("peer-id");
//# sourceMappingURL=refresh.d.ts.map