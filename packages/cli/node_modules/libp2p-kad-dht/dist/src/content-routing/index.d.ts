export type CID = import('multiformats/cid').CID;
export type PeerId = import('peer-id');
export type Multiaddr = import('multiaddr').Multiaddr;
/**
 * @typedef {import('multiformats/cid').CID} CID
 * @typedef {import('peer-id')} PeerId
 * @typedef {import('multiaddr').Multiaddr} Multiaddr
 */
export class ContentRouting {
    /**
     * @param {object} params
     * @param {import('peer-id')} params.peerId
     * @param {import('../network').Network} params.network
     * @param {import('../peer-routing').PeerRouting} params.peerRouting
     * @param {import('../query/manager').QueryManager} params.queryManager
     * @param {import('../routing-table').RoutingTable} params.routingTable
     * @param {import('../providers').Providers} params.providers
     * @param {import('../types').PeerStore} params.peerStore
     * @param {boolean} params.lan
     */
    constructor({ peerId, network, peerRouting, queryManager, routingTable, providers, peerStore, lan }: {
        peerId: import('peer-id');
        network: import('../network').Network;
        peerRouting: import('../peer-routing').PeerRouting;
        queryManager: import('../query/manager').QueryManager;
        routingTable: import('../routing-table').RoutingTable;
        providers: import('../providers').Providers;
        peerStore: import('../types').PeerStore;
        lan: boolean;
    });
    _log: debug.Debugger & {
        error: debug.Debugger;
    };
    _peerId: import("peer-id");
    _network: import("../network").Network;
    _peerRouting: import("../peer-routing").PeerRouting;
    _queryManager: import("../query/manager").QueryManager;
    _routingTable: import("../routing-table").RoutingTable;
    _providers: import("../providers").Providers;
    _peerStore: import("../types").PeerStore;
    /**
     * Announce to the network that we can provide the value for a given key and
     * are contactable on the given multiaddrs
     *
     * @param {CID} key
     * @param {Multiaddr[]} multiaddrs
     * @param {object} [options]
     * @param {AbortSignal} [options.signal]
     */
    provide(key: CID, multiaddrs: Multiaddr[], options?: {
        signal?: AbortSignal | undefined;
    } | undefined): AsyncGenerator<import("../types").SendingQueryEvent | import("../types").PeerResponseEvent | import("../types").QueryErrorEvent | import("../types").ProviderEvent | import("../types").ValueEvent | import("../types").AddingPeerEvent | import("../types").DialingPeerEvent, void, undefined>;
    /**
     * Search the dht for up to `K` providers of the given CID.
     *
     * @param {CID} key
     * @param {object} [options] - findProviders options
     * @param {number} [options.maxNumProviders=5] - maximum number of providers to find
     * @param {AbortSignal} [options.signal]
     * @param {number} [options.queryFuncTimeout]
     */
    findProviders(key: CID, options?: {
        maxNumProviders?: number | undefined;
        signal?: AbortSignal | undefined;
        queryFuncTimeout?: number | undefined;
    } | undefined): AsyncGenerator<import("../types").QueryEvent, void, unknown>;
}
//# sourceMappingURL=index.d.ts.map