export type PeerId = import('peer-id');
export type MuxedStream = import('libp2p-interfaces/src/stream-muxer/types').MuxedStream;
export type QueryEvent = import('./types').QueryEvent;
export type PeerData = import('./types').PeerData;
/**
 * @typedef {import('peer-id')} PeerId
 * @typedef {import('libp2p-interfaces/src/stream-muxer/types').MuxedStream} MuxedStream
 * @typedef {import('./types').QueryEvent} QueryEvent
 * @typedef {import('./types').PeerData} PeerData
 */
/**
 * Handle network operations for the dht
 */
export class Network extends EventEmitter {
    /**
     * Create a new network
     *
     * @param {object} params
     * @param {import('./types').Dialer} params.dialer
     * @param {string} params.protocol
     * @param {boolean} params.lan
     */
    constructor({ dialer, protocol, lan }: {
        dialer: import('./types').Dialer;
        protocol: string;
        lan: boolean;
    });
    _log: debug.Debugger & {
        error: debug.Debugger;
    };
    _running: boolean;
    _dialer: import("./types").Dialer;
    _protocol: string;
    /**
     * Start the network
     */
    start(): void;
    /**
     * Stop all network activity
     */
    stop(): void;
    /**
     * Is the network online?
     *
     * @type {boolean}
     */
    get isStarted(): boolean;
    /**
     * Send a request and record RTT for latency measurements
     *
     * @param {PeerId} to - The peer that should receive a message
     * @param {Message} msg - The message to send
     * @param {object} [options]
     * @param {AbortSignal} [options.signal]
     */
    sendRequest(to: PeerId, msg: Message, options?: {
        signal?: AbortSignal | undefined;
    } | undefined): AsyncGenerator<import("./types").SendingQueryEvent | import("./types").PeerResponseEvent | import("./types").QueryErrorEvent | import("./types").DialingPeerEvent, void, unknown>;
    /**
     * Sends a message without expecting an answer.
     *
     * @param {PeerId} to
     * @param {Message} msg
     * @param {object} [options]
     * @param {AbortSignal} [options.signal]
     */
    sendMessage(to: PeerId, msg: Message, options?: {
        signal?: AbortSignal | undefined;
    } | undefined): AsyncGenerator<import("./types").SendingQueryEvent | import("./types").PeerResponseEvent | import("./types").QueryErrorEvent | import("./types").DialingPeerEvent, void, unknown>;
    /**
     * Write a message to the given stream
     *
     * @param {MuxedStream} stream - the stream to use
     * @param {Uint8Array} msg - the message to send
     * @param {object} [options]
     * @param {AbortSignal} [options.signal]
     */
    _writeMessage(stream: MuxedStream, msg: Uint8Array, options?: {
        signal?: AbortSignal | undefined;
    } | undefined): Promise<void>;
    /**
     * Write a message and read its response.
     * If no response is received after the specified timeout
     * this will error out.
     *
     * @param {MuxedStream} stream - the stream to use
     * @param {Uint8Array} msg - the message to send
     * @param {object} [options]
     * @param {AbortSignal} [options.signal]
     */
    _writeReadMessage(stream: MuxedStream, msg: Uint8Array, options?: {
        signal?: AbortSignal | undefined;
    } | undefined): Promise<Message>;
}
import { EventEmitter } from "events";
import { Message } from "./message";
//# sourceMappingURL=network.d.ts.map