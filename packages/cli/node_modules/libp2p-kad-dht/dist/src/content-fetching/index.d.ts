export type PeerId = import('peer-id');
export type ValueEvent = import('../types').ValueEvent;
/**
 * @typedef {import('peer-id')} PeerId
 * @typedef {import('../types').ValueEvent} ValueEvent
 */
export class ContentFetching {
    /**
     * @param {object} params
     * @param {import('peer-id')} params.peerId
     * @param {import('interface-datastore').Datastore} params.records
     * @param {import('libp2p-interfaces/src/types').DhtValidators} params.validators
     * @param {import('libp2p-interfaces/src/types').DhtSelectors} params.selectors
     * @param {import('../peer-routing').PeerRouting} params.peerRouting
     * @param {import('../query/manager').QueryManager} params.queryManager
     * @param {import('../routing-table').RoutingTable} params.routingTable
     * @param {import('../network').Network} params.network
     * @param {boolean} params.lan
     */
    constructor({ peerId, records, validators, selectors, peerRouting, queryManager, routingTable, network, lan }: {
        peerId: import('peer-id');
        records: import('interface-datastore').Datastore;
        validators: import('libp2p-interfaces/src/types').DhtValidators;
        selectors: import('libp2p-interfaces/src/types').DhtSelectors;
        peerRouting: import('../peer-routing').PeerRouting;
        queryManager: import('../query/manager').QueryManager;
        routingTable: import('../routing-table').RoutingTable;
        network: import('../network').Network;
        lan: boolean;
    });
    _log: debug.Debugger & {
        error: debug.Debugger;
    };
    _peerId: import("peer-id");
    _records: import("interface-datastore").Datastore;
    _validators: import("libp2p-interfaces/src/types").DhtValidators;
    _selectors: import("libp2p-interfaces/src/types").DhtSelectors;
    _peerRouting: import("../peer-routing").PeerRouting;
    _queryManager: import("../query/manager").QueryManager;
    _routingTable: import("../routing-table").RoutingTable;
    _network: import("../network").Network;
    /**
     * @param {Uint8Array} key
     * @param {Uint8Array} rec
     */
    putLocal(key: Uint8Array, rec: Uint8Array): Promise<void>;
    /**
     * Attempt to retrieve the value for the given key from
     * the local datastore.
     *
     * @param {Uint8Array} key
     */
    getLocal(key: Uint8Array): Promise<import("libp2p-record/dist/src/record")>;
    /**
     * Send the best record found to any peers that have an out of date record.
     *
     * @param {Uint8Array} key
     * @param {ValueEvent[]} vals - values retrieved from the DHT
     * @param {Uint8Array} best - the best record that was found
     * @param {object} [options]
     * @param {AbortSignal} [options.signal]
     */
    sendCorrectionRecord(key: Uint8Array, vals: ValueEvent[], best: Uint8Array, options?: {
        signal?: AbortSignal | undefined;
    } | undefined): AsyncGenerator<import("../types").SendingQueryEvent | import("../types").PeerResponseEvent | import("../types").QueryErrorEvent | import("../types").DialingPeerEvent, void, unknown>;
    /**
     * Store the given key/value pair in the DHT
     *
     * @param {Uint8Array} key
     * @param {Uint8Array} value
     * @param {object} [options] - put options
     * @param {AbortSignal} [options.signal]
     */
    put(key: Uint8Array, value: Uint8Array, options?: {
        signal?: AbortSignal | undefined;
    } | undefined): AsyncGenerator<import("../types").SendingQueryEvent | import("../types").PeerResponseEvent | import("../types").QueryErrorEvent | import("../types").ProviderEvent | import("../types").ValueEvent | import("../types").AddingPeerEvent | import("../types").DialingPeerEvent, void, undefined>;
    /**
     * Get the value to the given key
     *
     * @param {Uint8Array} key
     * @param {object} [options]
     * @param {AbortSignal} [options.signal]
     * @param {number} [options.queryFuncTimeout]
     */
    get(key: Uint8Array, options?: {
        signal?: AbortSignal | undefined;
        queryFuncTimeout?: number | undefined;
    } | undefined): AsyncGenerator<import("../types").QueryEvent, void, unknown>;
    /**
     * Get the `n` values to the given key without sorting.
     *
     * @param {Uint8Array} key
     * @param {object} [options]
     * @param {AbortSignal} [options.signal]
     * @param {number} [options.queryFuncTimeout]
     */
    getMany(key: Uint8Array, options?: {
        signal?: AbortSignal | undefined;
        queryFuncTimeout?: number | undefined;
    } | undefined): AsyncGenerator<import("../types").QueryEvent, void, undefined>;
}
//# sourceMappingURL=index.d.ts.map