export type PeerId = import('peer-id');
export type DHTMessageHandler = import('../types').DHTMessageHandler;
/**
 * @typedef {import('peer-id')} PeerId
 * @typedef {import('../types').DHTMessageHandler} DHTMessageHandler
 */
/**
 * @implements {DHTMessageHandler}
 */
export class GetProvidersHandler implements DHTMessageHandler {
    /**
     * @param {object} params
     * @param {PeerId} params.peerId
     * @param {import('../../peer-routing').PeerRouting} params.peerRouting
     * @param {import('../../providers').Providers} params.providers
     * @param {import('../../types').PeerStore} params.peerStore
     * @param {import('../../types').Addressable} params.addressable
     * @param {boolean} [params.lan]
     */
    constructor({ peerId, peerRouting, providers, peerStore, addressable, lan }: {
        peerId: PeerId;
        peerRouting: import('../../peer-routing').PeerRouting;
        providers: import('../../providers').Providers;
        peerStore: import('../../types').PeerStore;
        addressable: import('../../types').Addressable;
        lan?: boolean | undefined;
    });
    _peerId: import("peer-id");
    _peerRouting: import("../../peer-routing").PeerRouting;
    _providers: import("../../providers").Providers;
    _peerStore: import("../../types").PeerStore;
    _addressable: import("../../types").Addressable;
    _lan: boolean;
    /**
     * Process `GetProviders` DHT messages.
     *
     * @param {PeerId} peerId
     * @param {Message} msg
     */
    handle(peerId: PeerId, msg: Message): Promise<Message>;
    /**
     * @param {PeerId} peerId
     */
    _getAddresses(peerId: PeerId): import("multiaddr").Multiaddr[];
    /**
     * @param {PeerId[]} peerIds
     * @returns
     */
    _getPeers(peerIds: PeerId[]): {
        id: import("peer-id");
        multiaddrs: import("multiaddr").Multiaddr[];
    }[];
}
import { Message } from "../../message";
//# sourceMappingURL=get-providers.d.ts.map