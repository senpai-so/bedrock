export type Multiaddr = import('multiaddr').Multiaddr;
export type PeerData = import('../types').PeerData;
/**
 * @typedef {import('multiaddr').Multiaddr} Multiaddr
 * @typedef {import('../types').PeerData} PeerData
 */
export class PeerRouting {
    /**
     * @param {object} params
     * @param {import('peer-id')} params.peerId
     * @param {import('../routing-table').RoutingTable} params.routingTable
     * @param {import('../types').PeerStore} params.peerStore
     * @param {import('../network').Network} params.network
     * @param {import('libp2p-interfaces/src/types').DhtValidators} params.validators
     * @param {import('../query/manager').QueryManager} params.queryManager
     * @param {boolean} params.lan
     */
    constructor({ peerId, routingTable, peerStore, network, validators, queryManager, lan }: {
        peerId: import('peer-id');
        routingTable: import('../routing-table').RoutingTable;
        peerStore: import('../types').PeerStore;
        network: import('../network').Network;
        validators: import('libp2p-interfaces/src/types').DhtValidators;
        queryManager: import('../query/manager').QueryManager;
        lan: boolean;
    });
    _peerId: PeerId;
    _routingTable: import("../routing-table").RoutingTable;
    _peerStore: import("../types").PeerStore;
    _network: import("../network").Network;
    _validators: import("libp2p-interfaces/src/types").DhtValidators;
    _queryManager: import("../query/manager").QueryManager;
    _log: debug.Debugger & {
        error: debug.Debugger;
    };
    /**
     * Look if we are connected to a peer with the given id.
     * Returns its id and addresses, if found, otherwise `undefined`.
     *
     * @param {PeerId} peer
     */
    findPeerLocal(peer: PeerId): Promise<{
        id: PeerId;
        multiaddrs: import("multiaddr").Multiaddr[];
    } | undefined>;
    /**
     * Get a value via rpc call for the given parameters.
     *
     * @param {PeerId} peer
     * @param {Uint8Array} key
     * @param {object} [options]
     * @param {AbortSignal} [options.signal]
     */
    _getValueSingle(peer: PeerId, key: Uint8Array, options?: {
        signal?: AbortSignal | undefined;
    } | undefined): AsyncGenerator<import("../types").SendingQueryEvent | import("../types").PeerResponseEvent | import("../types").QueryErrorEvent | import("../types").DialingPeerEvent, void, unknown>;
    /**
     * Get the public key directly from a node.
     *
     * @param {PeerId} peer
     * @param {object} [options]
     * @param {AbortSignal} [options.signal]
     */
    getPublicKeyFromNode(peer: PeerId, options?: {
        signal?: AbortSignal | undefined;
    } | undefined): AsyncGenerator<import("../types").SendingQueryEvent | import("../types").PeerResponseEvent | import("../types").QueryErrorEvent | import("../types").ValueEvent | import("../types").DialingPeerEvent, void, unknown>;
    /**
     * Search for a peer with the given ID.
     *
     * @param {PeerId} id
     * @param {object} [options]
     * @param {AbortSignal} [options.signal]
     * @param {number} [options.queryFuncTimeout]
     */
    findPeer(id: PeerId, options?: {
        signal?: AbortSignal | undefined;
        queryFuncTimeout?: number | undefined;
    } | undefined): AsyncGenerator<import("../types").QueryEvent, void, unknown>;
    /**
     * Kademlia 'node lookup' operation
     *
     * @param {Uint8Array} key - the key to look up, could be a the bytes from a multihash or a peer ID
     * @param {object} [options]
     * @param {AbortSignal} [options.signal]
     * @param {number} [options.queryFuncTimeout]
     */
    getClosestPeers(key: Uint8Array, options?: {
        signal?: AbortSignal | undefined;
        queryFuncTimeout?: number | undefined;
    } | undefined): AsyncGenerator<import("../types").QueryEvent, void, undefined>;
    /**
     * Query a particular peer for the value for the given key.
     * It will either return the value or a list of closer peers.
     *
     * Note: The peerStore is updated with new addresses found for the given peer.
     *
     * @param {PeerId} peer
     * @param {Uint8Array} key
     * @param {object} [options]
     * @param {AbortSignal} [options.signal]
     */
    getValueOrPeers(peer: PeerId, key: Uint8Array, options?: {
        signal?: AbortSignal | undefined;
    } | undefined): AsyncGenerator<import("../types").SendingQueryEvent | import("../types").PeerResponseEvent | import("../types").QueryErrorEvent | import("../types").DialingPeerEvent, void, unknown>;
    /**
     * Verify a record, fetching missing public keys from the network.
     * Calls back with an error if the record is invalid.
     *
     * @param {import('../types').DHTRecord} record
     * @returns {Promise<void>}
     */
    _verifyRecordOnline({ key, value, timeReceived }: import('../types').DHTRecord): Promise<void>;
    /**
     * Get the nearest peers to the given query, but if closer
     * than self
     *
     * @param {Uint8Array} key
     * @param {PeerId} closerThan
     */
    getCloserPeersOffline(key: Uint8Array, closerThan: PeerId): Promise<{
        id: PeerId;
        multiaddrs: import("multiaddr").Multiaddr[];
    }[]>;
}
import PeerId = require("peer-id");
//# sourceMappingURL=index.d.ts.map