import { createFromPrivKey } from 'peer-id';
import errcode from 'err-code';
import debug from 'debug';
import { IpnsPublisher } from './publisher.js';
import { IpnsRepublisher } from './republisher.js';
import { IpnsResolver } from './resolver.js';
import { TLRU } from '../utils/tlru.js';
import { toString as uint8ArrayToString } from 'uint8arrays/to-string';
const log = Object.assign(debug('ipfs:ipns'), { error: debug('ipfs:ipns:error') });
const defaultRecordTtl = 60 * 1000;
export class IPNS {
  constructor(routing, datastore, peerId, keychain, options) {
    this.publisher = new IpnsPublisher(routing, datastore);
    this.republisher = new IpnsRepublisher(this.publisher, datastore, peerId, keychain, options);
    this.resolver = new IpnsResolver(routing);
    this.cache = new TLRU(1000);
    this.routing = routing;
  }
  async publish(privKey, value, lifetime = IpnsPublisher.defaultRecordLifetime) {
    try {
      const peerId = await createFromPrivKey(privKey.bytes);
      await this.publisher.publishWithEOL(privKey, value, lifetime);
      log(`IPNS value ${ uint8ArrayToString(value, 'base32') } was published correctly`);
      const id = peerId.toB58String();
      const ttEol = parseFloat(lifetime);
      const ttl = ttEol < defaultRecordTtl ? ttEol : defaultRecordTtl;
      this.cache.set(id, value, ttl);
      log(`IPNS value ${ uint8ArrayToString(value, 'base32') } was cached correctly`);
      return {
        name: id,
        value: value
      };
    } catch (err) {
      log.error(err);
      throw err;
    }
  }
  async resolve(name, options = {}) {
    if (typeof name !== 'string') {
      throw errcode(new Error('name received is not valid'), 'ERR_INVALID_NAME');
    }
    if (!options.nocache && !options.recursive) {
      const id = name.split('/')[2];
      const result = this.cache.get(id);
      if (result) {
        return result;
      }
    }
    try {
      const result = await this.resolver.resolve(name, options);
      log(`IPNS record from ${ name } was resolved correctly`);
      return result;
    } catch (err) {
      log.error(err);
      throw err;
    }
  }
  async initializeKeyspace(privKey, value) {
    return this.publish(privKey, value, IpnsPublisher.defaultRecordLifetime);
  }
}