import * as ipns from 'ipns';
import crypto from 'libp2p-crypto';
import PeerId from 'peer-id';
import errcode from 'err-code';
import debug from 'debug';
const log = Object.assign(debug('ipfs:ipns:republisher'), { error: debug('ipfs:ipns:republisher:error') });
const minute = 60 * 1000;
const hour = 60 * minute;
const defaultBroadcastInterval = 4 * hour;
const defaultRecordLifetime = 24 * hour;
export class IpnsRepublisher {
  constructor(publisher, datastore, peerId, keychain, options = { pass: '' }) {
    this._publisher = publisher;
    this._datastore = datastore;
    this._peerId = peerId;
    this._keychain = keychain;
    this._options = options;
    this._republishHandle = null;
  }
  async start() {
    if (this._republishHandle) {
      throw errcode(new Error('republisher is already running'), 'ERR_REPUBLISH_ALREADY_RUNNING');
    }
    const republishHandle = {
      _task: null,
      _inflightTask: null,
      _timeoutId: null,
      runPeriodically: period => {
        republishHandle._timeoutId = setTimeout(async () => {
          republishHandle._timeoutId = null;
          try {
            republishHandle._inflightTask = republishHandle._task();
            await republishHandle._inflightTask;
            if (republishHandle._task) {
              republishHandle.runPeriodically(period);
            }
          } catch (err) {
            log.error(err);
          }
        }, period());
      },
      cancel: async () => {
        if (republishHandle._timeoutId != null) {
          clearTimeout(republishHandle._timeoutId);
        }
        republishHandle._task = null;
        await republishHandle._inflightTask;
      }
    };
    const {privKey} = this._peerId;
    const {pass} = this._options;
    let firstRun = true;
    republishHandle._task = () => this._republishEntries(privKey, pass);
    republishHandle.runPeriodically(() => {
      if (firstRun) {
        firstRun = false;
        return this._options.initialBroadcastInterval || minute;
      }
      return this._options.broadcastInterval || defaultBroadcastInterval;
    });
    this._republishHandle = republishHandle;
  }
  async stop() {
    const republishHandle = this._republishHandle;
    if (!republishHandle) {
      throw errcode(new Error('republisher is not running'), 'ERR_REPUBLISH_NOT_RUNNING');
    }
    this._republishHandle = null;
    await republishHandle.cancel();
  }
  async _republishEntries(privateKey, pass) {
    try {
      await this._republishEntry(privateKey);
    } catch (err) {
      const errMsg = 'cannot republish entry for the node\'s private key';
      log.error(errMsg);
      return;
    }
    if (pass) {
      try {
        const keys = await this._keychain.listKeys();
        for (const key of keys) {
          if (key.name === 'self') {
            continue;
          }
          const pem = await this._keychain.exportKey(key.name, pass);
          const privKey = await crypto.keys.import(pem, pass);
          await this._republishEntry(privKey);
        }
      } catch (err) {
        log.error(err);
      }
    }
  }
  async _republishEntry(privateKey) {
    if (!privateKey || !privateKey.bytes) {
      throw errcode(new Error('invalid private key'), 'ERR_INVALID_PRIVATE_KEY');
    }
    try {
      const peerId = await PeerId.createFromPrivKey(privateKey.bytes);
      const value = await this._getPreviousValue(peerId);
      await this._publisher.publishWithEOL(privateKey, value, defaultRecordLifetime);
    } catch (err) {
      if (err.code === 'ERR_NO_ENTRY_FOUND') {
        return;
      }
      throw err;
    }
  }
  async _getPreviousValue(peerId) {
    if (!PeerId.isPeerId(peerId)) {
      throw errcode(new Error('invalid peer ID'), 'ERR_INVALID_PEER_ID');
    }
    try {
      const dsVal = await this._datastore.get(ipns.getLocalKey(peerId.id));
      if (!(dsVal instanceof Uint8Array)) {
        throw errcode(new Error('found ipns record that we couldn\'t process'), 'ERR_INVALID_IPNS_RECORD');
      }
      try {
        const record = ipns.unmarshal(dsVal);
        return record.value;
      } catch (err) {
        log.error(err);
        throw errcode(new Error('found ipns record that we couldn\'t convert to a value'), 'ERR_INVALID_IPNS_RECORD');
      }
    } catch (err) {
      if (err && err.notFound) {
        throw errcode(new Error(`no previous entry for record with id: ${ peerId.id }`), 'ERR_NO_ENTRY_FOUND');
      }
      throw err;
    }
  }
}