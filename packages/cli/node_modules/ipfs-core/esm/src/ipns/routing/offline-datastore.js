import { Key } from 'interface-datastore/key';
import { Record } from 'libp2p-record';
import errcode from 'err-code';
import debug from 'debug';
import { toString as uint8ArrayToString } from 'uint8arrays/to-string';
const log = Object.assign(debug('ipfs:ipns:offline-datastore'), { error: debug('ipfs:ipns:offline-datastore:error') });
export class OfflineDatastore {
  constructor(repo) {
    this._repo = repo;
    this.stores = [];
  }
  async put(key, value) {
    if (!(key instanceof Uint8Array)) {
      throw errcode(new Error('Offline datastore key must be a Uint8Array'), 'ERR_INVALID_KEY');
    }
    if (!(value instanceof Uint8Array)) {
      throw errcode(new Error('Offline datastore value must be a Uint8Array'), 'ERR_INVALID_VALUE');
    }
    let routingKey;
    try {
      routingKey = this._routingKey(key);
    } catch (err) {
      log.error(err);
      throw errcode(new Error('Not possible to generate the routing key'), 'ERR_GENERATING_ROUTING_KEY');
    }
    const record = new Record(key, value);
    return this._repo.datastore.put(routingKey, record.serialize());
  }
  async get(key) {
    if (!(key instanceof Uint8Array)) {
      throw errcode(new Error('Offline datastore key must be a Uint8Array'), 'ERR_INVALID_KEY');
    }
    let routingKey;
    try {
      routingKey = this._routingKey(key);
    } catch (err) {
      log.error(err);
      throw errcode(new Error('Not possible to generate the routing key'), 'ERR_GENERATING_ROUTING_KEY');
    }
    const res = await this._repo.datastore.get(routingKey);
    let record;
    try {
      record = Record.deserialize(res);
    } catch (err) {
      log.error(err);
      throw err;
    }
    return record.value;
  }
  _routingKey(key) {
    return new Key('/dht/record/' + uint8ArrayToString(key, 'base32'), false);
  }
}