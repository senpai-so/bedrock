import * as ipns from 'ipns';
import { base58btc } from 'multiformats/bases/base58';
import { PubsubDatastore } from 'datastore-pubsub';
import { fromString as uint8ArrayFromString } from 'uint8arrays/from-string';
import { toString as uint8ArrayToString } from 'uint8arrays/to-string';
import errcode from 'err-code';
import debug from 'debug';
const log = Object.assign(debug('ipfs:ipns:pubsub'), { error: debug('ipfs:ipns:pubsub:error') });
export class IpnsPubsubDatastore {
  constructor(pubsub, localDatastore, peerId) {
    this._subscriptions = {};
    this._handleSubscriptionKey = this._handleSubscriptionKey.bind(this);
    this._pubsubDs = new PubsubDatastore(pubsub, localDatastore, peerId, ipns.validator, this._handleSubscriptionKey);
  }
  async put(key, value) {
    try {
      await this._pubsubDs.put(key, value);
    } catch (err) {
      log.error(err);
      throw err;
    }
  }
  async get(key) {
    let res;
    let err;
    try {
      res = await this._pubsubDs.get(key);
    } catch (e) {
      err = e;
    }
    const ns = key.slice(0, ipns.namespaceLength);
    if (uint8ArrayToString(ns) === ipns.namespace) {
      const stringifiedTopic = base58btc.encode(key).substring(1);
      const id = base58btc.encode(key.slice(ipns.namespaceLength)).substring(1);
      this._subscriptions[stringifiedTopic] = id;
      log(`subscribed to pubsub topic ${ stringifiedTopic }, id ${ id }`);
    }
    if (err) {
      throw err;
    }
    return res;
  }
  _handleSubscriptionKey(key) {
    if (key instanceof Uint8Array) {
      key = uint8ArrayToString(key, 'base58btc');
    }
    const subscriber = this._subscriptions[key];
    if (!subscriber) {
      throw errcode(new Error(`key ${ key } does not correspond to a subscription`), 'ERR_INVALID_KEY');
    }
    let keys;
    try {
      keys = ipns.getIdKeys(uint8ArrayFromString(subscriber, 'base58btc'));
    } catch (err) {
      log.error(err);
      throw err;
    }
    return keys.routingKey.uint8Array();
  }
  getSubscriptions() {
    const subscriptions = Object.values(this._subscriptions).filter(Boolean);
    return subscriptions.map(sub => `${ ipns.namespace }${ sub }`);
  }
  async cancel(name) {
    if (typeof name !== 'string') {
      throw errcode(new Error('invalid subscription name'), 'ERR_INVALID_SUBSCRIPTION_NAME');
    }
    if (name.startsWith(ipns.namespace)) {
      name = name.substring(ipns.namespaceLength);
    }
    const stringifiedTopic = Object.keys(this._subscriptions).find(key => this._subscriptions[key] === name);
    if (!stringifiedTopic) {
      return { canceled: false };
    }
    const bufTopic = uint8ArrayFromString(stringifiedTopic);
    this._pubsubDs.unsubscribe(bufTopic);
    delete this._subscriptions[stringifiedTopic];
    log(`unsubscribed pubsub ${ stringifiedTopic }: ${ name }`);
    return { canceled: true };
  }
}