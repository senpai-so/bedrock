import * as ipns from 'ipns';
import PeerId from 'peer-id';
import errcode from 'err-code';
import debug from 'debug';
import { toString as uint8ArrayToString } from 'uint8arrays/to-string';
import * as Errors from 'datastore-core/errors';
const log = Object.assign(debug('ipfs:ipns:resolver'), { error: debug('ipfs:ipns:resolver:error') });
const ERR_NOT_FOUND = Errors.notFoundError().code;
const defaultMaximumRecursiveDepth = 32;
export class IpnsResolver {
  constructor(routing) {
    this._routing = routing;
  }
  async resolve(name, options = {}) {
    if (typeof name !== 'string') {
      throw errcode(new Error('invalid name'), 'ERR_INVALID_NAME');
    }
    const recursive = options.recursive && options.recursive.toString() === 'true';
    const nameSegments = name.split('/');
    if (nameSegments.length !== 3 || nameSegments[0] !== '') {
      throw errcode(new Error('invalid name'), 'ERR_INVALID_NAME');
    }
    const key = nameSegments[2];
    let depth = Infinity;
    if (recursive) {
      depth = defaultMaximumRecursiveDepth;
    }
    const res = await this.resolver(key, depth);
    log(`${ name } was locally resolved correctly`);
    return res;
  }
  async resolver(name, depth) {
    if (depth === 0) {
      const errMsg = `could not resolve name (recursion limit of ${ defaultMaximumRecursiveDepth } exceeded)`;
      log.error(errMsg);
      throw errcode(new Error(errMsg), 'ERR_RESOLVE_RECURSION_LIMIT');
    }
    const res = await this._resolveName(name);
    const nameSegments = res.split('/');
    if (nameSegments[1] === 'ipfs' || !depth) {
      return res;
    }
    return this.resolver(nameSegments[2], depth - 1);
  }
  async _resolveName(name) {
    const peerId = PeerId.parse(name);
    const {routingKey} = ipns.getIdKeys(peerId.toBytes());
    let record;
    try {
      record = await this._routing.get(routingKey.uint8Array());
    } catch (err) {
      log.error('could not get record from routing', err);
      if (err.code === ERR_NOT_FOUND) {
        throw errcode(new Error(`record requested for ${ name } was not found in the network`), 'ERR_NO_RECORD_FOUND');
      }
      throw errcode(new Error(`unexpected error getting the ipns record ${ peerId.toString() }`), 'ERR_UNEXPECTED_ERROR_GETTING_RECORD');
    }
    let ipnsEntry;
    try {
      ipnsEntry = ipns.unmarshal(record);
    } catch (err) {
      log.error('could not unmarshal record', err);
      throw errcode(new Error('found ipns record that we couldn\'t convert to a value'), 'ERR_INVALID_RECORD_RECEIVED');
    }
    return this._validateRecord(peerId, ipnsEntry);
  }
  async _validateRecord(peerId, ipnsEntry) {
    const pubKey = await ipns.extractPublicKey(peerId, ipnsEntry);
    await ipns.validate(pubKey, ipnsEntry);
    return uint8ArrayToString(ipnsEntry.value);
  }
}