import toUri from 'multiaddr-to-uri';
import debug from 'debug';
import shuffle from 'array-shuffle';
import { AbortController } from 'native-abort-controller';
import { preload } from 'ipfs-core-config/preload';
import hashlru from 'hashlru';
const log = Object.assign(debug('ipfs:preload'), { error: debug('ipfs:preload:error') });
export function createPreloader(options = {}) {
  options.enabled = Boolean(options.enabled);
  options.addresses = options.addresses || [];
  options.cache = options.cache || 1000;
  if (!options.enabled || !options.addresses.length) {
    log('preload disabled');
    const api = () => {
    };
    return Object.assign(api, {
      start: () => {
      },
      stop: () => {
      }
    });
  }
  let stopped = true;
  let requests = [];
  const apiUris = options.addresses.map(toUri);
  const cache = hashlru(options.cache);
  const api = async cid => {
    try {
      if (stopped) {
        throw new Error(`preload ${ cid } but preloader is not started`);
      }
      const path = cid.toString();
      if (cache.has(path)) {
        return;
      }
      cache.set(path, true);
      const fallbackApiUris = shuffle(apiUris);
      let success = false;
      const now = Date.now();
      for (const uri of fallbackApiUris) {
        if (stopped)
          throw new Error(`preload aborted for ${ path }`);
        let controller;
        try {
          controller = new AbortController();
          requests = requests.concat(controller);
          await preload(`${ uri }/api/v0/refs?r=true&arg=${ encodeURIComponent(path) }`, { signal: controller.signal });
          success = true;
        } catch (err) {
          if (err.type !== 'aborted')
            log.error(err);
        } finally {
          requests = requests.filter(r => r !== controller);
        }
        if (success)
          break;
      }
      log(`${ success ? '' : 'un' }successfully preloaded ${ path } in ${ Date.now() - now }ms`);
    } catch (err) {
      log.error(err);
    }
  };
  api.start = () => {
    stopped = false;
  };
  api.stop = () => {
    stopped = true;
    log(`aborting ${ requests.length } pending preload request(s)`);
    requests.forEach(r => r.abort());
    requests = [];
  };
  return api;
}