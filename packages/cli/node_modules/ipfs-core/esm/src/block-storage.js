import { BaseBlockstore } from 'blockstore-core';
import merge from 'it-merge';
import pushable from 'it-pushable';
import filter from 'it-filter';
export class BlockStorage extends BaseBlockstore {
  constructor(blockstore, bitswap) {
    super();
    this.child = blockstore;
    this.bitswap = bitswap;
  }
  open() {
    return this.child.open();
  }
  close() {
    return this.child.close();
  }
  unwrap() {
    return this.child;
  }
  async put(cid, block, options = {}) {
    if (await this.has(cid)) {
      return;
    }
    if (this.bitswap.isStarted()) {
      await this.bitswap.put(cid, block, options);
    } else {
      await this.child.put(cid, block, options);
    }
  }
  async *putMany(blocks, options = {}) {
    const missingBlocks = filter(blocks, async ({key}) => {
      return !await this.has(key);
    });
    if (this.bitswap.isStarted()) {
      yield* this.bitswap.putMany(missingBlocks, options);
    } else {
      yield* this.child.putMany(missingBlocks, options);
    }
  }
  async get(cid, options = {}) {
    if (!await this.has(cid) && this.bitswap.isStarted()) {
      return this.bitswap.get(cid, options);
    } else {
      return this.child.get(cid, options);
    }
  }
  async *getMany(cids, options = {}) {
    const getFromBitswap = pushable();
    const getFromChild = pushable();
    Promise.resolve().then(async () => {
      for await (const cid of cids) {
        if (!await this.has(cid) && this.bitswap.isStarted()) {
          getFromBitswap.push(cid);
        } else {
          getFromChild.push(cid);
        }
      }
      getFromBitswap.end();
      getFromChild.end();
    });
    yield* merge(this.bitswap.getMany(getFromBitswap, options), this.child.getMany(getFromChild, options));
  }
  async delete(cid, options) {
    await this.child.delete(cid, options);
  }
  async *deleteMany(cids, options) {
    yield* this.child.deleteMany(cids, options);
  }
  async has(cid, options = {}) {
    return this.child.has(cid, options);
  }
  async *query(q, options = {}) {
    yield* this.child.query(q, options);
  }
  async *queryKeys(q, options = {}) {
    yield* this.child.queryKeys(q, options);
  }
}