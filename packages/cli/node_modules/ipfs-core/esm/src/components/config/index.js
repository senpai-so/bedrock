import { withTimeoutOption } from 'ipfs-core-utils/with-timeout-option';
import debug from 'debug';
import { profiles } from './profiles.js';
const log = debug('ipfs:core:config');
export function createConfig({repo}) {
  return {
    getAll: withTimeoutOption(getAll),
    get: withTimeoutOption(get),
    set: withTimeoutOption(set),
    replace: withTimeoutOption(replace),
    profiles: {
      apply: withTimeoutOption(applyProfile),
      list: withTimeoutOption(listProfiles)
    }
  };
  async function getAll(options = {}) {
    return repo.config.getAll(options);
  }
  async function get(key, options) {
    if (!key) {
      return Promise.reject(new Error('key argument is required'));
    }
    return repo.config.get(key, options);
  }
  async function set(key, value, options) {
    return repo.config.set(key, value, options);
  }
  async function replace(value, options) {
    return repo.config.replace(value, options);
  }
  async function applyProfile(profileName, options = { dryRun: false }) {
    const {dryRun} = options;
    const profile = profiles[profileName];
    if (!profile) {
      throw new Error(`No profile with name '${ profileName }' exists`);
    }
    try {
      const oldCfg = await repo.config.getAll(options);
      let newCfg = JSON.parse(JSON.stringify(oldCfg));
      newCfg = profile.transform(newCfg);
      if (!dryRun) {
        await repo.config.replace(newCfg, options);
      }
      delete oldCfg.Identity.PrivKey;
      delete newCfg.Identity.PrivKey;
      return {
        original: oldCfg,
        updated: newCfg
      };
    } catch (err) {
      log(err);
      throw new Error(`Could not apply profile '${ profileName }' to config: ${ err.message }`);
    }
  }
}
async function listProfiles(_options) {
  return Object.keys(profiles).map(name => ({
    name,
    description: profiles[name].description
  }));
}