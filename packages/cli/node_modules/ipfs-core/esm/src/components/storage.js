import debug from 'debug';
import { createRepo } from 'ipfs-core-config/repo';
import getDefaultConfig from 'ipfs-core-config/config';
import { fromString as uint8ArrayFromString } from 'uint8arrays/from-string';
import { toString as uint8ArrayToString } from 'uint8arrays/to-string';
import PeerId from 'peer-id';
import mergeOpts from 'merge-options';
import { profiles as configProfiles } from './config/profiles.js';
import {
  NotEnabledError,
  NotInitializedError
} from '../errors.js';
import { createLibp2p } from './libp2p.js';
import { ERR_REPO_NOT_INITIALIZED } from 'ipfs-repo/errors';
const mergeOptions = mergeOpts.bind({ ignoreUndefined: true });
const log = debug('ipfs:components:peer:storage');
export class Storage {
  constructor(peerId, keychain, repo, print, isNew) {
    this.print = print;
    this.peerId = peerId;
    this.keychain = keychain;
    this.repo = repo;
    this.print = print;
    this.isNew = isNew;
  }
  static async start(print, codecs, options) {
    const {
      repoAutoMigrate,
      repo: inputRepo,
      onMigrationProgress
    } = options;
    const repo = typeof inputRepo === 'string' || inputRepo == null ? createRepo(print, codecs, {
      path: inputRepo,
      autoMigrate: repoAutoMigrate,
      onMigrationProgress: onMigrationProgress
    }) : inputRepo;
    const {peerId, keychain, isNew} = await loadRepo(print, repo, options);
    return new Storage(peerId, keychain, repo, print, isNew);
  }
}
const loadRepo = async (print, repo, options) => {
  if (!repo.closed) {
    return {
      ...await configureRepo(repo, options),
      isNew: false
    };
  }
  try {
    await repo.open();
    return {
      ...await configureRepo(repo, options),
      isNew: false
    };
  } catch (err) {
    if (err.code !== ERR_REPO_NOT_INITIALIZED) {
      throw err;
    }
    if (options.init && options.init.allowNew === false) {
      throw new NotEnabledError('Initialization of new repos disabled by config, pass `config.init.isNew: true` to enable it');
    }
    return {
      ...await initRepo(print, repo, options),
      isNew: true
    };
  }
};
const initRepo = async (print, repo, options) => {
  const initOptions = options.init || {};
  const exists = await repo.exists();
  log('repo exists?', exists);
  if (exists === true) {
    throw new Error('repo already exists');
  }
  const peerId = initOptions.privateKey ? await decodePeerId(initOptions.privateKey) : await initPeerId(print, initOptions);
  const identity = peerIdToIdentity(peerId);
  log('peer identity: %s', identity.PeerID);
  const config = {
    ...mergeOptions(applyProfiles(getDefaultConfig(), initOptions.profiles), options.config),
    Identity: identity
  };
  await repo.init(config);
  await repo.open();
  log('repo opened');
  const keychainConfig = { pass: options.pass };
  try {
    keychainConfig.dek = await repo.config.get('Keychain.DEK');
  } catch (err) {
    if (err.code !== 'ERR_NOT_FOUND') {
      throw err;
    }
  }
  const libp2p = await createLibp2p({
    options: undefined,
    multiaddrs: undefined,
    peerId,
    repo,
    config,
    keychainConfig
  });
  if (libp2p.keychain && libp2p.keychain.opts) {
    await libp2p.loadKeychain();
    await repo.config.set('Keychain', { DEK: libp2p.keychain.opts.dek });
  }
  return {
    peerId,
    keychain: libp2p.keychain
  };
};
const decodePeerId = peerId => {
  log('using user-supplied private-key');
  return typeof peerId === 'object' ? peerId : PeerId.createFromPrivKey(uint8ArrayFromString(peerId, 'base64pad'));
};
const initPeerId = (print, {algorithm = 'Ed25519', bits = 2048}) => {
  print('generating %s keypair...', algorithm);
  return PeerId.create({
    keyType: algorithm,
    bits
  });
};
const peerIdToIdentity = peerId => ({
  PeerID: peerId.toB58String(),
  PrivKey: uint8ArrayToString(peerId.privKey.bytes, 'base64pad')
});
const configureRepo = async (repo, options) => {
  const config = options.config;
  const profiles = options.init && options.init.profiles || [];
  const pass = options.pass;
  const original = await repo.config.getAll();
  const changed = mergeConfigs(applyProfiles(original, profiles), config);
  if (original !== changed) {
    await repo.config.replace(changed);
  }
  if (!changed.Identity || !changed.Identity.PrivKey) {
    throw new NotInitializedError('No private key was found in the config, please intialize the repo');
  }
  const peerId = await PeerId.createFromPrivKey(changed.Identity.PrivKey);
  const libp2p = await createLibp2p({
    options: undefined,
    multiaddrs: undefined,
    peerId,
    repo,
    config: changed,
    keychainConfig: {
      pass,
      ...changed.Keychain
    }
  });
  if (libp2p.keychain) {
    await libp2p.loadKeychain();
  }
  return {
    peerId,
    keychain: libp2p.keychain
  };
};
const mergeConfigs = (config, changes) => changes ? mergeOptions(config, changes) : config;
const applyProfiles = (config, profiles) => {
  return (profiles || []).reduce((config, name) => {
    const profile = configProfiles[name];
    if (!profile) {
      throw new Error(`Could not find profile with name '${ name }'`);
    }
    log('applying profile %s', name);
    return profile.transform(config);
  }, config);
};