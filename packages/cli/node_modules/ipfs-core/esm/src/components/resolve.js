import isIpfs from 'is-ipfs';
import { CID } from 'multiformats/cid';
import PeerId from 'peer-id';
import { withTimeoutOption } from 'ipfs-core-utils/with-timeout-option';
import { resolve as res } from '../utils.js';
export function createResolve({repo, codecs, bases, name}) {
  async function resolve(path, opts = {}) {
    if (!isIpfs.path(path)) {
      throw new Error('invalid argument ' + path);
    }
    if (isIpfs.ipnsPath(path)) {
      for await (const resolvedPath of name.resolve(path, opts)) {
        path = resolvedPath;
      }
    }
    const [, schema, hash, ...rest] = path.split('/');
    const base = opts.cidBase ? await bases.getBase(opts.cidBase) : undefined;
    const bytes = parseBytes(hash);
    if (rest.length === 0) {
      const str = base ? base.encoder.encode(bytes) : hash;
      return `/${ schema }/${ str }`;
    }
    const cid = CID.decode(bytes);
    path = rest.join('/');
    const results = res(cid, path, codecs, repo, opts);
    let value = cid;
    let remainderPath = path;
    for await (const result of results) {
      if (CID.asCID(result.value)) {
        value = result.value;
        remainderPath = result.remainderPath;
      }
    }
    return `/ipfs/${ value.toString(base && base.encoder) }${ remainderPath ? '/' + remainderPath : '' }`;
  }
  return withTimeoutOption(resolve);
}
function parseBytes(str) {
  try {
    return PeerId.parse(str).toBytes();
  } catch {
    return CID.parse(str).bytes;
  }
}