import { CID } from 'multiformats/cid';
import { createUnsafe } from 'multiformats/block';
import { base58btc } from 'multiformats/bases/base58';
import { CarWriter } from '@ipld/car/writer';
import { withTimeoutOption } from 'ipfs-core-utils/with-timeout-option';
import debug from 'debug';
import * as raw from 'multiformats/codecs/raw';
import * as json from 'multiformats/codecs/json';
const log = debug('ipfs:components:dag:import');
const NO_LINKS_CODECS = [
  raw.code,
  json.code
];
export function createExport({repo, preload, codecs}) {
  async function* dagExport(root, options = {}) {
    if (options.preload !== false) {
      preload(root);
    }
    const cid = CID.asCID(root);
    if (!cid) {
      throw new Error(`Unexpected error converting CID type: ${ root }`);
    }
    log(`Exporting ${ cid } as car`);
    const {writer, out} = await CarWriter.create([cid]);
    let err = null;
    (async () => {
      try {
        await traverseWrite(repo, {
          signal: options.signal,
          timeout: options.timeout
        }, cid, writer, codecs);
      } catch (e) {
        err = e;
      } finally {
        writer.close();
      }
    })();
    for await (const chunk of out) {
      if (err) {
        break;
      }
      yield chunk;
    }
    if (err) {
      throw err;
    }
  }
  return withTimeoutOption(dagExport);
}
async function traverseWrite(repo, options, cid, writer, codecs, seen = new Set()) {
  const b58Cid = cid.toString(base58btc);
  if (seen.has(b58Cid)) {
    return;
  }
  const block = await getBlock(repo, options, cid, codecs);
  log(`Adding block ${ cid } to car`);
  await writer.put(block);
  seen.add(b58Cid);
  for (const link of block.links) {
    await traverseWrite(repo, options, link, writer, codecs, seen);
  }
}
async function getBlock(repo, options, cid, codecs) {
  const bytes = await repo.blocks.get(cid, options);
  let links = [];
  const codec = await codecs.getCodec(cid.code);
  if (codec) {
    const block = createUnsafe({
      bytes,
      cid,
      codec
    });
    links = [...block.links()].map(l => l[1]);
  } else if (!NO_LINKS_CODECS.includes(cid.code)) {
    throw new Error(`Can't decode links in block with codec 0x${ cid.code.toString(16) } to form complete DAG`);
  }
  return {
    cid,
    bytes,
    links
  };
}