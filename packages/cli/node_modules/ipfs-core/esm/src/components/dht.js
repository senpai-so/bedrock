import PeerId from 'peer-id';
import errCode from 'err-code';
import { NotEnabledError } from '../errors.js';
import get from 'dlv';
import { withTimeoutOption } from 'ipfs-core-utils/with-timeout-option';
import map from 'it-map';
import { CID } from 'multiformats/cid';
import { base58btc } from 'multiformats/bases/base58';
import { base36 } from 'multiformats/bases/base36';
import { concat as uint8ArrayConcat } from 'uint8arrays/concat';
import { fromString as uint8ArrayFromString } from 'uint8arrays/from-string';
const IPNS_PREFIX = '/ipns/';
function toDHTKey(str) {
  if (str.startsWith(IPNS_PREFIX)) {
    str = str.substring(IPNS_PREFIX.length);
  }
  let buf;
  if (str[0] === '1' || str[0] === 'Q') {
    str = `z${ str }`;
  }
  if (str[0] === 'z') {
    buf = base58btc.decode(str);
  }
  if (str[0] === 'k') {
    buf = base36.decode(str);
  }
  if (!buf) {
    throw new Error('Could not parse string');
  }
  if (buf[0] !== 1 && buf[1] !== 114) {
    buf = uint8ArrayConcat([
      [
        1,
        114
      ],
      buf
    ]);
  }
  if (buf.length !== 40) {
    throw new Error('Incorrect length ' + buf.length);
  }
  return uint8ArrayConcat([
    uint8ArrayFromString(IPNS_PREFIX),
    buf.subarray(2)
  ]);
}
function mapEvent(event) {
  if (event.name === 'SENDING_QUERY') {
    return {
      type: event.type,
      name: event.name,
      to: event.to.toB58String()
    };
  }
  if (event.name === 'PEER_RESPONSE') {
    return {
      type: event.type,
      name: event.name,
      messageType: event.messageType,
      messageName: event.messageName,
      closer: event.closer.map(({id, multiaddrs}) => ({
        id: id.toB58String(),
        multiaddrs
      })),
      providers: event.providers.map(({id, multiaddrs}) => ({
        id: id.toB58String(),
        multiaddrs
      })),
      record: event.record,
      from: event.from.toB58String()
    };
  }
  if (event.name === 'FINAL_PEER') {
    return {
      type: event.type,
      name: event.name,
      from: event.from.toB58String(),
      peer: {
        id: event.peer.id.toB58String(),
        multiaddrs: event.peer.multiaddrs
      }
    };
  }
  if (event.name === 'QUERY_ERROR') {
    return {
      type: event.type,
      name: event.name,
      error: event.error,
      from: event.from.toB58String()
    };
  }
  if (event.name === 'PROVIDER') {
    return {
      type: event.type,
      name: event.name,
      providers: event.providers.map(({id, multiaddrs}) => ({
        id: id.toB58String(),
        multiaddrs
      })),
      from: event.from.toB58String()
    };
  }
  if (event.name === 'VALUE') {
    return {
      type: event.type,
      name: event.name,
      value: event.value,
      from: event.from.toB58String()
    };
  }
  if (event.name === 'ADDING_PEER') {
    return {
      type: event.type,
      name: event.name,
      peer: event.peer.toB58String()
    };
  }
  if (event.name === 'DIALING_PEER') {
    return {
      type: event.type,
      name: event.name,
      peer: event.peer.toB58String()
    };
  }
  throw errCode(new Error('Unknown DHT event type'), 'ERR_UNKNOWN_DHT_EVENT');
}
export function createDht({network, repo, peerId}) {
  const {get, put, findProvs, findPeer, provide, query} = {
    async *get(key, options = {}) {
      const {libp2p} = await use(network, peerId, options);
      const dhtKey = key instanceof Uint8Array ? key : toDHTKey(key);
      yield* map(libp2p._dht.get(dhtKey, options), mapEvent);
    },
    async *put(key, value, options) {
      const {libp2p} = await use(network, peerId, options);
      const dhtKey = key instanceof Uint8Array ? key : toDHTKey(key);
      yield* map(libp2p._dht.put(dhtKey, value), mapEvent);
    },
    async *findProvs(cid, options = {}) {
      const {libp2p} = await use(network, peerId, options);
      yield* map(libp2p._dht.findProviders(cid, { signal: options.signal }), mapEvent);
    },
    async *findPeer(peerIdToFind, options = {}) {
      const {libp2p} = await use(network, peerId, options);
      yield* map(libp2p._dht.findPeer(PeerId.parse(peerIdToFind), { signal: options.signal }), mapEvent);
    },
    async *provide(cid, options = { recursive: false }) {
      const {libp2p} = await use(network, peerId, options);
      const hasBlock = await repo.blocks.has(cid);
      if (!hasBlock) {
        throw errCode(new Error('block(s) not found locally, cannot provide'), 'ERR_BLOCK_NOT_FOUND');
      }
      if (options.recursive) {
        throw errCode(new Error('not implemented yet'), 'ERR_NOT_IMPLEMENTED_YET');
      }
      yield* map(libp2p._dht.provide(cid), mapEvent);
    },
    async *query(peerIdToQuery, options = {}) {
      const {libp2p} = await use(network, peerId, options);
      let bytes;
      const asCid = CID.asCID(peerIdToQuery);
      if (asCid != null) {
        bytes = asCid.multihash.bytes;
      } else {
        bytes = PeerId.parse(peerIdToQuery.toString()).toBytes();
      }
      yield* map(libp2p._dht.getClosestPeers(bytes, options), mapEvent);
    }
  };
  return {
    get: withTimeoutOption(get),
    put: withTimeoutOption(put),
    findProvs: withTimeoutOption(findProvs),
    findPeer: withTimeoutOption(findPeer),
    provide: withTimeoutOption(provide),
    query: withTimeoutOption(query)
  };
}
const use = async (network, peerId, options) => {
  const net = await network.use(options);
  if (get(net.libp2p, '_config.dht.enabled', false)) {
    return net;
  } else {
    const fn = async function* () {
      yield {
        from: peerId,
        name: 'QUERY_ERROR',
        type: 3,
        error: new NotEnabledError('dht not enabled')
      };
    };
    return {
      libp2p: {
        _dht: {
          get: fn,
          put: fn,
          findProvs: fn,
          findPeer: fn,
          provide: fn,
          query: fn
        }
      }
    };
  }
};