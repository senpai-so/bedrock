import { IPNS } from '../ipns/index.js';
import { createRouting } from '../ipns/routing/config.js';
import { OfflineDatastore } from '../ipns/routing/offline-datastore.js';
import {
  NotInitializedError,
  AlreadyInitializedError
} from '../errors.js';
import debug from 'debug';
const log = debug('ipfs:components:ipns');
export class IPNSAPI {
  constructor(options = { pass: '' }) {
    this.options = options;
    this.offline = null;
    this.online = null;
  }
  getIPNS() {
    const ipns = this.online || this.offline;
    if (ipns) {
      return ipns;
    } else {
      throw new NotInitializedError();
    }
  }
  get routing() {
    return this.getIPNS().routing;
  }
  startOffline({repo, peerId, keychain}) {
    if (this.offline != null) {
      throw new AlreadyInitializedError();
    }
    log('initializing IPNS keyspace');
    const routing = new OfflineDatastore(repo);
    const ipns = new IPNS(routing, repo.datastore, peerId, keychain, this.options);
    this.offline = ipns;
  }
  async startOnline({libp2p, repo, peerId, keychain}) {
    if (this.online != null) {
      throw new AlreadyInitializedError();
    }
    const routing = createRouting({
      libp2p,
      repo,
      peerId,
      options: this.options
    });
    const ipns = new IPNS(routing, repo.datastore, peerId, keychain, this.options);
    await ipns.republisher.start();
    this.online = ipns;
  }
  async stop() {
    const ipns = this.online;
    if (ipns) {
      await ipns.republisher.stop();
      this.online = null;
    }
  }
  publish(privKey, value, lifetime) {
    return this.getIPNS().publish(privKey, value, lifetime);
  }
  resolve(name, options) {
    return this.getIPNS().resolve(name, options);
  }
  initializeKeyspace(privKey, value) {
    return this.getIPNS().initializeKeyspace(privKey, value);
  }
}