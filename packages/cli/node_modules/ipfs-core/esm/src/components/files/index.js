import { createLock } from './utils/create-lock.js';
import isIpfs from 'is-ipfs';
import { createStat } from './stat.js';
import { createChmod } from './chmod.js';
import { createCp } from './cp.js';
import { createFlush } from './flush.js';
import { createMkdir } from './mkdir.js';
import { createMv } from './mv.js';
import { createRm } from './rm.js';
import { createTouch } from './touch.js';
import { createRead } from './read.js';
import { createWrite } from './write.js';
import { createLs } from './ls.js';
const readOperations = { stat: createStat };
const writeOperations = {
  chmod: createChmod,
  cp: createCp,
  flush: createFlush,
  mkdir: createMkdir,
  mv: createMv,
  rm: createRm,
  touch: createTouch
};
const unwrappedOperations = {
  write: createWrite,
  read: createRead,
  ls: createLs
};
const wrap = ({options, mfs, operations, lock}) => {
  Object.keys(operations).forEach(key => {
    mfs[key] = lock(operations[key](options));
  });
};
const defaultOptions = {
  repoOwner: true,
  repo: null
};
function createMfs(options) {
  const {repoOwner} = Object.assign({}, defaultOptions || {}, options);
  const lock = createLock(repoOwner);
  const readLock = operation => {
    return lock.readLock(operation);
  };
  const writeLock = operation => {
    return lock.writeLock(operation);
  };
  const mfs = {};
  wrap({
    options,
    mfs,
    operations: readOperations,
    lock: readLock
  });
  wrap({
    options,
    mfs,
    operations: writeOperations,
    lock: writeLock
  });
  Object.keys(unwrappedOperations).forEach(key => {
    mfs[key] = unwrappedOperations[key](options);
  });
  return mfs;
}
export function createFiles({
  repo,
  preload,
  hashers,
  options: constructorOptions
}) {
  const methods = createMfs({
    repo,
    repoOwner: Boolean(constructorOptions.repoOwner),
    hashers
  });
  const withPreload = fn => {
    const wrapped = (...args) => {
      const paths = args.filter(arg => isIpfs.ipfsPath(arg) || isIpfs.cid(arg));
      if (paths.length) {
        const options = args[args.length - 1];
        if (options && options.preload !== false) {
          paths.forEach(path => preload(path));
        }
      }
      return fn(...args);
    };
    return wrapped;
  };
  return {
    ...methods,
    chmod: methods.chmod,
    cp: withPreload(methods.cp),
    mkdir: methods.mkdir,
    stat: withPreload(methods.stat),
    rm: methods.rm,
    read: withPreload(methods.read),
    touch: methods.touch,
    write: methods.write,
    mv: withPreload(methods.mv),
    flush: methods.flush,
    ls: withPreload(async function* (...args) {
      for await (const file of methods.ls(...args)) {
        yield {
          ...file,
          size: file.size || 0
        };
      }
    })
  };
}