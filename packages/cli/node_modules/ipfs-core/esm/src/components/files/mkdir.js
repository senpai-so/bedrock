import errCode from 'err-code';
import debug from 'debug';
import { exporter } from 'ipfs-unixfs-exporter';
import { createNode } from './utils/create-node.js';
import { toPathComponents } from './utils/to-path-components.js';
import { updateMfsRoot } from './utils/update-mfs-root.js';
import { updateTree } from './utils/update-tree.js';
import { addLink } from './utils/add-link.js';
import { loadMfsRoot } from './utils/with-mfs-root.js';
import mergeOpts from 'merge-options';
import { withTimeoutOption } from 'ipfs-core-utils/with-timeout-option';
const mergeOptions = mergeOpts.bind({ ignoreUndefined: true });
const log = debug('ipfs:mfs:mkdir');
const defaultOptions = {
  parents: false,
  hashAlg: 'sha2-256',
  cidVersion: 0,
  shardSplitThreshold: 1000,
  flush: true
};
export function createMkdir(context) {
  async function mfsMkdir(path, options = {}) {
    const opts = mergeOptions(defaultOptions, options);
    if (!path) {
      throw new Error('no path given to Mkdir');
    }
    path = path.trim();
    if (path === '/') {
      if (opts.parents) {
        return;
      }
      throw errCode(new Error('cannot create directory \'/\': Already exists'), 'ERR_INVALID_PATH');
    }
    if (path.substring(0, 1) !== '/') {
      throw errCode(new Error('paths must start with a leading slash'), 'ERR_INVALID_PATH');
    }
    log(`Creating ${ path }`);
    const pathComponents = toPathComponents(path);
    if (pathComponents[0] === 'ipfs') {
      throw errCode(new Error('path cannot have the prefix \'ipfs\''), 'ERR_INVALID_PATH');
    }
    const root = await loadMfsRoot(context, opts);
    let parent;
    const trail = [];
    const emptyDir = await createNode(context, 'directory', opts);
    for (let i = 0; i <= pathComponents.length; i++) {
      const subPathComponents = pathComponents.slice(0, i);
      const subPath = `/ipfs/${ root }/${ subPathComponents.join('/') }`;
      try {
        parent = await exporter(subPath, context.repo.blocks);
        if (parent.type !== 'file' && parent.type !== 'directory') {
          throw errCode(new Error(`${ path } was not a UnixFS node`), 'ERR_NOT_UNIXFS');
        }
        if (i === pathComponents.length) {
          if (opts.parents) {
            return;
          }
          throw errCode(new Error('file already exists'), 'ERR_ALREADY_EXISTS');
        }
        trail.push({
          name: parent.name,
          cid: parent.cid
        });
      } catch (err) {
        if (err.code === 'ERR_NOT_FOUND') {
          if (i < pathComponents.length && !opts.parents) {
            throw errCode(new Error(`Intermediate directory path ${ subPath } does not exist, use the -p flag to create it`), 'ERR_NOT_FOUND');
          }
          await addEmptyDir(context, subPathComponents[subPathComponents.length - 1], emptyDir, trail[trail.length - 1], trail, opts);
        } else {
          throw err;
        }
      }
    }
    const newRootCid = await updateTree(context, trail, opts);
    await updateMfsRoot(context, newRootCid, opts);
  }
  return withTimeoutOption(mfsMkdir);
}
const addEmptyDir = async (context, childName, emptyDir, parent, trail, options) => {
  log(`Adding empty dir called ${ childName } to ${ parent.cid }`);
  const result = await addLink(context, {
    parent: parent.node,
    parentCid: parent.cid,
    size: 0,
    cid: emptyDir.cid,
    name: childName,
    hashAlg: options.hashAlg,
    cidVersion: options.cidVersion,
    flush: options.flush,
    shardSplitThreshold: options.shardSplitThreshold
  });
  trail[trail.length - 1].cid = result.cid;
  trail.push({
    name: childName,
    cid: emptyDir.cid
  });
};