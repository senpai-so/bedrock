import mergeOpts from 'merge-options';
import { toMfsPath } from './utils/to-mfs-path.js';
import { exporter } from 'ipfs-unixfs-exporter';
import debug from 'debug';
import errCode from 'err-code';
import { withTimeoutOption } from 'ipfs-core-utils/with-timeout-option';
import * as dagPB from '@ipld/dag-pb';
const mergeOptions = mergeOpts.bind({ ignoreUndefined: true });
const log = debug('ipfs:mfs:stat');
const defaultOptions = { withLocal: false };
export function createStat(context) {
  async function mfsStat(path, options = {}) {
    options = mergeOptions(defaultOptions, options);
    log(`Fetching stats for ${ path }`);
    const {type, cid, mfsPath} = await toMfsPath(context, path, options);
    const exportPath = type === 'ipfs' && cid ? cid : mfsPath;
    let file;
    try {
      file = await exporter(exportPath, context.repo.blocks);
    } catch (err) {
      if (err.code === 'ERR_NOT_FOUND') {
        throw errCode(new Error(`${ path } does not exist`), 'ERR_NOT_FOUND');
      }
      throw err;
    }
    if (!statters[file.type]) {
      throw new Error(`Cannot stat codec ${ file.cid.code }`);
    }
    return statters[file.type](file);
  }
  return withTimeoutOption(mfsStat);
}
const statters = {
  raw: file => {
    return {
      cid: file.cid,
      size: file.node.length,
      cumulativeSize: file.node.length,
      blocks: 0,
      type: 'file',
      local: undefined,
      sizeLocal: undefined,
      withLocality: false
    };
  },
  file: file => {
    const stat = {
      cid: file.cid,
      type: 'file',
      size: file.unixfs.fileSize(),
      cumulativeSize: dagPB.encode(file.node).length + (file.node.Links || []).reduce((acc, curr) => acc + (curr.Tsize || 0), 0),
      blocks: file.unixfs.blockSizes.length,
      local: undefined,
      sizeLocal: undefined,
      withLocality: false,
      mode: file.unixfs.mode
    };
    if (file.unixfs.mtime) {
      stat.mtime = file.unixfs.mtime;
    }
    return stat;
  },
  directory: file => {
    const stat = {
      cid: file.cid,
      type: 'directory',
      size: 0,
      cumulativeSize: dagPB.encode(file.node).length + (file.node.Links || []).reduce((acc, curr) => acc + (curr.Tsize || 0), 0),
      blocks: file.node.Links.length,
      local: undefined,
      sizeLocal: undefined,
      withLocality: false,
      mode: file.unixfs.mode
    };
    if (file.unixfs.mtime) {
      stat.mtime = file.unixfs.mtime;
    }
    return stat;
  },
  object: file => {
    return {
      cid: file.cid,
      size: file.node.length,
      cumulativeSize: file.node.length,
      type: 'file',
      blocks: 0,
      local: undefined,
      sizeLocal: undefined,
      withLocality: false
    };
  },
  identity: file => {
    return {
      cid: file.cid,
      size: file.node.length,
      cumulativeSize: file.node.length,
      blocks: 0,
      type: 'file',
      local: undefined,
      sizeLocal: undefined,
      withLocality: false
    };
  }
};