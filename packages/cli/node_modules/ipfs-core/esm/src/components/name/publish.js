import debug from 'debug';
import parseDuration from 'parse-duration';
import crypto from 'libp2p-crypto';
import errcode from 'err-code';
import { fromString as uint8ArrayFromString } from 'uint8arrays/from-string';
import { toString as uint8ArrayToString } from 'uint8arrays/to-string';
import {
  OFFLINE_ERROR,
  normalizePath
} from '../../utils.js';
import { withTimeoutOption } from 'ipfs-core-utils/with-timeout-option';
import { resolvePath } from './utils.js';
const log = Object.assign(debug('ipfs:name:publish'), { error: debug('ipfs:name:publish:error') });
export function createPublish({ipns, repo, codecs, peerId, isOnline, keychain}) {
  const lookupKey = async keyName => {
    if (keyName === 'self') {
      return peerId.privKey;
    }
    try {
      const pem = await keychain.exportKey(keyName, 'temp');
      const privateKey = await crypto.keys.import(pem, 'temp');
      return privateKey;
    } catch (err) {
      log.error(err);
      throw errcode(err, 'ERR_CANNOT_GET_KEY');
    }
  };
  async function publish(value, options = {}) {
    const resolve = !(options.resolve === false);
    const lifetime = options.lifetime || '24h';
    const key = options.key || 'self';
    if (!isOnline()) {
      throw errcode(new Error(OFFLINE_ERROR), 'OFFLINE_ERROR');
    }
    try {
      value = normalizePath(value);
    } catch (err) {
      log.error(err);
      throw err;
    }
    let pubLifetime = 0;
    try {
      pubLifetime = parseDuration(lifetime) || 0;
      pubLifetime = parseFloat(pubLifetime.toFixed(6));
    } catch (err) {
      log.error(err);
      throw err;
    }
    const results = await Promise.all([
      lookupKey(key),
      resolve ? resolvePath({
        ipns,
        repo,
        codecs
      }, value) : Promise.resolve()
    ]);
    const bytes = uint8ArrayFromString(value);
    const result = await ipns.publish(results[0], bytes, pubLifetime);
    return {
      name: result.name,
      value: uint8ArrayToString(result.value)
    };
  }
  return withTimeoutOption(publish);
}