import debug from 'debug';
import errcode from 'err-code';
import mergeOpts from 'merge-options';
import { CID } from 'multiformats/cid';
import * as Digest from 'multiformats/hashes/digest';
import { base36 } from 'multiformats/bases/base36';
import PeerId from 'peer-id';
import isDomain from 'is-domain-name';
import { toString as uint8ArrayToString } from 'uint8arrays/to-string';
import { OFFLINE_ERROR } from '../../utils.js';
import { withTimeoutOption } from 'ipfs-core-utils/with-timeout-option';
const mergeOptions = mergeOpts.bind({ ignoreUndefined: true });
const log = Object.assign(debug('ipfs:name:resolve'), { error: debug('ipfs:name:resolve:error') });
const appendRemainder = (result, remainder) => remainder.length > 0 ? result + '/' + remainder.join('/') : result;
export function createResolve({
  dns,
  ipns,
  peerId,
  isOnline,
  options: {offline}
}) {
  async function* resolve(name, options = {}) {
    options = mergeOptions({
      nocache: false,
      recursive: true
    }, options);
    if (offline && options && options.nocache) {
      throw errcode(new Error('cannot specify both offline and nocache'), 'ERR_NOCACHE_AND_OFFLINE');
    }
    if (!isOnline() && !offline) {
      throw errcode(new Error(OFFLINE_ERROR), 'OFFLINE_ERROR');
    }
    if (!name) {
      name = peerId.toB58String();
    }
    if (!name.startsWith('/ipns/')) {
      name = `/ipns/${ name }`;
    }
    let [namespace, hash, ...remainder] = name.slice(1).split('/');
    try {
      if (hash.substring(0, 1) === '1') {
        const id = PeerId.parse(hash);
        const digest = Digest.decode(id.toBytes());
        const libp2pKey = CID.createV1(114, digest);
        hash = libp2pKey.toString(base36);
      } else {
        const cid = CID.parse(hash);
        if (cid.version === 1) {
          hash = cid.toString(base36);
        }
      }
    } catch (err) {
      if (isDomain(hash)) {
        yield appendRemainder(await dns(hash, options), remainder);
        return;
      }
      log.error(err);
      throw errcode(new Error('Invalid IPNS name'), 'ERR_IPNS_INVALID_NAME');
    }
    const value = await ipns.resolve(`/${ namespace }/${ hash }`, options);
    yield appendRemainder(value instanceof Uint8Array ? uint8ArrayToString(value) : value, remainder);
  }
  return withTimeoutOption(resolve);
}