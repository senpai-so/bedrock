/**
 * @param {Options} options
 */
export function create(options?: Options): Promise<IPFS>;
export type Options = import('../types').Options;
export type Print = import('../types').Print;
export type StorageAPI = typeof import("./storage.js");
export type BlockCodec = import('multiformats/codecs/interface').BlockCodec<any, any>;
export type MultihashHasher = import('multiformats/hashes/interface').MultihashHasher;
export type MultibaseCodec = import('multiformats/bases/interface').MultibaseCodec<any>;
/**
 * @typedef {import('../types').Options} Options
 * @typedef {import('../types').Print} Print
 * @typedef {import('./storage')} StorageAPI
 * @typedef {import('multiformats/codecs/interface').BlockCodec<any, any>} BlockCodec
 * @typedef {import('multiformats/hashes/interface').MultihashHasher} MultihashHasher
 * @typedef {import('multiformats/bases/interface').MultibaseCodec<any>} MultibaseCodec
 */
declare class IPFS {
    /**
     * @param {Object} config
     * @param {Print} config.print
     * @param {Storage} config.storage
     * @param {import('ipfs-core-utils/multicodecs').Multicodecs} config.codecs
     * @param {Options} config.options
     */
    constructor({ print, storage, codecs, options }: {
        print: Print;
        storage: Storage;
        codecs: import('ipfs-core-utils/multicodecs').Multicodecs;
        options: Options;
    });
    hashers: Multihashes;
    bases: Multibases;
    preload: import("../types").Preload;
    name: NameAPI;
    ipns: IPNSAPI;
    pin: PinAPI;
    resolve: (path: string, opts?: import("ipfs-core-types/src/root").ResolveOptions | undefined) => Promise<string>;
    block: BlockAPI;
    refs: ((ipfsPath: import("ipfs-core-types/src/utils").IPFSPath | import("ipfs-core-types/src/utils").IPFSPath[], options?: import("ipfs-core-types/src/refs").RefsOptions | undefined) => AsyncIterable<import("ipfs-core-types/src/refs").RefsResult>) & {
        local: (options?: import("ipfs-core-types/src/utils").AbortOptions | undefined) => AsyncIterable<import("ipfs-core-types/src/refs").RefsResult>;
    };
    start: () => Promise<void>;
    stop: (options?: import("ipfs-core-types/src/utils").AbortOptions | undefined) => Promise<void>;
    dht: {
        get: (key: string | Uint8Array, options?: import("ipfs-core-types/src/utils").AbortOptions | undefined) => AsyncIterable<import("ipfs-core-types/src/dht").QueryEvent>;
        put: (key: string | Uint8Array, value: Uint8Array, options?: import("ipfs-core-types/src/utils").AbortOptions | undefined) => AsyncIterable<import("ipfs-core-types/src/dht").QueryEvent>;
        findProvs: (cid: import("multiformats/cid").CID, options?: import("ipfs-core-types/src/utils").AbortOptions | undefined) => AsyncIterable<import("ipfs-core-types/src/dht").QueryEvent>;
        findPeer: (peerId: string, options?: import("ipfs-core-types/src/utils").AbortOptions | undefined) => AsyncIterable<import("ipfs-core-types/src/dht").QueryEvent>;
        provide: (cid: import("multiformats/cid").CID, options?: import("ipfs-core-types/src/dht").DHTProvideOptions | undefined) => AsyncIterable<import("ipfs-core-types/src/dht").QueryEvent>;
        query: (peerId: string | import("multiformats/cid").CID, options?: import("ipfs-core-types/src/utils").AbortOptions | undefined) => AsyncIterable<import("ipfs-core-types/src/dht").QueryEvent>;
    };
    pubsub: {
        subscribe: (topic: string, handler: import("ipfs-core-types/src/pubsub").MessageHandlerFn, options?: import("ipfs-core-types/src/pubsub").SubscribeOptions | undefined) => Promise<void>;
        unsubscribe: (topic: string, handler: import("ipfs-core-types/src/pubsub").MessageHandlerFn | undefined, options?: import("ipfs-core-types/src/utils").AbortOptions | undefined) => Promise<void>;
        publish: (topic: string, data: Uint8Array, options?: import("ipfs-core-types/src/utils").AbortOptions | undefined) => Promise<void>;
        ls: (options?: import("ipfs-core-types/src/utils").AbortOptions | undefined) => Promise<string[]>;
        peers: (topic: string, options?: import("ipfs-core-types/src/utils").AbortOptions | undefined) => Promise<string[]>;
    };
    dns: (domain: string, options?: import("ipfs-core-types/src/root").DNSOptions | undefined) => Promise<string>;
    isOnline: () => boolean;
    id: (options?: import("ipfs-core-types/src/root").IDOptions | undefined) => Promise<import("ipfs-core-types/src/root").IDResult>;
    version: (_options?: import("ipfs-core-types/src/utils").AbortOptions | undefined) => Promise<import("ipfs-core-types/src/root").VersionResult>;
    bitswap: BitswapAPI;
    bootstrap: BootstrapAPI;
    config: {
        getAll: (options?: import("ipfs-core-types/src/utils").AbortOptions | undefined) => Promise<import("ipfs-core-types/src/config").Config>;
        get: (key: string, options: import("ipfs-core-types/src/utils").AbortOptions | undefined) => Promise<string | object>;
        set: (key: string, value: any, options: import("ipfs-core-types/src/utils").AbortOptions | undefined) => Promise<void>;
        replace: (value: import("ipfs-core-types/src/config").Config, options: import("ipfs-core-types/src/utils").AbortOptions | undefined) => Promise<void>;
        profiles: {
            apply: (profileName: string, options?: import("ipfs-core-types/src/config/profiles").ProfilesApplyOptions | undefined) => Promise<import("ipfs-core-types/src/config/profiles").ProfilesApplyResult>;
            list: (_options: import("ipfs-core-types/src/utils").AbortOptions | undefined) => Promise<import("ipfs-core-types/src/config/profiles").Profile[]>;
        };
    };
    ping: (peerId: string, options?: import("ipfs-core-types/src/root").PingOptions | undefined) => AsyncIterable<import("ipfs-core-types/src/root").PingResult>;
    add: (entry: import("ipfs-core-types/src/utils").ImportCandidate, options?: import("ipfs-core-types/src/root").AddOptions | undefined) => Promise<import("ipfs-core-types/src/root").AddResult>;
    addAll: (source: import("ipfs-core-types/src/utils").ImportCandidateStream, options?: (import("ipfs-core-types/src/root").AddAllOptions & import("ipfs-core-types/src/utils").AbortOptions) | undefined) => AsyncIterable<import("ipfs-core-types/src/root").AddResult>;
    cat: (ipfsPath: import("ipfs-core-types/src/utils").IPFSPath, options?: import("ipfs-core-types/src/root").CatOptions | undefined) => AsyncIterable<Uint8Array>;
    get: (ipfsPath: import("ipfs-core-types/src/utils").IPFSPath, options?: import("ipfs-core-types/src/root").GetOptions | undefined) => AsyncIterable<Uint8Array>;
    ls: (ipfsPath: import("ipfs-core-types/src/utils").IPFSPath, options?: import("ipfs-core-types/src/root").ListOptions | undefined) => AsyncIterable<import("ipfs-core-types/src/root").IPFSEntry>;
    dag: DagAPI;
    files: import("ipfs-core-types/src/files").API<any>;
    key: KeyAPI;
    object: ObjectAPI;
    repo: RepoAPI;
    stats: StatsAPI;
    swarm: SwarmAPI;
    commands: () => Promise<never>;
    diag: {
        cmds: () => Promise<never>;
        net: () => Promise<never>;
        sys: () => Promise<never>;
    };
    log: {
        level: () => Promise<never>;
        ls: () => Promise<never>;
        tail: () => AsyncGenerator<never, never, unknown>;
    };
    mount: () => Promise<never>;
    codecs: Multicodecs;
    /**
     * `IPFS.create` will do the initialization. Keep this around for backwards
     * compatibility.
     *
     * @deprecated
     */
    init(): Promise<void>;
}
import { Multihashes } from "ipfs-core-utils/multihashes";
import { Multibases } from "ipfs-core-utils/multibases";
import { NameAPI } from "./name/index.js";
import { IPNSAPI } from "./ipns.js";
import { PinAPI } from "./pin/index.js";
import { BlockAPI } from "./block/index.js";
import { BitswapAPI } from "./bitswap/index.js";
import { BootstrapAPI } from "./bootstrap/index.js";
import { DagAPI } from "./dag/index.js";
import { KeyAPI } from "./key/index.js";
import { ObjectAPI } from "./object/index.js";
import { RepoAPI } from "./repo/index.js";
import { StatsAPI } from "./stats/index.js";
import { SwarmAPI } from "./swarm/index.js";
import { Multicodecs } from "ipfs-core-utils/multicodecs";
import { Storage } from "./storage.js";
export {};
//# sourceMappingURL=index.d.ts.map