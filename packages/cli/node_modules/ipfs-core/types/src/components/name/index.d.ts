export class NameAPI {
    /**
     * @param {Object} config
     * @param {import('../ipns').IPNSAPI} config.ipns
     * @param {import('peer-id')} config.peerId
     * @param {import('../../types').Options} config.options
     * @param {import('ipfs-repo').IPFSRepo} config.repo
     * @param {import('ipfs-core-utils/multicodecs').Multicodecs} config.codecs
     * @param {import('ipfs-core-types/src/root').API<{}>["isOnline"]} config.isOnline
     * @param {import('libp2p/src/keychain')} config.keychain
     * @param {import('ipfs-core-types/src/root').API<{}>["dns"]} config.dns
     */
    constructor({ dns, ipns, repo, codecs, peerId, isOnline, keychain, options }: {
        ipns: import('../ipns').IPNSAPI;
        peerId: import('peer-id');
        options: import('../../types').Options;
        repo: import('ipfs-repo').IPFSRepo;
        codecs: import('ipfs-core-utils/multicodecs').Multicodecs;
        isOnline: import('ipfs-core-types/src/root').API<{}>["isOnline"];
        keychain: import('libp2p/src/keychain');
        dns: import('ipfs-core-types/src/root').API<{}>["dns"];
    });
    publish: (value: string | import("multiformats").CID, options?: import("ipfs-core-types/src/name").PublishOptions | undefined) => Promise<import("ipfs-core-types/src/name").PublishResult>;
    resolve: (name: string, options?: import("ipfs-core-types/src/name").ResolveOptions | undefined) => AsyncIterable<string>;
    pubsub: PubSubAPI;
}
import { PubSubAPI } from "./pubsub/index.js";
//# sourceMappingURL=index.d.ts.map