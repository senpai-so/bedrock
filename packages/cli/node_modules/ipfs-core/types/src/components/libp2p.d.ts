/**
 * @typedef {object} DekOptions
 * @property {string} hash
 * @property {string} salt
 * @property {number} iterationCount
 * @property {number} keyLength
 *
 * @typedef {Object} KeychainConfig
 * @property {string} [pass]
 * @property {DekOptions} [dek]
 *
 * @typedef {import('ipfs-repo').IPFSRepo} Repo
 * @typedef {import('peer-id')} PeerId
 * @typedef {import('../types').Options} IPFSOptions
 * @typedef {import('libp2p')} LibP2P
 * @typedef {import('libp2p').Libp2pOptions & import('libp2p').CreateOptions} Libp2pOptions
 * @typedef {import('ipfs-core-types/src/config').Config} IPFSConfig
 */
/**
 * @param {Object} config
 * @param {Repo} config.repo
 * @param {IPFSOptions|undefined} config.options
 * @param {PeerId} config.peerId
 * @param {Multiaddr[]|undefined} config.multiaddrs
 * @param {KeychainConfig|undefined} config.keychainConfig
 * @param {Partial<IPFSConfig>|undefined} config.config
 */
export function createLibp2p({ options, peerId, multiaddrs, repo, keychainConfig, config }: {
    repo: Repo;
    options: IPFSOptions | undefined;
    peerId: PeerId;
    multiaddrs: Multiaddr[] | undefined;
    keychainConfig: KeychainConfig | undefined;
    config: Partial<IPFSConfig> | undefined;
}): Promise<Libp2p>;
export type DekOptions = {
    hash: string;
    salt: string;
    iterationCount: number;
    keyLength: number;
};
export type KeychainConfig = {
    pass?: string | undefined;
    dek?: DekOptions | undefined;
};
export type Repo = import('ipfs-repo').IPFSRepo;
export type PeerId = import('peer-id');
export type IPFSOptions = import('../types').Options;
export type LibP2P = import('libp2p');
export type Libp2pOptions = import('libp2p').Libp2pOptions & import('libp2p').CreateOptions;
export type IPFSConfig = import('ipfs-core-types/src/config').Config;
import { Multiaddr } from "multiaddr";
import Libp2p from "libp2p";
//# sourceMappingURL=libp2p.d.ts.map