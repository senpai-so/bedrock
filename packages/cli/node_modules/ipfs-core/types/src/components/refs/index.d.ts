/**
 * @typedef {object} Node
 * @property {string} [name]
 * @property {CID} cid
 *
 * @typedef {object} TraversalResult
 * @property {Node} parent
 * @property {Node} node
 * @property {boolean} isDuplicate
 *
 * @typedef {import('ipfs-core-types/src/utils').AbortOptions} AbortOptions
 */
/**
 * @param {Object} config
 * @param {import('ipfs-repo').IPFSRepo} config.repo
 * @param {import('ipfs-core-utils/multicodecs').Multicodecs} config.codecs
 * @param {import('ipfs-core-types/src/root').API<{}>["resolve"]} config.resolve
 * @param {import('../../types').Preload} config.preload
 */
export function createRefs({ repo, codecs, resolve, preload }: {
    repo: import('ipfs-repo').IPFSRepo;
    codecs: import('ipfs-core-utils/multicodecs').Multicodecs;
    resolve: import('ipfs-core-types/src/root').API<{}>["resolve"];
    preload: import('../../types').Preload;
}): (ipfsPath: import("ipfs-core-types/src/utils").IPFSPath | import("ipfs-core-types/src/utils").IPFSPath[], options?: import("ipfs-core-types/src/refs").RefsOptions | undefined) => AsyncIterable<import("ipfs-core-types/src/refs").RefsResult>;
export namespace Format {
    const _default: string;
    export { _default as default };
    export const edges: string;
}
export type Node = {
    name?: string | undefined;
    cid: CID;
};
export type TraversalResult = {
    parent: Node;
    node: Node;
    isDuplicate: boolean;
};
export type AbortOptions = import('ipfs-core-types/src/utils').AbortOptions;
//# sourceMappingURL=index.d.ts.map