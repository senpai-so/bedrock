'use strict';

Object.defineProperty(exports, '__esModule', { value: true });

var PeerId = require('peer-id');
var key = require('interface-datastore/key');
var Errors = require('datastore-core/errors');
var errCode = require('err-code');
var debug = require('debug');
var toString = require('uint8arrays/to-string');
var equals = require('uint8arrays/equals');
var ipns = require('ipns');

function _interopDefaultLegacy (e) { return e && typeof e === 'object' && 'default' in e ? e : { 'default': e }; }

function _interopNamespace(e) {
  if (e && e.__esModule) return e;
  var n = Object.create(null);
  if (e) {
    Object.keys(e).forEach(function (k) {
      if (k !== 'default') {
        var d = Object.getOwnPropertyDescriptor(e, k);
        Object.defineProperty(n, k, d.get ? d : {
          enumerable: true,
          get: function () { return e[k]; }
        });
      }
    });
  }
  n["default"] = e;
  return Object.freeze(n);
}

var PeerId__default = /*#__PURE__*/_interopDefaultLegacy(PeerId);
var errCode__default = /*#__PURE__*/_interopDefaultLegacy(errCode);
var debug__default = /*#__PURE__*/_interopDefaultLegacy(debug);
var ipns__namespace = /*#__PURE__*/_interopNamespace(ipns);

const log = Object.assign(debug__default["default"]('ipfs:ipns:publisher'), { error: debug__default["default"]('ipfs:ipns:publisher:error') });
const ERR_NOT_FOUND = Errors.notFoundError().code;
const defaultRecordLifetime = 60 * 60 * 1000;
class IpnsPublisher {
  constructor(routing, datastore) {
    this._routing = routing;
    this._datastore = datastore;
  }
  async publishWithEOL(privKey, value, lifetime) {
    if (!privKey || !privKey.bytes) {
      throw errCode__default["default"](new Error('invalid private key'), 'ERR_INVALID_PRIVATE_KEY');
    }
    const peerId = await PeerId__default["default"].createFromPrivKey(privKey.bytes);
    const record = await this._updateOrCreateRecord(privKey, value, lifetime, peerId);
    return this._putRecordToRouting(record, peerId);
  }
  publish(privKey, value) {
    return this.publishWithEOL(privKey, value, defaultRecordLifetime);
  }
  async _putRecordToRouting(record, peerId) {
    if (!PeerId__default["default"].isPeerId(peerId)) {
      const errMsg = 'peerId received is not valid';
      log.error(errMsg);
      throw errCode__default["default"](new Error(errMsg), 'ERR_INVALID_PEER_ID');
    }
    const publicKey = peerId.pubKey;
    const embedPublicKeyRecord = await ipns__namespace.embedPublicKey(publicKey, record);
    const keys = ipns__namespace.getIdKeys(peerId.toBytes());
    await this._publishEntry(keys.routingKey, embedPublicKeyRecord || record);
    return embedPublicKeyRecord || record;
  }
  async _publishEntry(key$1, entry) {
    const k = key.Key.asKey(key$1);
    if (!k) {
      const errMsg = 'datastore key does not have a valid format';
      log.error(errMsg);
      throw errCode__default["default"](new Error(errMsg), 'ERR_INVALID_DATASTORE_KEY');
    }
    let entryData;
    try {
      entryData = ipns__namespace.marshal(entry);
    } catch (err) {
      log.error(err);
      throw err;
    }
    try {
      const res = await this._routing.put(k.uint8Array(), entryData);
      log(`ipns record for ${ toString.toString(k.uint8Array(), 'base32') } was stored in the routing`);
      return res;
    } catch (err) {
      const errMsg = `ipns record for ${ toString.toString(k.uint8Array(), 'base32') } could not be stored in the routing`;
      log.error(errMsg);
      log.error(err);
      throw errCode__default["default"](new Error(errMsg), 'ERR_PUTTING_TO_ROUTING');
    }
  }
  async _getPublished(peerId, options = {}) {
    if (!PeerId__default["default"].isPeerId(peerId)) {
      const errMsg = 'peerId received is not valid';
      log.error(errMsg);
      throw errCode__default["default"](new Error(errMsg), 'ERR_INVALID_PEER_ID');
    }
    const checkRouting = options.checkRouting !== false;
    try {
      const dsVal = await this._datastore.get(ipns__namespace.getLocalKey(peerId.id));
      return this._unmarshalData(dsVal);
    } catch (err) {
      if (err.code !== ERR_NOT_FOUND) {
        const errMsg = `unexpected error getting the ipns record ${ peerId.id } from datastore`;
        log.error(errMsg);
        throw errCode__default["default"](new Error(errMsg), 'ERR_UNEXPECTED_DATASTORE_RESPONSE');
      }
      if (!checkRouting) {
        throw errCode__default["default"](err, 'ERR_NOT_FOUND_AND_CHECK_ROUTING_NOT_ENABLED');
      }
      try {
        const keys = ipns__namespace.getIdKeys(peerId.toBytes());
        const res = await this._routing.get(keys.routingKey.uint8Array());
        return this._unmarshalData(res);
      } catch (err) {
        log.error(err);
        throw err;
      }
    }
  }
  _unmarshalData(data) {
    try {
      return ipns__namespace.unmarshal(data);
    } catch (err) {
      throw errCode__default["default"](err, 'ERR_INVALID_RECORD_DATA');
    }
  }
  async _updateOrCreateRecord(privKey, value, lifetime, peerId) {
    if (!PeerId__default["default"].isPeerId(peerId)) {
      const errMsg = 'peerId received is not valid';
      log.error(errMsg);
      throw errCode__default["default"](new Error(errMsg), 'ERR_INVALID_PEER_ID');
    }
    const getPublishedOptions = { checkRouting: true };
    let record;
    try {
      record = await this._getPublished(peerId, getPublishedOptions);
    } catch (err) {
      if (err.code !== ERR_NOT_FOUND) {
        const errMsg = `unexpected error when determining the last published IPNS record for ${ peerId.id } ${ err.stack }`;
        log.error(errMsg);
        throw errCode__default["default"](new Error(errMsg), 'ERR_DETERMINING_PUBLISHED_RECORD');
      }
    }
    let seqNumber = 0;
    if (record && record.sequence !== undefined) {
      seqNumber = !equals.equals(record.value, value) ? BigInt(record.sequence) + BigInt(1) : BigInt(record.sequence);
    }
    let entryData;
    try {
      entryData = await ipns__namespace.create(privKey, value, seqNumber, lifetime);
    } catch (err) {
      const errMsg = `ipns record for ${ value } could not be created`;
      log.error(err);
      throw errCode__default["default"](new Error(errMsg), 'ERR_CREATING_IPNS_RECORD');
    }
    try {
      const data = ipns__namespace.marshal(entryData);
      await this._datastore.put(ipns__namespace.getLocalKey(peerId.id), data);
      log(`ipns record for ${ toString.toString(value, 'base32') } was stored in the datastore`);
      return entryData;
    } catch (err) {
      const errMsg = `ipns record for ${ value } could not be stored in the datastore`;
      log.error(errMsg);
      throw errCode__default["default"](new Error(errMsg), 'ERR_STORING_IN_DATASTORE');
    }
  }
}
IpnsPublisher.defaultRecordLifetime = defaultRecordLifetime;

exports.IpnsPublisher = IpnsPublisher;
