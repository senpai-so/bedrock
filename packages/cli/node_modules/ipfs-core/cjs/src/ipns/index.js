'use strict';

Object.defineProperty(exports, '__esModule', { value: true });

var PeerId = require('peer-id');
var errCode = require('err-code');
var debug = require('debug');
var publisher = require('./publisher.js');
var republisher = require('./republisher.js');
var resolver = require('./resolver.js');
var tlru = require('../utils/tlru.js');
var toString = require('uint8arrays/to-string');

function _interopDefaultLegacy (e) { return e && typeof e === 'object' && 'default' in e ? e : { 'default': e }; }

var errCode__default = /*#__PURE__*/_interopDefaultLegacy(errCode);
var debug__default = /*#__PURE__*/_interopDefaultLegacy(debug);

const log = Object.assign(debug__default["default"]('ipfs:ipns'), { error: debug__default["default"]('ipfs:ipns:error') });
const defaultRecordTtl = 60 * 1000;
class IPNS {
  constructor(routing, datastore, peerId, keychain, options) {
    this.publisher = new publisher.IpnsPublisher(routing, datastore);
    this.republisher = new republisher.IpnsRepublisher(this.publisher, datastore, peerId, keychain, options);
    this.resolver = new resolver.IpnsResolver(routing);
    this.cache = new tlru.TLRU(1000);
    this.routing = routing;
  }
  async publish(privKey, value, lifetime = publisher.IpnsPublisher.defaultRecordLifetime) {
    try {
      const peerId = await PeerId.createFromPrivKey(privKey.bytes);
      await this.publisher.publishWithEOL(privKey, value, lifetime);
      log(`IPNS value ${ toString.toString(value, 'base32') } was published correctly`);
      const id = peerId.toB58String();
      const ttEol = parseFloat(lifetime);
      const ttl = ttEol < defaultRecordTtl ? ttEol : defaultRecordTtl;
      this.cache.set(id, value, ttl);
      log(`IPNS value ${ toString.toString(value, 'base32') } was cached correctly`);
      return {
        name: id,
        value: value
      };
    } catch (err) {
      log.error(err);
      throw err;
    }
  }
  async resolve(name, options = {}) {
    if (typeof name !== 'string') {
      throw errCode__default["default"](new Error('name received is not valid'), 'ERR_INVALID_NAME');
    }
    if (!options.nocache && !options.recursive) {
      const id = name.split('/')[2];
      const result = this.cache.get(id);
      if (result) {
        return result;
      }
    }
    try {
      const result = await this.resolver.resolve(name, options);
      log(`IPNS record from ${ name } was resolved correctly`);
      return result;
    } catch (err) {
      log.error(err);
      throw err;
    }
  }
  async initializeKeyspace(privKey, value) {
    return this.publish(privKey, value, publisher.IpnsPublisher.defaultRecordLifetime);
  }
}

exports.IPNS = IPNS;
