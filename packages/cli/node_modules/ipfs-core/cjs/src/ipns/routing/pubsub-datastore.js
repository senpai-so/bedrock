'use strict';

Object.defineProperty(exports, '__esModule', { value: true });

var ipns = require('ipns');
var base58 = require('multiformats/bases/base58');
var datastorePubsub = require('datastore-pubsub');
var fromString = require('uint8arrays/from-string');
var toString = require('uint8arrays/to-string');
var errCode = require('err-code');
var debug = require('debug');

function _interopDefaultLegacy (e) { return e && typeof e === 'object' && 'default' in e ? e : { 'default': e }; }

function _interopNamespace(e) {
  if (e && e.__esModule) return e;
  var n = Object.create(null);
  if (e) {
    Object.keys(e).forEach(function (k) {
      if (k !== 'default') {
        var d = Object.getOwnPropertyDescriptor(e, k);
        Object.defineProperty(n, k, d.get ? d : {
          enumerable: true,
          get: function () { return e[k]; }
        });
      }
    });
  }
  n["default"] = e;
  return Object.freeze(n);
}

var ipns__namespace = /*#__PURE__*/_interopNamespace(ipns);
var errCode__default = /*#__PURE__*/_interopDefaultLegacy(errCode);
var debug__default = /*#__PURE__*/_interopDefaultLegacy(debug);

const log = Object.assign(debug__default["default"]('ipfs:ipns:pubsub'), { error: debug__default["default"]('ipfs:ipns:pubsub:error') });
class IpnsPubsubDatastore {
  constructor(pubsub, localDatastore, peerId) {
    this._subscriptions = {};
    this._handleSubscriptionKey = this._handleSubscriptionKey.bind(this);
    this._pubsubDs = new datastorePubsub.PubsubDatastore(pubsub, localDatastore, peerId, ipns__namespace.validator, this._handleSubscriptionKey);
  }
  async put(key, value) {
    try {
      await this._pubsubDs.put(key, value);
    } catch (err) {
      log.error(err);
      throw err;
    }
  }
  async get(key) {
    let res;
    let err;
    try {
      res = await this._pubsubDs.get(key);
    } catch (e) {
      err = e;
    }
    const ns = key.slice(0, ipns__namespace.namespaceLength);
    if (toString.toString(ns) === ipns__namespace.namespace) {
      const stringifiedTopic = base58.base58btc.encode(key).substring(1);
      const id = base58.base58btc.encode(key.slice(ipns__namespace.namespaceLength)).substring(1);
      this._subscriptions[stringifiedTopic] = id;
      log(`subscribed to pubsub topic ${ stringifiedTopic }, id ${ id }`);
    }
    if (err) {
      throw err;
    }
    return res;
  }
  _handleSubscriptionKey(key) {
    if (key instanceof Uint8Array) {
      key = toString.toString(key, 'base58btc');
    }
    const subscriber = this._subscriptions[key];
    if (!subscriber) {
      throw errCode__default["default"](new Error(`key ${ key } does not correspond to a subscription`), 'ERR_INVALID_KEY');
    }
    let keys;
    try {
      keys = ipns__namespace.getIdKeys(fromString.fromString(subscriber, 'base58btc'));
    } catch (err) {
      log.error(err);
      throw err;
    }
    return keys.routingKey.uint8Array();
  }
  getSubscriptions() {
    const subscriptions = Object.values(this._subscriptions).filter(Boolean);
    return subscriptions.map(sub => `${ ipns__namespace.namespace }${ sub }`);
  }
  async cancel(name) {
    if (typeof name !== 'string') {
      throw errCode__default["default"](new Error('invalid subscription name'), 'ERR_INVALID_SUBSCRIPTION_NAME');
    }
    if (name.startsWith(ipns__namespace.namespace)) {
      name = name.substring(ipns__namespace.namespaceLength);
    }
    const stringifiedTopic = Object.keys(this._subscriptions).find(key => this._subscriptions[key] === name);
    if (!stringifiedTopic) {
      return { canceled: false };
    }
    const bufTopic = fromString.fromString(stringifiedTopic);
    this._pubsubDs.unsubscribe(bufTopic);
    delete this._subscriptions[stringifiedTopic];
    log(`unsubscribed pubsub ${ stringifiedTopic }: ${ name }`);
    return { canceled: true };
  }
}

exports.IpnsPubsubDatastore = IpnsPubsubDatastore;
