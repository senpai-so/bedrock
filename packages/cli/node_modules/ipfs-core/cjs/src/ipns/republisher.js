'use strict';

Object.defineProperty(exports, '__esModule', { value: true });

var ipns = require('ipns');
var crypto = require('libp2p-crypto');
var PeerId = require('peer-id');
var errCode = require('err-code');
var debug = require('debug');

function _interopDefaultLegacy (e) { return e && typeof e === 'object' && 'default' in e ? e : { 'default': e }; }

function _interopNamespace(e) {
  if (e && e.__esModule) return e;
  var n = Object.create(null);
  if (e) {
    Object.keys(e).forEach(function (k) {
      if (k !== 'default') {
        var d = Object.getOwnPropertyDescriptor(e, k);
        Object.defineProperty(n, k, d.get ? d : {
          enumerable: true,
          get: function () { return e[k]; }
        });
      }
    });
  }
  n["default"] = e;
  return Object.freeze(n);
}

var ipns__namespace = /*#__PURE__*/_interopNamespace(ipns);
var crypto__default = /*#__PURE__*/_interopDefaultLegacy(crypto);
var PeerId__default = /*#__PURE__*/_interopDefaultLegacy(PeerId);
var errCode__default = /*#__PURE__*/_interopDefaultLegacy(errCode);
var debug__default = /*#__PURE__*/_interopDefaultLegacy(debug);

const log = Object.assign(debug__default["default"]('ipfs:ipns:republisher'), { error: debug__default["default"]('ipfs:ipns:republisher:error') });
const minute = 60 * 1000;
const hour = 60 * minute;
const defaultBroadcastInterval = 4 * hour;
const defaultRecordLifetime = 24 * hour;
class IpnsRepublisher {
  constructor(publisher, datastore, peerId, keychain, options = { pass: '' }) {
    this._publisher = publisher;
    this._datastore = datastore;
    this._peerId = peerId;
    this._keychain = keychain;
    this._options = options;
    this._republishHandle = null;
  }
  async start() {
    if (this._republishHandle) {
      throw errCode__default["default"](new Error('republisher is already running'), 'ERR_REPUBLISH_ALREADY_RUNNING');
    }
    const republishHandle = {
      _task: null,
      _inflightTask: null,
      _timeoutId: null,
      runPeriodically: period => {
        republishHandle._timeoutId = setTimeout(async () => {
          republishHandle._timeoutId = null;
          try {
            republishHandle._inflightTask = republishHandle._task();
            await republishHandle._inflightTask;
            if (republishHandle._task) {
              republishHandle.runPeriodically(period);
            }
          } catch (err) {
            log.error(err);
          }
        }, period());
      },
      cancel: async () => {
        if (republishHandle._timeoutId != null) {
          clearTimeout(republishHandle._timeoutId);
        }
        republishHandle._task = null;
        await republishHandle._inflightTask;
      }
    };
    const {privKey} = this._peerId;
    const {pass} = this._options;
    let firstRun = true;
    republishHandle._task = () => this._republishEntries(privKey, pass);
    republishHandle.runPeriodically(() => {
      if (firstRun) {
        firstRun = false;
        return this._options.initialBroadcastInterval || minute;
      }
      return this._options.broadcastInterval || defaultBroadcastInterval;
    });
    this._republishHandle = republishHandle;
  }
  async stop() {
    const republishHandle = this._republishHandle;
    if (!republishHandle) {
      throw errCode__default["default"](new Error('republisher is not running'), 'ERR_REPUBLISH_NOT_RUNNING');
    }
    this._republishHandle = null;
    await republishHandle.cancel();
  }
  async _republishEntries(privateKey, pass) {
    try {
      await this._republishEntry(privateKey);
    } catch (err) {
      const errMsg = 'cannot republish entry for the node\'s private key';
      log.error(errMsg);
      return;
    }
    if (pass) {
      try {
        const keys = await this._keychain.listKeys();
        for (const key of keys) {
          if (key.name === 'self') {
            continue;
          }
          const pem = await this._keychain.exportKey(key.name, pass);
          const privKey = await crypto__default["default"].keys.import(pem, pass);
          await this._republishEntry(privKey);
        }
      } catch (err) {
        log.error(err);
      }
    }
  }
  async _republishEntry(privateKey) {
    if (!privateKey || !privateKey.bytes) {
      throw errCode__default["default"](new Error('invalid private key'), 'ERR_INVALID_PRIVATE_KEY');
    }
    try {
      const peerId = await PeerId__default["default"].createFromPrivKey(privateKey.bytes);
      const value = await this._getPreviousValue(peerId);
      await this._publisher.publishWithEOL(privateKey, value, defaultRecordLifetime);
    } catch (err) {
      if (err.code === 'ERR_NO_ENTRY_FOUND') {
        return;
      }
      throw err;
    }
  }
  async _getPreviousValue(peerId) {
    if (!PeerId__default["default"].isPeerId(peerId)) {
      throw errCode__default["default"](new Error('invalid peer ID'), 'ERR_INVALID_PEER_ID');
    }
    try {
      const dsVal = await this._datastore.get(ipns__namespace.getLocalKey(peerId.id));
      if (!(dsVal instanceof Uint8Array)) {
        throw errCode__default["default"](new Error('found ipns record that we couldn\'t process'), 'ERR_INVALID_IPNS_RECORD');
      }
      try {
        const record = ipns__namespace.unmarshal(dsVal);
        return record.value;
      } catch (err) {
        log.error(err);
        throw errCode__default["default"](new Error('found ipns record that we couldn\'t convert to a value'), 'ERR_INVALID_IPNS_RECORD');
      }
    } catch (err) {
      if (err && err.notFound) {
        throw errCode__default["default"](new Error(`no previous entry for record with id: ${ peerId.id }`), 'ERR_NO_ENTRY_FOUND');
      }
      throw err;
    }
  }
}

exports.IpnsRepublisher = IpnsRepublisher;
