'use strict';

Object.defineProperty(exports, '__esModule', { value: true });

var ipns = require('ipns');
var PeerId = require('peer-id');
var errCode = require('err-code');
var debug = require('debug');
var toString = require('uint8arrays/to-string');
var Errors = require('datastore-core/errors');

function _interopDefaultLegacy (e) { return e && typeof e === 'object' && 'default' in e ? e : { 'default': e }; }

function _interopNamespace(e) {
  if (e && e.__esModule) return e;
  var n = Object.create(null);
  if (e) {
    Object.keys(e).forEach(function (k) {
      if (k !== 'default') {
        var d = Object.getOwnPropertyDescriptor(e, k);
        Object.defineProperty(n, k, d.get ? d : {
          enumerable: true,
          get: function () { return e[k]; }
        });
      }
    });
  }
  n["default"] = e;
  return Object.freeze(n);
}

var ipns__namespace = /*#__PURE__*/_interopNamespace(ipns);
var PeerId__default = /*#__PURE__*/_interopDefaultLegacy(PeerId);
var errCode__default = /*#__PURE__*/_interopDefaultLegacy(errCode);
var debug__default = /*#__PURE__*/_interopDefaultLegacy(debug);
var Errors__namespace = /*#__PURE__*/_interopNamespace(Errors);

const log = Object.assign(debug__default["default"]('ipfs:ipns:resolver'), { error: debug__default["default"]('ipfs:ipns:resolver:error') });
const ERR_NOT_FOUND = Errors__namespace.notFoundError().code;
const defaultMaximumRecursiveDepth = 32;
class IpnsResolver {
  constructor(routing) {
    this._routing = routing;
  }
  async resolve(name, options = {}) {
    if (typeof name !== 'string') {
      throw errCode__default["default"](new Error('invalid name'), 'ERR_INVALID_NAME');
    }
    const recursive = options.recursive && options.recursive.toString() === 'true';
    const nameSegments = name.split('/');
    if (nameSegments.length !== 3 || nameSegments[0] !== '') {
      throw errCode__default["default"](new Error('invalid name'), 'ERR_INVALID_NAME');
    }
    const key = nameSegments[2];
    let depth = Infinity;
    if (recursive) {
      depth = defaultMaximumRecursiveDepth;
    }
    const res = await this.resolver(key, depth);
    log(`${ name } was locally resolved correctly`);
    return res;
  }
  async resolver(name, depth) {
    if (depth === 0) {
      const errMsg = `could not resolve name (recursion limit of ${ defaultMaximumRecursiveDepth } exceeded)`;
      log.error(errMsg);
      throw errCode__default["default"](new Error(errMsg), 'ERR_RESOLVE_RECURSION_LIMIT');
    }
    const res = await this._resolveName(name);
    const nameSegments = res.split('/');
    if (nameSegments[1] === 'ipfs' || !depth) {
      return res;
    }
    return this.resolver(nameSegments[2], depth - 1);
  }
  async _resolveName(name) {
    const peerId = PeerId__default["default"].parse(name);
    const {routingKey} = ipns__namespace.getIdKeys(peerId.toBytes());
    let record;
    try {
      record = await this._routing.get(routingKey.uint8Array());
    } catch (err) {
      log.error('could not get record from routing', err);
      if (err.code === ERR_NOT_FOUND) {
        throw errCode__default["default"](new Error(`record requested for ${ name } was not found in the network`), 'ERR_NO_RECORD_FOUND');
      }
      throw errCode__default["default"](new Error(`unexpected error getting the ipns record ${ peerId.toString() }`), 'ERR_UNEXPECTED_ERROR_GETTING_RECORD');
    }
    let ipnsEntry;
    try {
      ipnsEntry = ipns__namespace.unmarshal(record);
    } catch (err) {
      log.error('could not unmarshal record', err);
      throw errCode__default["default"](new Error('found ipns record that we couldn\'t convert to a value'), 'ERR_INVALID_RECORD_RECEIVED');
    }
    return this._validateRecord(peerId, ipnsEntry);
  }
  async _validateRecord(peerId, ipnsEntry) {
    const pubKey = await ipns__namespace.extractPublicKey(peerId, ipnsEntry);
    await ipns__namespace.validate(pubKey, ipnsEntry);
    return toString.toString(ipnsEntry.value);
  }
}

exports.IpnsResolver = IpnsResolver;
