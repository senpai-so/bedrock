'use strict';

Object.defineProperty(exports, '__esModule', { value: true });

var debug = require('debug');

function _interopDefaultLegacy (e) { return e && typeof e === 'object' && 'default' in e ? e : { 'default': e }; }

var debug__default = /*#__PURE__*/_interopDefaultLegacy(debug);

const log = Object.assign(debug__default["default"]('ipfs:mfs-preload'), { error: debug__default["default"]('ipfs:mfs-preload:error') });
function createMfsPreloader({preload, files, options = {}}) {
  options.interval = options.interval || 30 * 1000;
  if (!options.enabled) {
    log('MFS preload disabled');
    const noop = async () => {
    };
    return {
      start: noop,
      stop: noop
    };
  }
  let rootCid = '';
  let timeoutId;
  const preloadMfs = async () => {
    try {
      const stats = await files.stat('/');
      const nextRootCid = stats.cid.toString();
      if (rootCid !== nextRootCid) {
        log(`preloading updated MFS root ${ rootCid } -> ${ stats.cid }`);
        await preload(stats.cid);
        rootCid = nextRootCid;
      }
    } catch (err) {
      log.error('failed to preload MFS root', err);
    } finally {
      timeoutId = setTimeout(preloadMfs, options.interval);
    }
  };
  return {
    async start() {
      const stats = await files.stat('/');
      rootCid = stats.cid.toString();
      log(`monitoring MFS root ${ stats.cid }`);
      timeoutId = setTimeout(preloadMfs, options.interval);
    },
    stop() {
      clearTimeout(timeoutId);
    }
  };
}

exports.createMfsPreloader = createMfsPreloader;
