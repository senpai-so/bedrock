'use strict';

Object.defineProperty(exports, '__esModule', { value: true });

var isIpfs = require('is-ipfs');
var cid = require('multiformats/cid');
var key = require('interface-datastore/key');
var errCode = require('err-code');
var withTimeoutOption = require('ipfs-core-utils/with-timeout-option');
var toCidAndPath = require('ipfs-core-utils/to-cid-and-path');
var dagPB = require('@ipld/dag-pb');

function _interopDefaultLegacy (e) { return e && typeof e === 'object' && 'default' in e ? e : { 'default': e }; }

function _interopNamespace(e) {
  if (e && e.__esModule) return e;
  var n = Object.create(null);
  if (e) {
    Object.keys(e).forEach(function (k) {
      if (k !== 'default') {
        var d = Object.getOwnPropertyDescriptor(e, k);
        Object.defineProperty(n, k, d.get ? d : {
          enumerable: true,
          get: function () { return e[k]; }
        });
      }
    });
  }
  n["default"] = e;
  return Object.freeze(n);
}

var isIpfs__default = /*#__PURE__*/_interopDefaultLegacy(isIpfs);
var errCode__default = /*#__PURE__*/_interopDefaultLegacy(errCode);
var dagPB__namespace = /*#__PURE__*/_interopNamespace(dagPB);

const ERR_BAD_PATH = 'ERR_BAD_PATH';
const OFFLINE_ERROR = 'This command must be run in online mode. Try running \'ipfs daemon\' first.';
const MFS_ROOT_KEY = new key.Key('/local/filesroot');
const MFS_MAX_CHUNK_SIZE = 262144;
const MFS_MAX_LINKS = 174;
const normalizePath = pathStr => {
  const cid$1 = cid.CID.asCID(pathStr);
  if (cid$1) {
    return `/ipfs/${ pathStr }`;
  }
  const str = pathStr.toString();
  try {
    return `/ipfs/${ cid.CID.parse(str) }`;
  } catch {
  }
  if (isIpfs__default["default"].path(str)) {
    return str;
  } else {
    throw errCode__default["default"](new Error(`invalid path: ${ pathStr }`), ERR_BAD_PATH);
  }
};
const normalizeCidPath = path => {
  if (path instanceof Uint8Array) {
    return cid.CID.decode(path).toString();
  }
  path = path.toString();
  if (path.indexOf('/ipfs/') === 0) {
    path = path.substring('/ipfs/'.length);
  }
  if (path.charAt(path.length - 1) === '/') {
    path = path.substring(0, path.length - 1);
  }
  return path;
};
const resolvePath = async function (repo, codecs, ipfsPath, options = {}) {
  const {cid: cid$1, path} = toCidAndPath.toCidAndPath(ipfsPath);
  if (path) {
    options.path = path;
  }
  let lastCid = cid$1;
  let lastRemainderPath = options.path || '';
  if (lastRemainderPath.startsWith('/')) {
    lastRemainderPath = lastRemainderPath.substring(1);
  }
  if (options.path) {
    try {
      for await (const {value, remainderPath} of resolve(cid$1, options.path, codecs, repo, { signal: options.signal })) {
        if (!cid.CID.asCID(value)) {
          break;
        }
        lastRemainderPath = remainderPath;
        lastCid = value;
      }
    } catch (err) {
      if (err.message.startsWith('Object has no property')) {
        err.message = `no link named "${ lastRemainderPath.split('/')[0] }" under ${ lastCid }`;
        err.code = 'ERR_NO_LINK';
      }
      throw err;
    }
  }
  return {
    cid: lastCid,
    remainderPath: lastRemainderPath || ''
  };
};
const mapFile = file => {
  if (file.type !== 'file' && file.type !== 'directory' && file.type !== 'raw') {
    throw new Error(`Unknown node type '${ file.type }'`);
  }
  const output = {
    cid: file.cid,
    path: file.path,
    name: file.name,
    size: file.size,
    type: 'file'
  };
  if (file.type === 'directory') {
    output.type = 'dir';
  }
  if (file.type === 'file') {
    output.size = file.unixfs.fileSize();
  }
  if (file.type === 'file' || file.type === 'directory') {
    output.mode = file.unixfs.mode;
    if (file.unixfs.mtime !== undefined) {
      output.mtime = file.unixfs.mtime;
    }
  }
  return output;
};
const withTimeout = withTimeoutOption.withTimeoutOption(async (promise, _options) => await promise);
const resolve = async function* (cid$1, path, codecs, repo, options) {
  const load = async cid => {
    const codec = await codecs.getCodec(cid.code);
    const block = await repo.blocks.get(cid, options);
    return codec.decode(block);
  };
  const parts = path.split('/').filter(Boolean);
  let value = await load(cid$1);
  let lastCid = cid$1;
  while (parts.length) {
    const key = parts.shift();
    if (!key) {
      throw errCode__default["default"](new Error(`Could not resolve path "${ path }"`), 'ERR_INVALID_PATH');
    }
    if (cid$1.code === dagPB__namespace.code && Array.isArray(value.Links)) {
      const link = value.Links.find(l => l.Name === key);
      if (link) {
        yield {
          value: link.Hash,
          remainderPath: parts.join('/')
        };
        value = await load(link.Hash);
        lastCid = link.Hash;
        continue;
      }
    }
    if (Object.prototype.hasOwnProperty.call(value, key)) {
      value = value[key];
      yield {
        value,
        remainderPath: parts.join('/')
      };
    } else {
      throw errCode__default["default"](new Error(`no link named "${ key }" under ${ lastCid }`), 'ERR_NO_LINK');
    }
    if (cid.CID.asCID(value)) {
      lastCid = value;
      value = await load(value);
    }
  }
  yield {
    value,
    remainderPath: ''
  };
};

exports.MFS_MAX_CHUNK_SIZE = MFS_MAX_CHUNK_SIZE;
exports.MFS_MAX_LINKS = MFS_MAX_LINKS;
exports.MFS_ROOT_KEY = MFS_ROOT_KEY;
exports.OFFLINE_ERROR = OFFLINE_ERROR;
exports.mapFile = mapFile;
exports.normalizeCidPath = normalizeCidPath;
exports.normalizePath = normalizePath;
exports.resolve = resolve;
exports.resolvePath = resolvePath;
exports.withTimeout = withTimeout;
