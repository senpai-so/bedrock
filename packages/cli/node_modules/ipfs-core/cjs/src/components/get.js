'use strict';

Object.defineProperty(exports, '__esModule', { value: true });

var ipfsUnixfsExporter = require('ipfs-unixfs-exporter');
var errCode = require('err-code');
var utils = require('../utils.js');
var withTimeoutOption = require('ipfs-core-utils/with-timeout-option');
var cid = require('multiformats/cid');
var itTar = require('it-tar');
var itPipe = require('it-pipe');
var Pako = require('pako');
var map = require('it-map');
var toBuffer = require('it-to-buffer');

function _interopDefaultLegacy (e) { return e && typeof e === 'object' && 'default' in e ? e : { 'default': e }; }

var errCode__default = /*#__PURE__*/_interopDefaultLegacy(errCode);
var Pako__default = /*#__PURE__*/_interopDefaultLegacy(Pako);
var map__default = /*#__PURE__*/_interopDefaultLegacy(map);
var toBuffer__default = /*#__PURE__*/_interopDefaultLegacy(toBuffer);

const DEFAULT_COMPRESSION_LEVEL = 6;
function createGet({repo, preload}) {
  async function* get(ipfsPath, options = {}) {
    if (options.compressionLevel != null && (options.compressionLevel < -1 || options.compressionLevel > 9)) {
      throw errCode__default["default"](new Error('Compression level must be between -1 and 9'), 'ERR_INVALID_PARAMS');
    }
    if (options.preload !== false) {
      let pathComponents;
      try {
        pathComponents = utils.normalizeCidPath(ipfsPath).split('/');
      } catch (err) {
        throw errCode__default["default"](err, 'ERR_INVALID_PATH');
      }
      preload(cid.CID.parse(pathComponents[0]));
    }
    const ipfsPathOrCid = cid.CID.asCID(ipfsPath) || ipfsPath;
    const file = await ipfsUnixfsExporter.exporter(ipfsPathOrCid, repo.blocks, options);
    if (file.type === 'file' || file.type === 'raw') {
      const args = [];
      if (!options.compress || options.archive === true) {
        args.push([{
            header: {
              name: file.path,
              mode: file.type === 'file' && file.unixfs.mode,
              mtime: file.type === 'file' && file.unixfs.mtime ? new Date(file.unixfs.mtime.secs * 1000) : undefined,
              size: file.size,
              type: 'file'
            },
            body: file.content()
          }], itTar.pack(), source => map__default["default"](source, buf => buf.slice()));
      } else {
        args.push(file.content);
      }
      if (options.compress) {
        args.push(async function* (source) {
          const buf = await toBuffer__default["default"](source);
          yield Pako__default["default"].gzip(buf, { level: options.compressionLevel || DEFAULT_COMPRESSION_LEVEL });
        });
      }
      yield* itPipe.pipe(...args);
      return;
    }
    if (file.type === 'directory') {
      const args = [
        ipfsUnixfsExporter.recursive(ipfsPathOrCid, repo.blocks, options),
        async function* (source) {
          for await (const entry of source) {
            const output = {
              header: {
                name: entry.path,
                size: entry.size
              }
            };
            if (entry.type === 'file') {
              output.header.type = 'file';
              output.header.mode = entry.unixfs.mode != null ? entry.unixfs.mode : undefined;
              output.header.mtime = entry.unixfs.mtime ? new Date(entry.unixfs.mtime.secs * 1000) : undefined;
              output.body = entry.content();
            } else if (entry.type === 'raw') {
              output.header.type = 'file';
              output.body = entry.content();
            } else if (entry.type === 'directory') {
              output.header.type = 'directory';
              output.header.mode = entry.unixfs.mode != null ? entry.unixfs.mode : undefined;
              output.header.mtime = entry.unixfs.mtime ? new Date(entry.unixfs.mtime.secs * 1000) : undefined;
            } else {
              throw errCode__default["default"](new Error('Not a UnixFS node'), 'ERR_NOT_UNIXFS');
            }
            yield output;
          }
        },
        itTar.pack(),
        source => map__default["default"](source, buf => buf.slice())
      ];
      if (options.compress) {
        if (!options.archive) {
          throw errCode__default["default"](new Error('file is not regular'), 'ERR_INVALID_PATH');
        }
        if (options.compress) {
          args.push(async function* (source) {
            const buf = await toBuffer__default["default"](source);
            yield Pako__default["default"].gzip(buf, { level: options.compressionLevel || DEFAULT_COMPRESSION_LEVEL });
          });
        }
      }
      yield* itPipe.pipe(...args);
      return;
    }
    throw errCode__default["default"](new Error('Not a UnixFS node'), 'ERR_NOT_UNIXFS');
  }
  return withTimeoutOption.withTimeoutOption(get);
}

exports.createGet = createGet;
