'use strict';

Object.defineProperty(exports, '__esModule', { value: true });

var debug = require('debug');
var repo = require('ipfs-core-config/repo');
var getDefaultConfig = require('ipfs-core-config/config');
var fromString = require('uint8arrays/from-string');
var toString = require('uint8arrays/to-string');
var PeerId = require('peer-id');
var mergeOpts = require('merge-options');
var profiles = require('./config/profiles.js');
var errors$1 = require('../errors.js');
var libp2p = require('./libp2p.js');
var errors = require('ipfs-repo/errors');

function _interopDefaultLegacy (e) { return e && typeof e === 'object' && 'default' in e ? e : { 'default': e }; }

var debug__default = /*#__PURE__*/_interopDefaultLegacy(debug);
var getDefaultConfig__default = /*#__PURE__*/_interopDefaultLegacy(getDefaultConfig);
var PeerId__default = /*#__PURE__*/_interopDefaultLegacy(PeerId);
var mergeOpts__default = /*#__PURE__*/_interopDefaultLegacy(mergeOpts);

const mergeOptions = mergeOpts__default["default"].bind({ ignoreUndefined: true });
const log = debug__default["default"]('ipfs:components:peer:storage');
class Storage {
  constructor(peerId, keychain, repo, print, isNew) {
    this.print = print;
    this.peerId = peerId;
    this.keychain = keychain;
    this.repo = repo;
    this.print = print;
    this.isNew = isNew;
  }
  static async start(print, codecs, options) {
    const {
      repoAutoMigrate,
      repo: inputRepo,
      onMigrationProgress
    } = options;
    const repo$1 = typeof inputRepo === 'string' || inputRepo == null ? repo.createRepo(print, codecs, {
      path: inputRepo,
      autoMigrate: repoAutoMigrate,
      onMigrationProgress: onMigrationProgress
    }) : inputRepo;
    const {peerId, keychain, isNew} = await loadRepo(print, repo$1, options);
    return new Storage(peerId, keychain, repo$1, print, isNew);
  }
}
const loadRepo = async (print, repo, options) => {
  if (!repo.closed) {
    return {
      ...await configureRepo(repo, options),
      isNew: false
    };
  }
  try {
    await repo.open();
    return {
      ...await configureRepo(repo, options),
      isNew: false
    };
  } catch (err) {
    if (err.code !== errors.ERR_REPO_NOT_INITIALIZED) {
      throw err;
    }
    if (options.init && options.init.allowNew === false) {
      throw new errors$1.NotEnabledError('Initialization of new repos disabled by config, pass `config.init.isNew: true` to enable it');
    }
    return {
      ...await initRepo(print, repo, options),
      isNew: true
    };
  }
};
const initRepo = async (print, repo, options) => {
  const initOptions = options.init || {};
  const exists = await repo.exists();
  log('repo exists?', exists);
  if (exists === true) {
    throw new Error('repo already exists');
  }
  const peerId = initOptions.privateKey ? await decodePeerId(initOptions.privateKey) : await initPeerId(print, initOptions);
  const identity = peerIdToIdentity(peerId);
  log('peer identity: %s', identity.PeerID);
  const config = {
    ...mergeOptions(applyProfiles(getDefaultConfig__default["default"](), initOptions.profiles), options.config),
    Identity: identity
  };
  await repo.init(config);
  await repo.open();
  log('repo opened');
  const keychainConfig = { pass: options.pass };
  try {
    keychainConfig.dek = await repo.config.get('Keychain.DEK');
  } catch (err) {
    if (err.code !== 'ERR_NOT_FOUND') {
      throw err;
    }
  }
  const libp2p$1 = await libp2p.createLibp2p({
    options: undefined,
    multiaddrs: undefined,
    peerId,
    repo,
    config,
    keychainConfig
  });
  if (libp2p$1.keychain && libp2p$1.keychain.opts) {
    await libp2p$1.loadKeychain();
    await repo.config.set('Keychain', { DEK: libp2p$1.keychain.opts.dek });
  }
  return {
    peerId,
    keychain: libp2p$1.keychain
  };
};
const decodePeerId = peerId => {
  log('using user-supplied private-key');
  return typeof peerId === 'object' ? peerId : PeerId__default["default"].createFromPrivKey(fromString.fromString(peerId, 'base64pad'));
};
const initPeerId = (print, {algorithm = 'Ed25519', bits = 2048}) => {
  print('generating %s keypair...', algorithm);
  return PeerId__default["default"].create({
    keyType: algorithm,
    bits
  });
};
const peerIdToIdentity = peerId => ({
  PeerID: peerId.toB58String(),
  PrivKey: toString.toString(peerId.privKey.bytes, 'base64pad')
});
const configureRepo = async (repo, options) => {
  const config = options.config;
  const profiles = options.init && options.init.profiles || [];
  const pass = options.pass;
  const original = await repo.config.getAll();
  const changed = mergeConfigs(applyProfiles(original, profiles), config);
  if (original !== changed) {
    await repo.config.replace(changed);
  }
  if (!changed.Identity || !changed.Identity.PrivKey) {
    throw new errors$1.NotInitializedError('No private key was found in the config, please intialize the repo');
  }
  const peerId = await PeerId__default["default"].createFromPrivKey(changed.Identity.PrivKey);
  const libp2p$1 = await libp2p.createLibp2p({
    options: undefined,
    multiaddrs: undefined,
    peerId,
    repo,
    config: changed,
    keychainConfig: {
      pass,
      ...changed.Keychain
    }
  });
  if (libp2p$1.keychain) {
    await libp2p$1.loadKeychain();
  }
  return {
    peerId,
    keychain: libp2p$1.keychain
  };
};
const mergeConfigs = (config, changes) => changes ? mergeOptions(config, changes) : config;
const applyProfiles = (config, profiles$1) => {
  return (profiles$1 || []).reduce((config, name) => {
    const profile = profiles.profiles[name];
    if (!profile) {
      throw new Error(`Could not find profile with name '${ name }'`);
    }
    log('applying profile %s', name);
    return profile.transform(config);
  }, config);
};

exports.Storage = Storage;
