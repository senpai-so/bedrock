'use strict';

Object.defineProperty(exports, '__esModule', { value: true });

var debug = require('debug');
var errCode = require('err-code');
var mergeOpts = require('merge-options');
var cid = require('multiformats/cid');
var Digest = require('multiformats/hashes/digest');
var base36 = require('multiformats/bases/base36');
var PeerId = require('peer-id');
var isDomain = require('is-domain-name');
var toString = require('uint8arrays/to-string');
var utils = require('../../utils.js');
var withTimeoutOption = require('ipfs-core-utils/with-timeout-option');

function _interopDefaultLegacy (e) { return e && typeof e === 'object' && 'default' in e ? e : { 'default': e }; }

function _interopNamespace(e) {
  if (e && e.__esModule) return e;
  var n = Object.create(null);
  if (e) {
    Object.keys(e).forEach(function (k) {
      if (k !== 'default') {
        var d = Object.getOwnPropertyDescriptor(e, k);
        Object.defineProperty(n, k, d.get ? d : {
          enumerable: true,
          get: function () { return e[k]; }
        });
      }
    });
  }
  n["default"] = e;
  return Object.freeze(n);
}

var debug__default = /*#__PURE__*/_interopDefaultLegacy(debug);
var errCode__default = /*#__PURE__*/_interopDefaultLegacy(errCode);
var mergeOpts__default = /*#__PURE__*/_interopDefaultLegacy(mergeOpts);
var Digest__namespace = /*#__PURE__*/_interopNamespace(Digest);
var PeerId__default = /*#__PURE__*/_interopDefaultLegacy(PeerId);
var isDomain__default = /*#__PURE__*/_interopDefaultLegacy(isDomain);

const mergeOptions = mergeOpts__default["default"].bind({ ignoreUndefined: true });
const log = Object.assign(debug__default["default"]('ipfs:name:resolve'), { error: debug__default["default"]('ipfs:name:resolve:error') });
const appendRemainder = (result, remainder) => remainder.length > 0 ? result + '/' + remainder.join('/') : result;
function createResolve({
  dns,
  ipns,
  peerId,
  isOnline,
  options: {offline}
}) {
  async function* resolve(name, options = {}) {
    options = mergeOptions({
      nocache: false,
      recursive: true
    }, options);
    if (offline && options && options.nocache) {
      throw errCode__default["default"](new Error('cannot specify both offline and nocache'), 'ERR_NOCACHE_AND_OFFLINE');
    }
    if (!isOnline() && !offline) {
      throw errCode__default["default"](new Error(utils.OFFLINE_ERROR), 'OFFLINE_ERROR');
    }
    if (!name) {
      name = peerId.toB58String();
    }
    if (!name.startsWith('/ipns/')) {
      name = `/ipns/${ name }`;
    }
    let [namespace, hash, ...remainder] = name.slice(1).split('/');
    try {
      if (hash.substring(0, 1) === '1') {
        const id = PeerId__default["default"].parse(hash);
        const digest = Digest__namespace.decode(id.toBytes());
        const libp2pKey = cid.CID.createV1(114, digest);
        hash = libp2pKey.toString(base36.base36);
      } else {
        const cid$1 = cid.CID.parse(hash);
        if (cid$1.version === 1) {
          hash = cid$1.toString(base36.base36);
        }
      }
    } catch (err) {
      if (isDomain__default["default"](hash)) {
        yield appendRemainder(await dns(hash, options), remainder);
        return;
      }
      log.error(err);
      throw errCode__default["default"](new Error('Invalid IPNS name'), 'ERR_IPNS_INVALID_NAME');
    }
    const value = await ipns.resolve(`/${ namespace }/${ hash }`, options);
    yield appendRemainder(value instanceof Uint8Array ? toString.toString(value) : value, remainder);
  }
  return withTimeoutOption.withTimeoutOption(resolve);
}

exports.createResolve = createResolve;
