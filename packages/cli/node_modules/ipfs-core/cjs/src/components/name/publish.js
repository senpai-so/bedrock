'use strict';

Object.defineProperty(exports, '__esModule', { value: true });

var debug = require('debug');
var parseDuration = require('parse-duration');
var crypto = require('libp2p-crypto');
var errCode = require('err-code');
var fromString = require('uint8arrays/from-string');
var toString = require('uint8arrays/to-string');
var utils = require('../../utils.js');
var withTimeoutOption = require('ipfs-core-utils/with-timeout-option');
var utils$1 = require('./utils.js');

function _interopDefaultLegacy (e) { return e && typeof e === 'object' && 'default' in e ? e : { 'default': e }; }

var debug__default = /*#__PURE__*/_interopDefaultLegacy(debug);
var parseDuration__default = /*#__PURE__*/_interopDefaultLegacy(parseDuration);
var crypto__default = /*#__PURE__*/_interopDefaultLegacy(crypto);
var errCode__default = /*#__PURE__*/_interopDefaultLegacy(errCode);

const log = Object.assign(debug__default["default"]('ipfs:name:publish'), { error: debug__default["default"]('ipfs:name:publish:error') });
function createPublish({ipns, repo, codecs, peerId, isOnline, keychain}) {
  const lookupKey = async keyName => {
    if (keyName === 'self') {
      return peerId.privKey;
    }
    try {
      const pem = await keychain.exportKey(keyName, 'temp');
      const privateKey = await crypto__default["default"].keys.import(pem, 'temp');
      return privateKey;
    } catch (err) {
      log.error(err);
      throw errCode__default["default"](err, 'ERR_CANNOT_GET_KEY');
    }
  };
  async function publish(value, options = {}) {
    const resolve = !(options.resolve === false);
    const lifetime = options.lifetime || '24h';
    const key = options.key || 'self';
    if (!isOnline()) {
      throw errCode__default["default"](new Error(utils.OFFLINE_ERROR), 'OFFLINE_ERROR');
    }
    try {
      value = utils.normalizePath(value);
    } catch (err) {
      log.error(err);
      throw err;
    }
    let pubLifetime = 0;
    try {
      pubLifetime = parseDuration__default["default"](lifetime) || 0;
      pubLifetime = parseFloat(pubLifetime.toFixed(6));
    } catch (err) {
      log.error(err);
      throw err;
    }
    const results = await Promise.all([
      lookupKey(key),
      resolve ? utils$1.resolvePath({
        ipns,
        repo,
        codecs
      }, value) : Promise.resolve()
    ]);
    const bytes = fromString.fromString(value);
    const result = await ipns.publish(results[0], bytes, pubLifetime);
    return {
      name: result.name,
      value: toString.toString(result.value)
    };
  }
  return withTimeoutOption.withTimeoutOption(publish);
}

exports.createPublish = createPublish;
