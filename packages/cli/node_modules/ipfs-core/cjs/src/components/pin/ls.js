'use strict';

Object.defineProperty(exports, '__esModule', { value: true });

var normaliseInput = require('ipfs-core-utils/pins/normalise-input');
var utils = require('../../utils.js');
var withTimeoutOption = require('ipfs-core-utils/with-timeout-option');
var errCode = require('err-code');
var pinTypes = require('ipfs-repo/pin-types');

function _interopDefaultLegacy (e) { return e && typeof e === 'object' && 'default' in e ? e : { 'default': e }; }

var errCode__default = /*#__PURE__*/_interopDefaultLegacy(errCode);

function toPin(type, cid, metadata) {
  const output = {
    type,
    cid
  };
  if (metadata) {
    output.metadata = metadata;
  }
  return output;
}
function createLs({repo, codecs}) {
  async function* ls(options = {}) {
    let type = pinTypes.PinTypes.all;
    if (options.type) {
      type = options.type;
      if (!Object.keys(pinTypes.PinTypes).includes(type)) {
        throw errCode__default["default"](new Error('Invalid pin type'), 'ERR_INVALID_PIN_TYPE');
      }
    }
    if (options.paths) {
      let matched = false;
      for await (const {path} of normaliseInput.normaliseInput(options.paths)) {
        const {cid} = await utils.resolvePath(repo, codecs, path);
        const {reason, pinned, parent, metadata} = await repo.pins.isPinnedWithType(cid, type);
        if (!pinned) {
          throw errCode__default["default"](new Error(`path '${ path }' is not pinned`), 'ERR_NOT_PINNED');
        }
        switch (reason) {
        case pinTypes.PinTypes.direct:
        case pinTypes.PinTypes.recursive:
          matched = true;
          yield toPin(reason, cid, metadata);
          break;
        default:
          matched = true;
          yield toPin(`${ pinTypes.PinTypes.indirect } through ${ parent }`, cid, metadata);
        }
      }
      if (!matched) {
        throw new Error('No match found');
      }
      return;
    }
    if (type === pinTypes.PinTypes.recursive || type === pinTypes.PinTypes.all) {
      for await (const {cid, metadata} of repo.pins.recursiveKeys()) {
        yield toPin(pinTypes.PinTypes.recursive, cid, metadata);
      }
    }
    if (type === pinTypes.PinTypes.indirect || type === pinTypes.PinTypes.all) {
      for await (const cid of repo.pins.indirectKeys(options)) {
        yield toPin(pinTypes.PinTypes.indirect, cid);
      }
    }
    if (type === pinTypes.PinTypes.direct || type === pinTypes.PinTypes.all) {
      for await (const {cid, metadata} of repo.pins.directKeys()) {
        yield toPin(pinTypes.PinTypes.direct, cid, metadata);
      }
    }
  }
  return withTimeoutOption.withTimeoutOption(ls);
}

exports.createLs = createLs;
