'use strict';

Object.defineProperty(exports, '__esModule', { value: true });

var PeerId = require('peer-id');
var errCode = require('err-code');
var errors = require('../errors.js');
var get = require('dlv');
var withTimeoutOption = require('ipfs-core-utils/with-timeout-option');
var map = require('it-map');
var cid = require('multiformats/cid');
var base58 = require('multiformats/bases/base58');
var base36 = require('multiformats/bases/base36');
var concat = require('uint8arrays/concat');
var fromString = require('uint8arrays/from-string');

function _interopDefaultLegacy (e) { return e && typeof e === 'object' && 'default' in e ? e : { 'default': e }; }

var PeerId__default = /*#__PURE__*/_interopDefaultLegacy(PeerId);
var errCode__default = /*#__PURE__*/_interopDefaultLegacy(errCode);
var get__default = /*#__PURE__*/_interopDefaultLegacy(get);
var map__default = /*#__PURE__*/_interopDefaultLegacy(map);

const IPNS_PREFIX = '/ipns/';
function toDHTKey(str) {
  if (str.startsWith(IPNS_PREFIX)) {
    str = str.substring(IPNS_PREFIX.length);
  }
  let buf;
  if (str[0] === '1' || str[0] === 'Q') {
    str = `z${ str }`;
  }
  if (str[0] === 'z') {
    buf = base58.base58btc.decode(str);
  }
  if (str[0] === 'k') {
    buf = base36.base36.decode(str);
  }
  if (!buf) {
    throw new Error('Could not parse string');
  }
  if (buf[0] !== 1 && buf[1] !== 114) {
    buf = concat.concat([
      [
        1,
        114
      ],
      buf
    ]);
  }
  if (buf.length !== 40) {
    throw new Error('Incorrect length ' + buf.length);
  }
  return concat.concat([
    fromString.fromString(IPNS_PREFIX),
    buf.subarray(2)
  ]);
}
function mapEvent(event) {
  if (event.name === 'SENDING_QUERY') {
    return {
      type: event.type,
      name: event.name,
      to: event.to.toB58String()
    };
  }
  if (event.name === 'PEER_RESPONSE') {
    return {
      type: event.type,
      name: event.name,
      messageType: event.messageType,
      messageName: event.messageName,
      closer: event.closer.map(({id, multiaddrs}) => ({
        id: id.toB58String(),
        multiaddrs
      })),
      providers: event.providers.map(({id, multiaddrs}) => ({
        id: id.toB58String(),
        multiaddrs
      })),
      record: event.record,
      from: event.from.toB58String()
    };
  }
  if (event.name === 'FINAL_PEER') {
    return {
      type: event.type,
      name: event.name,
      from: event.from.toB58String(),
      peer: {
        id: event.peer.id.toB58String(),
        multiaddrs: event.peer.multiaddrs
      }
    };
  }
  if (event.name === 'QUERY_ERROR') {
    return {
      type: event.type,
      name: event.name,
      error: event.error,
      from: event.from.toB58String()
    };
  }
  if (event.name === 'PROVIDER') {
    return {
      type: event.type,
      name: event.name,
      providers: event.providers.map(({id, multiaddrs}) => ({
        id: id.toB58String(),
        multiaddrs
      })),
      from: event.from.toB58String()
    };
  }
  if (event.name === 'VALUE') {
    return {
      type: event.type,
      name: event.name,
      value: event.value,
      from: event.from.toB58String()
    };
  }
  if (event.name === 'ADDING_PEER') {
    return {
      type: event.type,
      name: event.name,
      peer: event.peer.toB58String()
    };
  }
  if (event.name === 'DIALING_PEER') {
    return {
      type: event.type,
      name: event.name,
      peer: event.peer.toB58String()
    };
  }
  throw errCode__default["default"](new Error('Unknown DHT event type'), 'ERR_UNKNOWN_DHT_EVENT');
}
function createDht({network, repo, peerId}) {
  const {get, put, findProvs, findPeer, provide, query} = {
    async *get(key, options = {}) {
      const {libp2p} = await use(network, peerId, options);
      const dhtKey = key instanceof Uint8Array ? key : toDHTKey(key);
      yield* map__default["default"](libp2p._dht.get(dhtKey, options), mapEvent);
    },
    async *put(key, value, options) {
      const {libp2p} = await use(network, peerId, options);
      const dhtKey = key instanceof Uint8Array ? key : toDHTKey(key);
      yield* map__default["default"](libp2p._dht.put(dhtKey, value), mapEvent);
    },
    async *findProvs(cid, options = {}) {
      const {libp2p} = await use(network, peerId, options);
      yield* map__default["default"](libp2p._dht.findProviders(cid, { signal: options.signal }), mapEvent);
    },
    async *findPeer(peerIdToFind, options = {}) {
      const {libp2p} = await use(network, peerId, options);
      yield* map__default["default"](libp2p._dht.findPeer(PeerId__default["default"].parse(peerIdToFind), { signal: options.signal }), mapEvent);
    },
    async *provide(cid, options = { recursive: false }) {
      const {libp2p} = await use(network, peerId, options);
      const hasBlock = await repo.blocks.has(cid);
      if (!hasBlock) {
        throw errCode__default["default"](new Error('block(s) not found locally, cannot provide'), 'ERR_BLOCK_NOT_FOUND');
      }
      if (options.recursive) {
        throw errCode__default["default"](new Error('not implemented yet'), 'ERR_NOT_IMPLEMENTED_YET');
      }
      yield* map__default["default"](libp2p._dht.provide(cid), mapEvent);
    },
    async *query(peerIdToQuery, options = {}) {
      const {libp2p} = await use(network, peerId, options);
      let bytes;
      const asCid = cid.CID.asCID(peerIdToQuery);
      if (asCid != null) {
        bytes = asCid.multihash.bytes;
      } else {
        bytes = PeerId__default["default"].parse(peerIdToQuery.toString()).toBytes();
      }
      yield* map__default["default"](libp2p._dht.getClosestPeers(bytes, options), mapEvent);
    }
  };
  return {
    get: withTimeoutOption.withTimeoutOption(get),
    put: withTimeoutOption.withTimeoutOption(put),
    findProvs: withTimeoutOption.withTimeoutOption(findProvs),
    findPeer: withTimeoutOption.withTimeoutOption(findPeer),
    provide: withTimeoutOption.withTimeoutOption(provide),
    query: withTimeoutOption.withTimeoutOption(query)
  };
}
const use = async (network, peerId, options) => {
  const net = await network.use(options);
  if (get__default["default"](net.libp2p, '_config.dht.enabled', false)) {
    return net;
  } else {
    const fn = async function* () {
      yield {
        from: peerId,
        name: 'QUERY_ERROR',
        type: 3,
        error: new errors.NotEnabledError('dht not enabled')
      };
    };
    return {
      libp2p: {
        _dht: {
          get: fn,
          put: fn,
          findProvs: fn,
          findPeer: fn,
          provide: fn,
          query: fn
        }
      }
    };
  }
};

exports.createDht = createDht;
