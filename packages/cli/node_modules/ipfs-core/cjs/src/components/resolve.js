'use strict';

Object.defineProperty(exports, '__esModule', { value: true });

var isIpfs = require('is-ipfs');
var cid = require('multiformats/cid');
var PeerId = require('peer-id');
var withTimeoutOption = require('ipfs-core-utils/with-timeout-option');
var utils = require('../utils.js');

function _interopDefaultLegacy (e) { return e && typeof e === 'object' && 'default' in e ? e : { 'default': e }; }

var isIpfs__default = /*#__PURE__*/_interopDefaultLegacy(isIpfs);
var PeerId__default = /*#__PURE__*/_interopDefaultLegacy(PeerId);

function createResolve({repo, codecs, bases, name}) {
  async function resolve(path, opts = {}) {
    if (!isIpfs__default["default"].path(path)) {
      throw new Error('invalid argument ' + path);
    }
    if (isIpfs__default["default"].ipnsPath(path)) {
      for await (const resolvedPath of name.resolve(path, opts)) {
        path = resolvedPath;
      }
    }
    const [, schema, hash, ...rest] = path.split('/');
    const base = opts.cidBase ? await bases.getBase(opts.cidBase) : undefined;
    const bytes = parseBytes(hash);
    if (rest.length === 0) {
      const str = base ? base.encoder.encode(bytes) : hash;
      return `/${ schema }/${ str }`;
    }
    const cid$1 = cid.CID.decode(bytes);
    path = rest.join('/');
    const results = utils.resolve(cid$1, path, codecs, repo, opts);
    let value = cid$1;
    let remainderPath = path;
    for await (const result of results) {
      if (cid.CID.asCID(result.value)) {
        value = result.value;
        remainderPath = result.remainderPath;
      }
    }
    return `/ipfs/${ value.toString(base && base.encoder) }${ remainderPath ? '/' + remainderPath : '' }`;
  }
  return withTimeoutOption.withTimeoutOption(resolve);
}
function parseBytes(str) {
  try {
    return PeerId__default["default"].parse(str).toBytes();
  } catch {
    return cid.CID.parse(str).bytes;
  }
}

exports.createResolve = createResolve;
