'use strict';

Object.defineProperty(exports, '__esModule', { value: true });

var errCode = require('err-code');
var parallel = require('it-parallel');
var map = require('it-map');
var filter = require('it-filter');
var itPipe = require('it-pipe');
var utils = require('./utils.js');
var withTimeoutOption = require('ipfs-core-utils/with-timeout-option');

function _interopDefaultLegacy (e) { return e && typeof e === 'object' && 'default' in e ? e : { 'default': e }; }

var errCode__default = /*#__PURE__*/_interopDefaultLegacy(errCode);
var parallel__default = /*#__PURE__*/_interopDefaultLegacy(parallel);
var map__default = /*#__PURE__*/_interopDefaultLegacy(map);
var filter__default = /*#__PURE__*/_interopDefaultLegacy(filter);

const BLOCK_RM_CONCURRENCY = 8;
function createRm({repo}) {
  async function* rm(cids, options = {}) {
    if (!Array.isArray(cids)) {
      cids = [cids];
    }
    const release = await repo.gcLock.writeLock();
    try {
      yield* itPipe.pipe(cids, source => map__default["default"](source, cid => {
        return async () => {
          cid = utils.cleanCid(cid);
          const result = { cid };
          try {
            const has = await repo.blocks.has(cid);
            if (!has) {
              throw errCode__default["default"](new Error('block not found'), 'ERR_BLOCK_NOT_FOUND');
            }
            await repo.blocks.delete(cid);
          } catch (err) {
            if (!options.force) {
              err.message = `cannot remove ${ cid }: ${ err.message }`;
              result.error = err;
            }
          }
          return result;
        };
      }), source => parallel__default["default"](source, { concurrency: BLOCK_RM_CONCURRENCY }), source => filter__default["default"](source, () => !options.quiet));
    } finally {
      release();
    }
  }
  return withTimeoutOption.withTimeoutOption(rm);
}

exports.createRm = createRm;
