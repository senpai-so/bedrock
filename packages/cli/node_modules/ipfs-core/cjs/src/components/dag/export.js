'use strict';

Object.defineProperty(exports, '__esModule', { value: true });

var cid = require('multiformats/cid');
var block = require('multiformats/block');
var base58 = require('multiformats/bases/base58');
var writer = require('@ipld/car/writer');
var withTimeoutOption = require('ipfs-core-utils/with-timeout-option');
var debug = require('debug');
var raw = require('multiformats/codecs/raw');
var json = require('multiformats/codecs/json');

function _interopDefaultLegacy (e) { return e && typeof e === 'object' && 'default' in e ? e : { 'default': e }; }

function _interopNamespace(e) {
  if (e && e.__esModule) return e;
  var n = Object.create(null);
  if (e) {
    Object.keys(e).forEach(function (k) {
      if (k !== 'default') {
        var d = Object.getOwnPropertyDescriptor(e, k);
        Object.defineProperty(n, k, d.get ? d : {
          enumerable: true,
          get: function () { return e[k]; }
        });
      }
    });
  }
  n["default"] = e;
  return Object.freeze(n);
}

var debug__default = /*#__PURE__*/_interopDefaultLegacy(debug);
var raw__namespace = /*#__PURE__*/_interopNamespace(raw);
var json__namespace = /*#__PURE__*/_interopNamespace(json);

const log = debug__default["default"]('ipfs:components:dag:import');
const NO_LINKS_CODECS = [
  raw__namespace.code,
  json__namespace.code
];
function createExport({repo, preload, codecs}) {
  async function* dagExport(root, options = {}) {
    if (options.preload !== false) {
      preload(root);
    }
    const cid$1 = cid.CID.asCID(root);
    if (!cid$1) {
      throw new Error(`Unexpected error converting CID type: ${ root }`);
    }
    log(`Exporting ${ cid$1 } as car`);
    const {writer: writer$1, out} = await writer.CarWriter.create([cid$1]);
    let err = null;
    (async () => {
      try {
        await traverseWrite(repo, {
          signal: options.signal,
          timeout: options.timeout
        }, cid$1, writer$1, codecs);
      } catch (e) {
        err = e;
      } finally {
        writer$1.close();
      }
    })();
    for await (const chunk of out) {
      if (err) {
        break;
      }
      yield chunk;
    }
    if (err) {
      throw err;
    }
  }
  return withTimeoutOption.withTimeoutOption(dagExport);
}
async function traverseWrite(repo, options, cid, writer, codecs, seen = new Set()) {
  const b58Cid = cid.toString(base58.base58btc);
  if (seen.has(b58Cid)) {
    return;
  }
  const block = await getBlock(repo, options, cid, codecs);
  log(`Adding block ${ cid } to car`);
  await writer.put(block);
  seen.add(b58Cid);
  for (const link of block.links) {
    await traverseWrite(repo, options, link, writer, codecs, seen);
  }
}
async function getBlock(repo, options, cid, codecs) {
  const bytes = await repo.blocks.get(cid, options);
  let links = [];
  const codec = await codecs.getCodec(cid.code);
  if (codec) {
    const block$1 = block.createUnsafe({
      bytes,
      cid,
      codec
    });
    links = [...block$1.links()].map(l => l[1]);
  } else if (!NO_LINKS_CODECS.includes(cid.code)) {
    throw new Error(`Can't decode links in block with codec 0x${ cid.code.toString(16) } to form complete DAG`);
  }
  return {
    cid,
    bytes,
    links
  };
}

exports.createExport = createExport;
