'use strict';

Object.defineProperty(exports, '__esModule', { value: true });

var iterator = require('@ipld/car/iterator');
var withTimeoutOption = require('ipfs-core-utils/with-timeout-option');
var itPeekable = require('it-peekable');
var drain = require('it-drain');
var map = require('it-map');
var debug = require('debug');

function _interopDefaultLegacy (e) { return e && typeof e === 'object' && 'default' in e ? e : { 'default': e }; }

var itPeekable__default = /*#__PURE__*/_interopDefaultLegacy(itPeekable);
var drain__default = /*#__PURE__*/_interopDefaultLegacy(drain);
var map__default = /*#__PURE__*/_interopDefaultLegacy(map);
var debug__default = /*#__PURE__*/_interopDefaultLegacy(debug);

const log = debug__default["default"]('ipfs:components:dag:import');
function createImport({repo}) {
  async function* dagImport(sources, options = {}) {
    const release = await repo.gcLock.readLock();
    try {
      const abortOptions = {
        signal: options.signal,
        timeout: options.timeout
      };
      const peekable = itPeekable__default["default"](sources);
      const {value, done} = await peekable.peek();
      if (done) {
        return;
      }
      if (value) {
        peekable.push(value);
      }
      let cars;
      if (value instanceof Uint8Array) {
        cars = [peekable];
      } else {
        cars = peekable;
      }
      for await (const car of cars) {
        const roots = await importCar(repo, abortOptions, car);
        if (options.pinRoots !== false) {
          for (const cid of roots) {
            let pinErrorMsg = '';
            try {
              if (await repo.blocks.has(cid)) {
                log(`Pinning root ${ cid }`);
                await repo.pins.pinRecursively(cid);
              } else {
                pinErrorMsg = 'blockstore: block not found';
              }
            } catch (err) {
              pinErrorMsg = err.message;
            }
            yield {
              root: {
                cid,
                pinErrorMsg
              }
            };
          }
        }
      }
    } finally {
      release();
    }
  }
  return withTimeoutOption.withTimeoutOption(dagImport);
}
async function importCar(repo, options, source) {
  const reader = await iterator.CarBlockIterator.fromIterable(source);
  const roots = await reader.getRoots();
  await drain__default["default"](repo.blocks.putMany(map__default["default"](reader, ({
    cid: key,
    bytes: value
  }) => {
    log(`Import block ${ key }`);
    return {
      key,
      value
    };
  }), { signal: options.signal }));
  return roots;
}

exports.createImport = createImport;
