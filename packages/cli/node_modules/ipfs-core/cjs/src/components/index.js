'use strict';

Object.defineProperty(exports, '__esModule', { value: true });

var mergeOpts = require('merge-options');
var env_js = require('ipfs-utils/src/env.js');
var debug = require('debug');
var errCode = require('err-code');
var ipfsUnixfs = require('ipfs-unixfs');
var dagPB = require('@ipld/dag-pb');
var dagCBOR = require('@ipld/dag-cbor');
var dagJSON = require('@ipld/dag-json');
var identity = require('multiformats/hashes/identity');
var basics = require('multiformats/basics');
var initAssets = require('ipfs-core-config/init-assets');
var errors = require('../errors.js');
var fromString = require('uint8arrays/from-string');
var start = require('./start.js');
var stop = require('./stop.js');
var dns = require('./dns.js');
var isOnline = require('./is-online.js');
var resolve = require('./resolve.js');
var index = require('./pin/index.js');
var ipns = require('./ipns.js');
var index$2 = require('./name/index.js');
var index$4 = require('./refs/index.js');
var local = require('./refs/local.js');
var index$6 = require('./bitswap/index.js');
var index$7 = require('./bootstrap/index.js');
var index$1 = require('./block/index.js');
var root = require('./root.js');
var version = require('./version.js');
var id = require('./id.js');
var index$8 = require('./config/index.js');
var index$3 = require('./dag/index.js');
var preload = require('../preload.js');
var mfsPreload = require('../mfs-preload.js');
var index$5 = require('./files/index.js');
var index$9 = require('./key/index.js');
var index$a = require('./object/index.js');
var index$b = require('./repo/index.js');
var index$c = require('./stats/index.js');
var storage = require('./storage.js');
var network = require('./network.js');
var service = require('../utils/service.js');
var index$d = require('./swarm/index.js');
var ping = require('./ping.js');
var dht = require('./dht.js');
var pubsub = require('./pubsub.js');
var multicodecs = require('ipfs-core-utils/multicodecs');
var multihashes = require('ipfs-core-utils/multihashes');
var multibases = require('ipfs-core-utils/multibases');

function _interopDefaultLegacy (e) { return e && typeof e === 'object' && 'default' in e ? e : { 'default': e }; }

function _interopNamespace(e) {
  if (e && e.__esModule) return e;
  var n = Object.create(null);
  if (e) {
    Object.keys(e).forEach(function (k) {
      if (k !== 'default') {
        var d = Object.getOwnPropertyDescriptor(e, k);
        Object.defineProperty(n, k, d.get ? d : {
          enumerable: true,
          get: function () { return e[k]; }
        });
      }
    });
  }
  n["default"] = e;
  return Object.freeze(n);
}

var mergeOpts__default = /*#__PURE__*/_interopDefaultLegacy(mergeOpts);
var debug__default = /*#__PURE__*/_interopDefaultLegacy(debug);
var errCode__default = /*#__PURE__*/_interopDefaultLegacy(errCode);
var dagPB__namespace = /*#__PURE__*/_interopNamespace(dagPB);
var dagCBOR__namespace = /*#__PURE__*/_interopNamespace(dagCBOR);
var dagJSON__namespace = /*#__PURE__*/_interopNamespace(dagJSON);

const mergeOptions = mergeOpts__default["default"].bind({ ignoreUndefined: true });
const log = debug__default["default"]('ipfs');
class IPFS {
  constructor({print, storage, codecs, options}) {
    const {peerId, repo, keychain} = storage;
    const network$1 = service.Service.create(network.Network);
    const preload$1 = preload.createPreloader(options.preload);
    const dns$1 = dns.createDns();
    const isOnline$1 = isOnline.createIsOnline({ network: network$1 });
    const ipns$1 = new ipns.IPNSAPI(options);
    const multihashHashers = Object.values(basics.hashes);
    (options.ipld && options.ipld.hashers ? options.ipld.hashers : []).forEach(hasher => multihashHashers.push(hasher));
    this.hashers = new multihashes.Multihashes({
      hashers: multihashHashers,
      loadHasher: options.ipld && options.ipld.loadHasher
    });
    const multibaseCodecs = Object.values(basics.bases);
    (options.ipld && options.ipld.bases ? options.ipld.bases : []).forEach(base => multibaseCodecs.push(base));
    this.bases = new multibases.Multibases({
      bases: multibaseCodecs,
      loadBase: options.ipld && options.ipld.loadBase
    });
    const pin = new index.PinAPI({
      repo,
      codecs
    });
    const block = new index$1.BlockAPI({
      codecs,
      hashers: this.hashers,
      preload: preload$1,
      repo
    });
    const name = new index$2.NameAPI({
      dns: dns$1,
      ipns: ipns$1,
      repo,
      codecs,
      peerId,
      isOnline: isOnline$1,
      keychain,
      options
    });
    const resolve$1 = resolve.createResolve({
      repo,
      codecs,
      bases: this.bases,
      name
    });
    const dag = new index$3.DagAPI({
      repo,
      codecs,
      hashers: this.hashers,
      preload: preload$1
    });
    const refs = Object.assign(index$4.createRefs({
      repo,
      codecs,
      resolve: resolve$1,
      preload: preload$1
    }), { local: local.createLocal({ repo: storage.repo }) });
    const {add, addAll, cat, get, ls} = new root.RootAPI({
      preload: preload$1,
      repo,
      options: options.EXPERIMENTAL
    });
    const files = index$5.createFiles({
      repo,
      preload: preload$1,
      hashers: this.hashers,
      options
    });
    const mfsPreload$1 = mfsPreload.createMfsPreloader({
      files,
      preload: preload$1,
      options: options.preload
    });
    this.preload = preload$1;
    this.name = name;
    this.ipns = ipns$1;
    this.pin = pin;
    this.resolve = resolve$1;
    this.block = block;
    this.refs = refs;
    this.start = start.createStart({
      network: network$1,
      peerId,
      repo,
      preload: preload$1,
      ipns: ipns$1,
      mfsPreload: mfsPreload$1,
      print,
      keychain,
      hashers: this.hashers,
      options
    });
    this.stop = stop.createStop({
      network: network$1,
      preload: preload$1,
      mfsPreload: mfsPreload$1,
      ipns: ipns$1,
      repo
    });
    this.dht = dht.createDht({
      network: network$1,
      repo,
      peerId
    });
    this.pubsub = pubsub.createPubsub({
      network: network$1,
      config: options.config
    });
    this.dns = dns$1;
    this.isOnline = isOnline$1;
    this.id = id.createId({
      network: network$1,
      peerId
    });
    this.version = version.createVersion({ repo });
    this.bitswap = new index$6.BitswapAPI({ network: network$1 });
    this.bootstrap = new index$7.BootstrapAPI({ repo });
    this.config = index$8.createConfig({ repo });
    this.ping = ping.createPing({ network: network$1 });
    this.add = add;
    this.addAll = addAll;
    this.cat = cat;
    this.get = get;
    this.ls = ls;
    this.dag = dag;
    this.files = files;
    this.key = new index$9.KeyAPI({ keychain });
    this.object = new index$a.ObjectAPI({
      preload: preload$1,
      codecs,
      repo
    });
    this.repo = new index$b.RepoAPI({
      repo,
      hashers: this.hashers
    });
    this.stats = new index$c.StatsAPI({
      repo,
      network: network$1
    });
    this.swarm = new index$d.SwarmAPI({ network: network$1 });
    Object.defineProperty(this, 'libp2p', {
      get() {
        const net = network$1.try();
        return net ? net.libp2p : undefined;
      }
    });
    const notImplemented = () => Promise.reject(errCode__default["default"](new Error('Not implemented'), 'ERR_NOT_IMPLEMENTED'));
    const notImplementedIter = async function* () {
      throw errCode__default["default"](new Error('Not implemented'), 'ERR_NOT_IMPLEMENTED');
    };
    this.commands = notImplemented;
    this.diag = {
      cmds: notImplemented,
      net: notImplemented,
      sys: notImplemented
    };
    this.log = {
      level: notImplemented,
      ls: notImplemented,
      tail: notImplementedIter
    };
    this.mount = notImplemented;
    this.codecs = codecs;
  }
  async init() {
    throw new errors.AlreadyInitializedError();
  }
}
const addEmptyDir = async ipfs => {
  const buf = dagPB__namespace.encode({
    Data: new ipfsUnixfs.UnixFS({ type: 'directory' }).marshal(),
    Links: []
  });
  const cid = await ipfs.block.put(buf, {
    mhtype: 'sha2-256',
    format: 'dag-pb'
  });
  await ipfs.pin.add(cid);
  return cid;
};
const getDefaultOptions = () => ({
  start: true,
  EXPERIMENTAL: {},
  preload: {
    enabled: !env_js.isTest,
    addresses: [
      '/dns4/node0.preload.ipfs.io/https',
      '/dns4/node1.preload.ipfs.io/https',
      '/dns4/node2.preload.ipfs.io/https',
      '/dns4/node3.preload.ipfs.io/https'
    ]
  }
});
async function create(options = {}) {
  options = mergeOptions(getDefaultOptions(), options);
  const initOptions = options.init || {};
  const id = {
    name: identity.identity.name,
    code: identity.identity.code,
    encode: id => id,
    decode: id => id
  };
  const blockCodecs = Object.values(basics.codecs);
  [
    dagPB__namespace,
    dagCBOR__namespace,
    dagJSON__namespace,
    id
  ].concat(options.ipld && options.ipld.codecs || []).forEach(codec => blockCodecs.push(codec));
  const multicodecs$1 = new multicodecs.Multicodecs({
    codecs: blockCodecs,
    loadCodec: options.ipld && options.ipld.loadCodec
  });
  const print = options.silent ? log : console.log;
  const storage$1 = await storage.Storage.start(print, multicodecs$1, options);
  const config = await storage$1.repo.config.getAll();
  const ipfs = new IPFS({
    storage: storage$1,
    print,
    codecs: multicodecs$1,
    options: {
      ...options,
      config
    }
  });
  await ipfs.preload.start();
  ipfs.ipns.startOffline(storage$1);
  if (storage$1.isNew && !initOptions.emptyRepo) {
    const cid = await addEmptyDir(ipfs);
    log('adding default assets');
    await initAssets.initAssets({
      addAll: ipfs.addAll,
      print
    });
    log('initializing IPNS keyspace');
    await ipfs.ipns.initializeKeyspace(storage$1.peerId.privKey, fromString.fromString(`/ipfs/${ cid }`));
  }
  if (options.start !== false) {
    await ipfs.start();
  }
  return ipfs;
}

exports.create = create;
