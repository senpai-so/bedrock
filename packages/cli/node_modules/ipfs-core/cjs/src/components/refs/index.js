'use strict';

Object.defineProperty(exports, '__esModule', { value: true });

var dagPB = require('@ipld/dag-pb');
var Errors = require('datastore-core/errors');
var toCidAndPath = require('ipfs-core-utils/to-cid-and-path');
var cid = require('multiformats/cid');
var timeoutAbortController = require('timeout-abort-controller');
var anySignal = require('any-signal');

function _interopNamespace(e) {
  if (e && e.__esModule) return e;
  var n = Object.create(null);
  if (e) {
    Object.keys(e).forEach(function (k) {
      if (k !== 'default') {
        var d = Object.getOwnPropertyDescriptor(e, k);
        Object.defineProperty(n, k, d.get ? d : {
          enumerable: true,
          get: function () { return e[k]; }
        });
      }
    });
  }
  n["default"] = e;
  return Object.freeze(n);
}

var dagPB__namespace = /*#__PURE__*/_interopNamespace(dagPB);

const ERR_NOT_FOUND = Errors.notFoundError().code;
const Format = {
  default: '<dst>',
  edges: '<src> -> <dst>'
};
function createRefs({repo, codecs, resolve, preload}) {
  async function* refs(ipfsPath, options = {}) {
    if (options.maxDepth === 0) {
      return;
    }
    if (options.edges && options.format && options.format !== Format.default) {
      throw new Error('Cannot set edges to true and also specify format');
    }
    options.format = options.edges ? Format.edges : options.format;
    if (typeof options.maxDepth !== 'number') {
      options.maxDepth = options.recursive ? Infinity : 1;
    }
    if (options.timeout) {
      const controller = new timeoutAbortController.TimeoutController(options.timeout);
      const signals = [controller.signal];
      if (options.signal) {
        signals.push(options.signal);
      }
      options.signal = anySignal.anySignal(signals);
    }
    const rawPaths = Array.isArray(ipfsPath) ? ipfsPath : [ipfsPath];
    const paths = rawPaths.map(p => getFullPath(preload, p, options));
    for (const path of paths) {
      try {
        yield* refsStream(resolve, repo, codecs, path, options);
      } catch (err) {
        yield {
          ref: '',
          err: err.message
        };
      }
    }
  }
  return refs;
}
function getFullPath(preload, ipfsPath, options) {
  const {cid, path} = toCidAndPath.toCidAndPath(ipfsPath);
  if (options.preload !== false) {
    preload(cid);
  }
  return `/ipfs/${ cid }${ path || '' }`;
}
async function* refsStream(resolve, repo, codecs, path, options) {
  const resPath = await resolve(path, options);
  const {cid} = toCidAndPath.toCidAndPath(resPath);
  const maxDepth = options.maxDepth != null ? options.maxDepth : Infinity;
  const unique = options.unique || false;
  for await (const obj of objectStream(repo, codecs, cid, maxDepth, unique, options)) {
    if (!obj.parent) {
      continue;
    }
    if (obj.isDuplicate) {
      continue;
    }
    yield { ref: formatLink(obj.parent.cid, obj.node.cid, obj.node.name, options.format) };
  }
}
function formatLink(srcCid, dstCid, linkName = '', format = Format.default) {
  let out = format.replace(/<src>/g, srcCid.toString());
  out = out.replace(/<dst>/g, dstCid.toString());
  out = out.replace(/<linkname>/g, linkName);
  return out;
}
async function* objectStream(repo, codecs, rootCid, maxDepth, uniqueOnly, options) {
  const seen = new Set();
  async function* traverseLevel(parent, depth) {
    const nextLevelDepth = depth + 1;
    if (nextLevelDepth > maxDepth) {
      return;
    }
    try {
      for await (const link of getLinks(repo, codecs, parent.cid, options)) {
        yield {
          parent: parent,
          node: link,
          isDuplicate: uniqueOnly && seen.has(link.cid.toString())
        };
        if (uniqueOnly) {
          seen.add(link.cid.toString());
        }
        yield* traverseLevel(link, nextLevelDepth);
      }
    } catch (err) {
      if (err.code === ERR_NOT_FOUND) {
        err.message = `Could not find object with CID: ${ parent.cid }`;
      }
      throw err;
    }
  }
  yield* traverseLevel({ cid: rootCid }, 0);
}
async function* getLinks(repo, codecs, cid, options) {
  const block = await repo.blocks.get(cid, options);
  const codec = await codecs.getCodec(cid.code);
  const value = codec.decode(block);
  const isDagPb = cid.code === dagPB__namespace.code;
  const base = [];
  for (const [name, cid] of links(value, base)) {
    if (isDagPb) {
      const match = name.match(/^Links\/(\d+)\/Hash$/);
      if (match) {
        const index = Number(match[1]);
        if (index < value.Links.length) {
          yield {
            name: value.Links[index].Name,
            cid
          };
          continue;
        }
      }
    }
    yield {
      name,
      cid
    };
  }
}
const links = function* (source, base) {
  if (source == null) {
    return;
  }
  if (source instanceof Uint8Array) {
    return;
  }
  for (const [key, value] of Object.entries(source)) {
    const path = [
      ...base,
      key
    ];
    if (value != null && typeof value === 'object') {
      if (Array.isArray(value)) {
        for (const [index, element] of value.entries()) {
          const elementPath = [
            ...path,
            index
          ];
          const cid$1 = cid.CID.asCID(element);
          if (cid$1) {
            yield [
              elementPath.join('/'),
              cid$1
            ];
          } else if (typeof element === 'object') {
            yield* links(element, elementPath);
          }
        }
      } else {
        const cid$1 = cid.CID.asCID(value);
        if (cid$1) {
          yield [
            path.join('/'),
            cid$1
          ];
        } else {
          yield* links(value, path);
        }
      }
    }
  }
  return [];
};

exports.Format = Format;
exports.createRefs = createRefs;
