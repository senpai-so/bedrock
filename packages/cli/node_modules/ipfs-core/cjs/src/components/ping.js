'use strict';

Object.defineProperty(exports, '__esModule', { value: true });

var PeerId = require('peer-id');
var withTimeoutOption = require('ipfs-core-utils/with-timeout-option');

function _interopDefaultLegacy (e) { return e && typeof e === 'object' && 'default' in e ? e : { 'default': e }; }

var PeerId__default = /*#__PURE__*/_interopDefaultLegacy(PeerId);

const basePacket = {
  success: true,
  time: 0,
  text: ''
};
function createPing({network}) {
  async function* ping(peerId, options = {}) {
    const {libp2p} = await network.use();
    options.count = options.count || 10;
    const peer = PeerId__default["default"].createFromB58String(peerId);
    const storedPeer = libp2p.peerStore.get(peer);
    let id = storedPeer && storedPeer.id;
    if (!id) {
      yield {
        ...basePacket,
        text: `Looking up peer ${ peerId }`
      };
      const remotePeer = await libp2p.peerRouting.findPeer(peer);
      id = remotePeer && remotePeer.id;
    }
    if (!id) {
      throw new Error('Peer was not found');
    }
    yield {
      ...basePacket,
      text: `PING ${ id.toB58String() }`
    };
    let packetCount = 0;
    let totalTime = 0;
    for (let i = 0; i < options.count; i++) {
      try {
        const time = await libp2p.ping(id);
        totalTime += time;
        packetCount++;
        yield {
          ...basePacket,
          time
        };
      } catch (err) {
        yield {
          ...basePacket,
          success: false,
          text: err.toString()
        };
      }
    }
    if (packetCount) {
      const average = totalTime / packetCount;
      yield {
        ...basePacket,
        text: `Average latency: ${ average }ms`
      };
    }
  }
  return withTimeoutOption.withTimeoutOption(ping);
}

exports.createPing = createPing;
