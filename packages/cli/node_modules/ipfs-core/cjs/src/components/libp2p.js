'use strict';

Object.defineProperty(exports, '__esModule', { value: true });

var get = require('dlv');
var mergeOpts = require('merge-options');
var errCode = require('err-code');
var libp2pPubsubRouters = require('ipfs-core-config/libp2p-pubsub-routers');
var DelegatedPeerRouter = require('libp2p-delegated-peer-routing');
var DelegatedContentRouter = require('libp2p-delegated-content-routing');
var ipfsHttpClient = require('ipfs-http-client');
var multiaddr = require('multiaddr');
var version = require('../version.js');
var libp2p = require('ipfs-core-config/libp2p');
var bootstrap = require('libp2p-bootstrap');
var Libp2p = require('libp2p');
var ipns = require('ipns');

function _interopDefaultLegacy (e) { return e && typeof e === 'object' && 'default' in e ? e : { 'default': e }; }

function _interopNamespace(e) {
  if (e && e.__esModule) return e;
  var n = Object.create(null);
  if (e) {
    Object.keys(e).forEach(function (k) {
      if (k !== 'default') {
        var d = Object.getOwnPropertyDescriptor(e, k);
        Object.defineProperty(n, k, d.get ? d : {
          enumerable: true,
          get: function () { return e[k]; }
        });
      }
    });
  }
  n["default"] = e;
  return Object.freeze(n);
}

var get__default = /*#__PURE__*/_interopDefaultLegacy(get);
var mergeOpts__default = /*#__PURE__*/_interopDefaultLegacy(mergeOpts);
var errCode__default = /*#__PURE__*/_interopDefaultLegacy(errCode);
var DelegatedPeerRouter__default = /*#__PURE__*/_interopDefaultLegacy(DelegatedPeerRouter);
var DelegatedContentRouter__default = /*#__PURE__*/_interopDefaultLegacy(DelegatedContentRouter);
var bootstrap__default = /*#__PURE__*/_interopDefaultLegacy(bootstrap);
var Libp2p__default = /*#__PURE__*/_interopDefaultLegacy(Libp2p);
var ipns__namespace = /*#__PURE__*/_interopNamespace(ipns);

const mergeOptions = mergeOpts__default["default"].bind({ ignoreUndefined: true });
function createLibp2p({options = {}, peerId, multiaddrs = [], repo, keychainConfig = {}, config = {}}) {
  const {datastore, keys} = repo;
  const libp2pOptions = getLibp2pOptions({
    options,
    config,
    datastore,
    keys,
    keychainConfig,
    peerId,
    multiaddrs
  });
  if (typeof options.libp2p === 'function') {
    return options.libp2p({
      libp2pOptions,
      options,
      config,
      datastore,
      peerId
    });
  }
  return Libp2p__default["default"].create(libp2pOptions);
}
function getLibp2pOptions({options, config, datastore, keys, keychainConfig, peerId, multiaddrs}) {
  const getPubsubRouter = () => {
    const router = get__default["default"](config, 'Pubsub.Router') || 'gossipsub';
    if (!libp2pPubsubRouters.routers[router]) {
      throw errCode__default["default"](new Error(`Router unavailable. Configure libp2p.modules.pubsub to use the ${ router } router.`), 'ERR_NOT_SUPPORTED');
    }
    return libp2pPubsubRouters.routers[router];
  };
  const libp2pDefaults = {
    datastore,
    peerId: peerId,
    modules: {}
  };
  const libp2pOptions = {
    modules: {
      pubsub: getPubsubRouter(),
      contentRouting: [],
      peerRouting: []
    },
    config: {
      peerDiscovery: {
        mdns: { enabled: get__default["default"](options, 'config.Discovery.MDNS.Enabled', get__default["default"](config, 'Discovery.MDNS.Enabled', true)) },
        webRTCStar: { enabled: get__default["default"](options, 'config.Discovery.webRTCStar.Enabled', get__default["default"](config, 'Discovery.webRTCStar.Enabled', true)) },
        bootstrap: { list: get__default["default"](options, 'config.Bootstrap', get__default["default"](config, 'Bootstrap', [])) }
      },
      relay: {
        enabled: get__default["default"](options, 'relay.enabled', get__default["default"](config, 'relay.enabled', true)),
        hop: {
          enabled: get__default["default"](options, 'relay.hop.enabled', get__default["default"](config, 'relay.hop.enabled', false)),
          active: get__default["default"](options, 'relay.hop.active', get__default["default"](config, 'relay.hop.active', false))
        }
      },
      dht: {
        enabled: get__default["default"](config, 'Routing.Type', 'none') !== 'none',
        clientMode: get__default["default"](config, 'Routing.Type', 'dht') !== 'dhtserver',
        kBucketSize: get__default["default"](options, 'dht.kBucketSize', 20),
        validators: { ipns: ipns__namespace.validator }
      },
      pubsub: { enabled: get__default["default"](options, 'config.Pubsub.Enabled', get__default["default"](config, 'Pubsub.Enabled', true)) },
      nat: { enabled: !get__default["default"](config, 'Swarm.DisableNatPortMap', false) }
    },
    addresses: {
      listen: multiaddrs.map(ma => ma.toString()),
      announce: get__default["default"](options, 'addresses.announce', get__default["default"](config, 'Addresses.Announce', [])),
      noAnnounce: get__default["default"](options, 'addresses.noAnnounce', get__default["default"](config, 'Addresses.NoAnnounce', []))
    },
    connectionManager: get__default["default"](options, 'connectionManager', {
      maxConnections: get__default["default"](options, 'config.Swarm.ConnMgr.HighWater', get__default["default"](config, 'Swarm.ConnMgr.HighWater')),
      minConnections: get__default["default"](options, 'config.Swarm.ConnMgr.LowWater', get__default["default"](config, 'Swarm.ConnMgr.LowWater'))
    }),
    keychain: {
      datastore: keys,
      ...keychainConfig
    },
    host: { agentVersion: `js-ipfs/${ version.ipfsCore }` }
  };
  let constructorOptions = get__default["default"](options, 'libp2p', undefined);
  if (typeof constructorOptions === 'function') {
    constructorOptions = undefined;
  }
  const libp2pConfig = mergeOptions(libp2pDefaults, libp2p.libp2pConfig(), libp2pOptions, constructorOptions);
  const bootstrapList = get__default["default"](libp2pConfig, 'config.peerDiscovery.bootstrap.list', []);
  if (bootstrapList.length > 0) {
    libp2pConfig.modules.peerDiscovery.push(bootstrap__default["default"]);
  }
  const delegateHosts = get__default["default"](options, 'config.Addresses.Delegates', get__default["default"](config, 'Addresses.Delegates', []));
  if (delegateHosts.length > 0) {
    const delegateString = delegateHosts[Math.floor(Math.random() * delegateHosts.length)];
    const delegateAddr = new multiaddr.Multiaddr(delegateString).toOptions();
    const delegateApiOptions = {
      host: delegateAddr.host,
      protocol: parseInt(delegateAddr.port) === 443 ? 'https' : 'http',
      port: delegateAddr.port
    };
    const delegateHttpClient = ipfsHttpClient.create(delegateApiOptions);
    libp2pOptions.modules.contentRouting = libp2pOptions.modules.contentRouting || [];
    libp2pOptions.modules.contentRouting.push(new DelegatedContentRouter__default["default"](peerId, delegateHttpClient));
    libp2pOptions.modules.peerRouting = libp2pOptions.modules.peerRouting || [];
    libp2pOptions.modules.peerRouting.push(new DelegatedPeerRouter__default["default"](delegateHttpClient));
  }
  return libp2pConfig;
}

exports.createLibp2p = createLibp2p;
