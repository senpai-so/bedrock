'use strict';

Object.defineProperty(exports, '__esModule', { value: true });

var createLock = require('./utils/create-lock.js');
var isIpfs = require('is-ipfs');
var stat = require('./stat.js');
var chmod = require('./chmod.js');
var cp = require('./cp.js');
var flush = require('./flush.js');
var mkdir = require('./mkdir.js');
var mv = require('./mv.js');
var rm = require('./rm.js');
var touch = require('./touch.js');
var read = require('./read.js');
var write = require('./write.js');
var ls = require('./ls.js');

function _interopDefaultLegacy (e) { return e && typeof e === 'object' && 'default' in e ? e : { 'default': e }; }

var isIpfs__default = /*#__PURE__*/_interopDefaultLegacy(isIpfs);

const readOperations = { stat: stat.createStat };
const writeOperations = {
  chmod: chmod.createChmod,
  cp: cp.createCp,
  flush: flush.createFlush,
  mkdir: mkdir.createMkdir,
  mv: mv.createMv,
  rm: rm.createRm,
  touch: touch.createTouch
};
const unwrappedOperations = {
  write: write.createWrite,
  read: read.createRead,
  ls: ls.createLs
};
const wrap = ({options, mfs, operations, lock}) => {
  Object.keys(operations).forEach(key => {
    mfs[key] = lock(operations[key](options));
  });
};
const defaultOptions = {
  repoOwner: true,
  repo: null
};
function createMfs(options) {
  const {repoOwner} = Object.assign({}, defaultOptions || {}, options);
  const lock = createLock.createLock(repoOwner);
  const readLock = operation => {
    return lock.readLock(operation);
  };
  const writeLock = operation => {
    return lock.writeLock(operation);
  };
  const mfs = {};
  wrap({
    options,
    mfs,
    operations: readOperations,
    lock: readLock
  });
  wrap({
    options,
    mfs,
    operations: writeOperations,
    lock: writeLock
  });
  Object.keys(unwrappedOperations).forEach(key => {
    mfs[key] = unwrappedOperations[key](options);
  });
  return mfs;
}
function createFiles({
  repo,
  preload,
  hashers,
  options: constructorOptions
}) {
  const methods = createMfs({
    repo,
    repoOwner: Boolean(constructorOptions.repoOwner),
    hashers
  });
  const withPreload = fn => {
    const wrapped = (...args) => {
      const paths = args.filter(arg => isIpfs__default["default"].ipfsPath(arg) || isIpfs__default["default"].cid(arg));
      if (paths.length) {
        const options = args[args.length - 1];
        if (options && options.preload !== false) {
          paths.forEach(path => preload(path));
        }
      }
      return fn(...args);
    };
    return wrapped;
  };
  return {
    ...methods,
    chmod: methods.chmod,
    cp: withPreload(methods.cp),
    mkdir: methods.mkdir,
    stat: withPreload(methods.stat),
    rm: methods.rm,
    read: withPreload(methods.read),
    touch: methods.touch,
    write: methods.write,
    mv: withPreload(methods.mv),
    flush: methods.flush,
    ls: withPreload(async function* (...args) {
      for await (const file of methods.ls(...args)) {
        yield {
          ...file,
          size: file.size || 0
        };
      }
    })
  };
}

exports.createFiles = createFiles;
