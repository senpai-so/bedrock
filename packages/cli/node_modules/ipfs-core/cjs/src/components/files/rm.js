'use strict';

Object.defineProperty(exports, '__esModule', { value: true });

var errCode = require('err-code');
var updateTree = require('./utils/update-tree.js');
var updateMfsRoot = require('./utils/update-mfs-root.js');
var removeLink = require('./utils/remove-link.js');
var toMfsPath = require('./utils/to-mfs-path.js');
var toTrail = require('./utils/to-trail.js');
var withTimeoutOption = require('ipfs-core-utils/with-timeout-option');
var mergeOpts = require('merge-options');

function _interopDefaultLegacy (e) { return e && typeof e === 'object' && 'default' in e ? e : { 'default': e }; }

var errCode__default = /*#__PURE__*/_interopDefaultLegacy(errCode);
var mergeOpts__default = /*#__PURE__*/_interopDefaultLegacy(mergeOpts);

const mergeOptions = mergeOpts__default["default"].bind({ ignoreUndefined: true });
const defaultOptions = {
  recursive: false,
  cidVersion: 0,
  hashAlg: 'sha2-256',
  flush: true,
  shardSplitThreshold: 1000
};
function createRm(context) {
  async function mfsRm(paths, opts = {}) {
    const options = mergeOptions(defaultOptions, opts);
    if (!Array.isArray(paths)) {
      paths = [paths];
    }
    const sources = await Promise.all(paths.map(path => toMfsPath.toMfsPath(context, path, options)));
    if (!sources.length) {
      throw errCode__default["default"](new Error('Please supply at least one path to remove'), 'ERR_INVALID_PARAMS');
    }
    sources.forEach(source => {
      if (source.path === '/') {
        throw errCode__default["default"](new Error('Cannot delete root'), 'ERR_INVALID_PARAMS');
      }
    });
    for (const source of sources) {
      await removePath(context, source.path, options);
    }
  }
  return withTimeoutOption.withTimeoutOption(mfsRm);
}
const removePath = async (context, path, options) => {
  const mfsPath = await toMfsPath.toMfsPath(context, path, options);
  const trail = await toTrail.toTrail(context, mfsPath.mfsPath);
  const child = trail[trail.length - 1];
  trail.pop();
  const parent = trail[trail.length - 1];
  if (!parent) {
    throw errCode__default["default"](new Error(`${ path } does not exist`), 'ERR_NOT_FOUND');
  }
  if (child.type === 'directory' && !options.recursive) {
    throw errCode__default["default"](new Error(`${ path } is a directory, use -r to remove directories`), 'ERR_WAS_DIR');
  }
  const {cid} = await removeLink.removeLink(context, {
    parentCid: parent.cid,
    name: child.name,
    hashAlg: options.hashAlg,
    cidVersion: options.cidVersion,
    flush: options.flush,
    shardSplitThreshold: options.shardSplitThreshold
  });
  parent.cid = cid;
  const newRootCid = await updateTree.updateTree(context, trail, options);
  await updateMfsRoot.updateMfsRoot(context, newRootCid, options);
};

exports.createRm = createRm;
