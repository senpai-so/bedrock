'use strict';

Object.defineProperty(exports, '__esModule', { value: true });

var mergeOpts = require('merge-options');
var toMfsPath = require('./utils/to-mfs-path.js');
var debug = require('debug');
var errCode = require('err-code');
var ipfsUnixfs = require('ipfs-unixfs');
var toTrail = require('./utils/to-trail.js');
var addLink = require('./utils/add-link.js');
var updateTree = require('./utils/update-tree.js');
var updateMfsRoot = require('./utils/update-mfs-root.js');
var dagPB = require('@ipld/dag-pb');
var cid = require('multiformats/cid');
var withTimeoutOption = require('ipfs-core-utils/with-timeout-option');

function _interopDefaultLegacy (e) { return e && typeof e === 'object' && 'default' in e ? e : { 'default': e }; }

function _interopNamespace(e) {
  if (e && e.__esModule) return e;
  var n = Object.create(null);
  if (e) {
    Object.keys(e).forEach(function (k) {
      if (k !== 'default') {
        var d = Object.getOwnPropertyDescriptor(e, k);
        Object.defineProperty(n, k, d.get ? d : {
          enumerable: true,
          get: function () { return e[k]; }
        });
      }
    });
  }
  n["default"] = e;
  return Object.freeze(n);
}

var mergeOpts__default = /*#__PURE__*/_interopDefaultLegacy(mergeOpts);
var debug__default = /*#__PURE__*/_interopDefaultLegacy(debug);
var errCode__default = /*#__PURE__*/_interopDefaultLegacy(errCode);
var dagPB__namespace = /*#__PURE__*/_interopNamespace(dagPB);

const mergeOptions = mergeOpts__default["default"].bind({ ignoreUndefined: true });
const log = debug__default["default"]('ipfs:mfs:touch');
const defaultOptions = {
  flush: true,
  shardSplitThreshold: 1000,
  cidVersion: 0,
  hashAlg: 'sha2-256'
};
function createTouch(context) {
  async function mfsTouch(path, options = {}) {
    const settings = mergeOptions(defaultOptions, options);
    settings.mtime = settings.mtime || new Date();
    log(`Touching ${ path } mtime: ${ settings.mtime }`);
    const {cid: cid$1, mfsDirectory, name, exists} = await toMfsPath.toMfsPath(context, path, settings);
    const hashAlg = options.hashAlg || defaultOptions.hashAlg;
    const hasher = await context.hashers.getHasher(hashAlg);
    let updatedBlock;
    let updatedCid;
    let cidVersion = settings.cidVersion;
    if (!exists) {
      const metadata = new ipfsUnixfs.UnixFS({
        type: 'file',
        mtime: settings.mtime
      });
      updatedBlock = dagPB__namespace.encode({
        Data: metadata.marshal(),
        Links: []
      });
      const hash = await hasher.digest(updatedBlock);
      updatedCid = cid.CID.create(settings.cidVersion, dagPB__namespace.code, hash);
      if (settings.flush) {
        await context.repo.blocks.put(updatedCid, updatedBlock);
      }
    } else {
      if (cid$1.code !== dagPB__namespace.code) {
        throw errCode__default["default"](new Error(`${ path } was not a UnixFS node`), 'ERR_NOT_UNIXFS');
      }
      cidVersion = cid$1.version;
      const block = await context.repo.blocks.get(cid$1);
      const node = dagPB__namespace.decode(block);
      if (!node.Data) {
        throw errCode__default["default"](new Error(`${ path } had no data`), 'ERR_INVALID_NODE');
      }
      const metadata = ipfsUnixfs.UnixFS.unmarshal(node.Data);
      metadata.mtime = settings.mtime;
      updatedBlock = dagPB__namespace.encode({
        Data: metadata.marshal(),
        Links: node.Links
      });
      const hash = await hasher.digest(updatedBlock);
      updatedCid = cid.CID.create(settings.cidVersion, dagPB__namespace.code, hash);
      if (settings.flush) {
        await context.repo.blocks.put(updatedCid, updatedBlock);
      }
    }
    const trail = await toTrail.toTrail(context, mfsDirectory);
    const parent = trail[trail.length - 1];
    const parentCid = parent.cid;
    const parentBlock = await context.repo.blocks.get(parentCid);
    const parentNode = dagPB__namespace.decode(parentBlock);
    const result = await addLink.addLink(context, {
      parent: parentNode,
      name: name,
      cid: updatedCid,
      size: updatedBlock.length,
      flush: settings.flush,
      shardSplitThreshold: settings.shardSplitThreshold,
      hashAlg: settings.hashAlg,
      cidVersion
    });
    parent.cid = result.cid;
    const newRootCid = await updateTree.updateTree(context, trail, settings);
    await updateMfsRoot.updateMfsRoot(context, newRootCid, settings);
  }
  return withTimeoutOption.withTimeoutOption(mfsTouch);
}

exports.createTouch = createTouch;
