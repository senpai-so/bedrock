'use strict';

Object.defineProperty(exports, '__esModule', { value: true });

var errCode = require('err-code');
var debug = require('debug');
var ipfsUnixfsExporter = require('ipfs-unixfs-exporter');
var createNode = require('./utils/create-node.js');
var toPathComponents = require('./utils/to-path-components.js');
var updateMfsRoot = require('./utils/update-mfs-root.js');
var updateTree = require('./utils/update-tree.js');
var addLink = require('./utils/add-link.js');
var withMfsRoot = require('./utils/with-mfs-root.js');
var mergeOpts = require('merge-options');
var withTimeoutOption = require('ipfs-core-utils/with-timeout-option');

function _interopDefaultLegacy (e) { return e && typeof e === 'object' && 'default' in e ? e : { 'default': e }; }

var errCode__default = /*#__PURE__*/_interopDefaultLegacy(errCode);
var debug__default = /*#__PURE__*/_interopDefaultLegacy(debug);
var mergeOpts__default = /*#__PURE__*/_interopDefaultLegacy(mergeOpts);

const mergeOptions = mergeOpts__default["default"].bind({ ignoreUndefined: true });
const log = debug__default["default"]('ipfs:mfs:mkdir');
const defaultOptions = {
  parents: false,
  hashAlg: 'sha2-256',
  cidVersion: 0,
  shardSplitThreshold: 1000,
  flush: true
};
function createMkdir(context) {
  async function mfsMkdir(path, options = {}) {
    const opts = mergeOptions(defaultOptions, options);
    if (!path) {
      throw new Error('no path given to Mkdir');
    }
    path = path.trim();
    if (path === '/') {
      if (opts.parents) {
        return;
      }
      throw errCode__default["default"](new Error('cannot create directory \'/\': Already exists'), 'ERR_INVALID_PATH');
    }
    if (path.substring(0, 1) !== '/') {
      throw errCode__default["default"](new Error('paths must start with a leading slash'), 'ERR_INVALID_PATH');
    }
    log(`Creating ${ path }`);
    const pathComponents = toPathComponents.toPathComponents(path);
    if (pathComponents[0] === 'ipfs') {
      throw errCode__default["default"](new Error('path cannot have the prefix \'ipfs\''), 'ERR_INVALID_PATH');
    }
    const root = await withMfsRoot.loadMfsRoot(context, opts);
    let parent;
    const trail = [];
    const emptyDir = await createNode.createNode(context, 'directory', opts);
    for (let i = 0; i <= pathComponents.length; i++) {
      const subPathComponents = pathComponents.slice(0, i);
      const subPath = `/ipfs/${ root }/${ subPathComponents.join('/') }`;
      try {
        parent = await ipfsUnixfsExporter.exporter(subPath, context.repo.blocks);
        if (parent.type !== 'file' && parent.type !== 'directory') {
          throw errCode__default["default"](new Error(`${ path } was not a UnixFS node`), 'ERR_NOT_UNIXFS');
        }
        if (i === pathComponents.length) {
          if (opts.parents) {
            return;
          }
          throw errCode__default["default"](new Error('file already exists'), 'ERR_ALREADY_EXISTS');
        }
        trail.push({
          name: parent.name,
          cid: parent.cid
        });
      } catch (err) {
        if (err.code === 'ERR_NOT_FOUND') {
          if (i < pathComponents.length && !opts.parents) {
            throw errCode__default["default"](new Error(`Intermediate directory path ${ subPath } does not exist, use the -p flag to create it`), 'ERR_NOT_FOUND');
          }
          await addEmptyDir(context, subPathComponents[subPathComponents.length - 1], emptyDir, trail[trail.length - 1], trail, opts);
        } else {
          throw err;
        }
      }
    }
    const newRootCid = await updateTree.updateTree(context, trail, opts);
    await updateMfsRoot.updateMfsRoot(context, newRootCid, opts);
  }
  return withTimeoutOption.withTimeoutOption(mfsMkdir);
}
const addEmptyDir = async (context, childName, emptyDir, parent, trail, options) => {
  log(`Adding empty dir called ${ childName } to ${ parent.cid }`);
  const result = await addLink.addLink(context, {
    parent: parent.node,
    parentCid: parent.cid,
    size: 0,
    cid: emptyDir.cid,
    name: childName,
    hashAlg: options.hashAlg,
    cidVersion: options.cidVersion,
    flush: options.flush,
    shardSplitThreshold: options.shardSplitThreshold
  });
  trail[trail.length - 1].cid = result.cid;
  trail.push({
    name: childName,
    cid: emptyDir.cid
  });
};

exports.createMkdir = createMkdir;
