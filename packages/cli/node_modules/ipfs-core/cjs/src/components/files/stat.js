'use strict';

Object.defineProperty(exports, '__esModule', { value: true });

var mergeOpts = require('merge-options');
var toMfsPath = require('./utils/to-mfs-path.js');
var ipfsUnixfsExporter = require('ipfs-unixfs-exporter');
var debug = require('debug');
var errCode = require('err-code');
var withTimeoutOption = require('ipfs-core-utils/with-timeout-option');
var dagPB = require('@ipld/dag-pb');

function _interopDefaultLegacy (e) { return e && typeof e === 'object' && 'default' in e ? e : { 'default': e }; }

function _interopNamespace(e) {
  if (e && e.__esModule) return e;
  var n = Object.create(null);
  if (e) {
    Object.keys(e).forEach(function (k) {
      if (k !== 'default') {
        var d = Object.getOwnPropertyDescriptor(e, k);
        Object.defineProperty(n, k, d.get ? d : {
          enumerable: true,
          get: function () { return e[k]; }
        });
      }
    });
  }
  n["default"] = e;
  return Object.freeze(n);
}

var mergeOpts__default = /*#__PURE__*/_interopDefaultLegacy(mergeOpts);
var debug__default = /*#__PURE__*/_interopDefaultLegacy(debug);
var errCode__default = /*#__PURE__*/_interopDefaultLegacy(errCode);
var dagPB__namespace = /*#__PURE__*/_interopNamespace(dagPB);

const mergeOptions = mergeOpts__default["default"].bind({ ignoreUndefined: true });
const log = debug__default["default"]('ipfs:mfs:stat');
const defaultOptions = { withLocal: false };
function createStat(context) {
  async function mfsStat(path, options = {}) {
    options = mergeOptions(defaultOptions, options);
    log(`Fetching stats for ${ path }`);
    const {type, cid, mfsPath} = await toMfsPath.toMfsPath(context, path, options);
    const exportPath = type === 'ipfs' && cid ? cid : mfsPath;
    let file;
    try {
      file = await ipfsUnixfsExporter.exporter(exportPath, context.repo.blocks);
    } catch (err) {
      if (err.code === 'ERR_NOT_FOUND') {
        throw errCode__default["default"](new Error(`${ path } does not exist`), 'ERR_NOT_FOUND');
      }
      throw err;
    }
    if (!statters[file.type]) {
      throw new Error(`Cannot stat codec ${ file.cid.code }`);
    }
    return statters[file.type](file);
  }
  return withTimeoutOption.withTimeoutOption(mfsStat);
}
const statters = {
  raw: file => {
    return {
      cid: file.cid,
      size: file.node.length,
      cumulativeSize: file.node.length,
      blocks: 0,
      type: 'file',
      local: undefined,
      sizeLocal: undefined,
      withLocality: false
    };
  },
  file: file => {
    const stat = {
      cid: file.cid,
      type: 'file',
      size: file.unixfs.fileSize(),
      cumulativeSize: dagPB__namespace.encode(file.node).length + (file.node.Links || []).reduce((acc, curr) => acc + (curr.Tsize || 0), 0),
      blocks: file.unixfs.blockSizes.length,
      local: undefined,
      sizeLocal: undefined,
      withLocality: false,
      mode: file.unixfs.mode
    };
    if (file.unixfs.mtime) {
      stat.mtime = file.unixfs.mtime;
    }
    return stat;
  },
  directory: file => {
    const stat = {
      cid: file.cid,
      type: 'directory',
      size: 0,
      cumulativeSize: dagPB__namespace.encode(file.node).length + (file.node.Links || []).reduce((acc, curr) => acc + (curr.Tsize || 0), 0),
      blocks: file.node.Links.length,
      local: undefined,
      sizeLocal: undefined,
      withLocality: false,
      mode: file.unixfs.mode
    };
    if (file.unixfs.mtime) {
      stat.mtime = file.unixfs.mtime;
    }
    return stat;
  },
  object: file => {
    return {
      cid: file.cid,
      size: file.node.length,
      cumulativeSize: file.node.length,
      type: 'file',
      blocks: 0,
      local: undefined,
      sizeLocal: undefined,
      withLocality: false
    };
  },
  identity: file => {
    return {
      cid: file.cid,
      size: file.node.length,
      cumulativeSize: file.node.length,
      blocks: 0,
      type: 'file',
      local: undefined,
      sizeLocal: undefined,
      withLocality: false
    };
  }
};

exports.createStat = createStat;
