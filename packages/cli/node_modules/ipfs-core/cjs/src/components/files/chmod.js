'use strict';

Object.defineProperty(exports, '__esModule', { value: true });

var mergeOpts = require('merge-options');
var toMfsPath = require('./utils/to-mfs-path.js');
var debug = require('debug');
var errCode = require('err-code');
var ipfsUnixfs = require('ipfs-unixfs');
var toTrail = require('./utils/to-trail.js');
var addLink = require('./utils/add-link.js');
var updateTree = require('./utils/update-tree.js');
var updateMfsRoot = require('./utils/update-mfs-root.js');
var dagPB = require('@ipld/dag-pb');
var cid = require('multiformats/cid');
var itPipe = require('it-pipe');
var ipfsUnixfsImporter = require('ipfs-unixfs-importer');
var ipfsUnixfsExporter = require('ipfs-unixfs-exporter');
var last = require('it-last');
var cp = require('./cp.js');
var rm = require('./rm.js');
var persist = require('./utils/persist.js');
var withTimeoutOption = require('ipfs-core-utils/with-timeout-option');

function _interopDefaultLegacy (e) { return e && typeof e === 'object' && 'default' in e ? e : { 'default': e }; }

function _interopNamespace(e) {
  if (e && e.__esModule) return e;
  var n = Object.create(null);
  if (e) {
    Object.keys(e).forEach(function (k) {
      if (k !== 'default') {
        var d = Object.getOwnPropertyDescriptor(e, k);
        Object.defineProperty(n, k, d.get ? d : {
          enumerable: true,
          get: function () { return e[k]; }
        });
      }
    });
  }
  n["default"] = e;
  return Object.freeze(n);
}

var mergeOpts__default = /*#__PURE__*/_interopDefaultLegacy(mergeOpts);
var debug__default = /*#__PURE__*/_interopDefaultLegacy(debug);
var errCode__default = /*#__PURE__*/_interopDefaultLegacy(errCode);
var dagPB__namespace = /*#__PURE__*/_interopNamespace(dagPB);
var last__default = /*#__PURE__*/_interopDefaultLegacy(last);

const mergeOptions = mergeOpts__default["default"].bind({ ignoreUndefined: true });
const log = debug__default["default"]('ipfs:mfs:touch');
const defaultOptions = {
  flush: true,
  shardSplitThreshold: 1000,
  hashAlg: 'sha2-256',
  cidVersion: 0,
  recursive: false
};
function calculateModification(mode, originalMode, isDirectory) {
  let modification = 0;
  if (mode.includes('x') || mode.includes('X') && (isDirectory || (originalMode & 1 || originalMode & 8 || originalMode & 64))) {
    modification += 1;
  }
  if (mode.includes('w')) {
    modification += 2;
  }
  if (mode.includes('r')) {
    modification += 4;
  }
  return modification;
}
function calculateUGO(references, modification) {
  let ugo = 0;
  if (references.includes('u')) {
    ugo += modification << 6;
  }
  if (references.includes('g')) {
    ugo += modification << 3;
  }
  if (references.includes('o')) {
    ugo += modification;
  }
  return ugo;
}
function calculateSpecial(references, mode, modification) {
  if (mode.includes('t')) {
    modification += parseInt('1000', 8);
  }
  if (mode.includes('s')) {
    if (references.includes('u')) {
      modification += parseInt('4000', 8);
    }
    if (references.includes('g')) {
      modification += parseInt('2000', 8);
    }
  }
  return modification;
}
function parseSymbolicMode(input, originalMode, isDirectory) {
  if (!originalMode) {
    originalMode = 0;
  }
  const match = input.match(/^(u?g?o?a?)(-?\+?=?)?(r?w?x?X?s?t?)$/);
  if (!match) {
    throw new Error(`Invalid file mode: ${ input }`);
  }
  let [, references, operator, mode] = match;
  if (references === 'a' || !references) {
    references = 'ugo';
  }
  let modification = calculateModification(mode, originalMode, isDirectory);
  modification = calculateUGO(references, modification);
  modification = calculateSpecial(references, mode, modification);
  if (operator === '=') {
    if (references.includes('u')) {
      originalMode = originalMode & parseInt('7077', 8);
      originalMode = originalMode | modification;
    }
    if (references.includes('g')) {
      originalMode = originalMode & parseInt('7707', 8);
      originalMode = originalMode | modification;
    }
    if (references.includes('o')) {
      originalMode = originalMode & parseInt('7770', 8);
      originalMode = originalMode | modification;
    }
    return originalMode;
  }
  if (operator === '+') {
    return modification | originalMode;
  }
  if (operator === '-') {
    return modification ^ originalMode;
  }
  return originalMode;
}
function calculateMode(mode, metadata) {
  if (mode instanceof String || typeof mode === 'string') {
    const strMode = `${ mode }`;
    if (strMode.match(/^\d+$/g)) {
      mode = parseInt(strMode, 8);
    } else {
      mode = 0 + strMode.split(',').reduce((curr, acc) => {
        return parseSymbolicMode(acc, curr, metadata.isDirectory());
      }, metadata.mode || 0);
    }
  }
  return mode;
}
function createChmod(context) {
  async function mfsChmod(path, mode, options = {}) {
    const opts = mergeOptions(defaultOptions, options);
    log(`Fetching stats for ${ path }`);
    const {cid: cid$1, mfsDirectory, name} = await toMfsPath.toMfsPath(context, path, opts);
    if (cid$1.code !== dagPB__namespace.code) {
      throw errCode__default["default"](new Error(`${ path } was not a UnixFS node`), 'ERR_NOT_UNIXFS');
    }
    if (opts.recursive) {
      const root = await itPipe.pipe(async function* () {
        for await (const entry of ipfsUnixfsExporter.recursive(cid$1, context.repo.blocks)) {
          if (entry.type !== 'file' && entry.type !== 'directory') {
            throw errCode__default["default"](new Error(`${ path } was not a UnixFS node`), 'ERR_NOT_UNIXFS');
          }
          entry.unixfs.mode = calculateMode(mode, entry.unixfs);
          const node = dagPB__namespace.prepare({
            Data: entry.unixfs.marshal(),
            Links: entry.node.Links
          });
          yield {
            path: entry.path,
            content: node
          };
        }
      }, source => ipfsUnixfsImporter.importer(source, context.repo.blocks, {
        ...opts,
        pin: false,
        dagBuilder: async function* (source, block, opts) {
          for await (const entry of source) {
            yield async function () {
              const node = entry.content;
              const buf = dagPB__namespace.encode(node);
              const cid = await persist.persist(buf, block, opts);
              if (!node.Data) {
                throw errCode__default["default"](new Error(`${ cid } had no data`), 'ERR_INVALID_NODE');
              }
              const unixfs = ipfsUnixfs.UnixFS.unmarshal(node.Data);
              return {
                cid,
                size: buf.length,
                path: entry.path,
                unixfs
              };
            };
          }
        }
      }), nodes => last__default["default"](nodes));
      if (!root) {
        throw errCode__default["default"](new Error(`Could not chmod ${ path }`), 'ERR_COULD_NOT_CHMOD');
      }
      await rm.createRm(context)(path, opts);
      await cp.createCp(context)(`/ipfs/${ root.cid }`, path, opts);
      return;
    }
    const block = await context.repo.blocks.get(cid$1);
    const node = dagPB__namespace.decode(block);
    if (!node.Data) {
      throw errCode__default["default"](new Error(`${ cid$1 } had no data`), 'ERR_INVALID_NODE');
    }
    const metadata = ipfsUnixfs.UnixFS.unmarshal(node.Data);
    metadata.mode = calculateMode(mode, metadata);
    const updatedBlock = dagPB__namespace.encode({
      Data: metadata.marshal(),
      Links: node.Links
    });
    const hashAlg = opts.hashAlg || defaultOptions.hashAlg;
    const hasher = await context.hashers.getHasher(hashAlg);
    const hash = await hasher.digest(updatedBlock);
    const updatedCid = cid.CID.create(opts.cidVersion, dagPB__namespace.code, hash);
    if (opts.flush) {
      await context.repo.blocks.put(updatedCid, updatedBlock);
    }
    const trail = await toTrail.toTrail(context, mfsDirectory);
    const parent = trail[trail.length - 1];
    const parentCid = cid.CID.decode(parent.cid.bytes);
    const parentBlock = await context.repo.blocks.get(parentCid);
    const parentNode = dagPB__namespace.decode(parentBlock);
    const result = await addLink.addLink(context, {
      parent: parentNode,
      name: name,
      cid: updatedCid,
      size: updatedBlock.length,
      flush: opts.flush,
      hashAlg,
      cidVersion: cid$1.version,
      shardSplitThreshold: Infinity
    });
    parent.cid = result.cid;
    const newRootCid = await updateTree.updateTree(context, trail, opts);
    await updateMfsRoot.updateMfsRoot(context, newRootCid, opts);
  }
  return withTimeoutOption.withTimeoutOption(mfsChmod);
}

exports.createChmod = createChmod;
