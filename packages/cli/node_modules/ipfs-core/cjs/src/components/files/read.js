'use strict';

Object.defineProperty(exports, '__esModule', { value: true });

var ipfsUnixfsExporter = require('ipfs-unixfs-exporter');
var mergeOpts = require('merge-options');
var toMfsPath = require('./utils/to-mfs-path.js');
var errCode = require('err-code');
var withTimeoutOption = require('ipfs-core-utils/with-timeout-option');

function _interopDefaultLegacy (e) { return e && typeof e === 'object' && 'default' in e ? e : { 'default': e }; }

var mergeOpts__default = /*#__PURE__*/_interopDefaultLegacy(mergeOpts);
var errCode__default = /*#__PURE__*/_interopDefaultLegacy(errCode);

const mergeOptions = mergeOpts__default["default"].bind({ ignoreUndefined: true });
const defaultOptions = {
  offset: 0,
  length: Infinity
};
function createRead(context) {
  function mfsRead(path, options = {}) {
    options = mergeOptions(defaultOptions, options);
    return {
      [Symbol.asyncIterator]: async function* read() {
        const mfsPath = await toMfsPath.toMfsPath(context, path, options);
        const result = await ipfsUnixfsExporter.exporter(mfsPath.mfsPath, context.repo.blocks);
        if (result.type !== 'file') {
          throw errCode__default["default"](new Error(`${ path } was not a file`), 'ERR_NOT_FILE');
        }
        if (!result.content) {
          throw errCode__default["default"](new Error(`Could not load content stream from ${ path }`), 'ERR_NO_CONTENT');
        }
        for await (const buf of result.content({
            offset: options.offset,
            length: options.length
          })) {
          yield buf;
        }
      }
    };
  }
  return withTimeoutOption.withTimeoutOption(mfsRead);
}

exports.createRead = createRead;
