'use strict';

Object.defineProperty(exports, '__esModule', { value: true });

var withMfsRoot = require('./with-mfs-root.js');
var toPathComponents = require('./to-path-components.js');
var ipfsUnixfsExporter = require('ipfs-unixfs-exporter');
var errCode = require('err-code');
var cid = require('multiformats/cid');

function _interopDefaultLegacy (e) { return e && typeof e === 'object' && 'default' in e ? e : { 'default': e }; }

var errCode__default = /*#__PURE__*/_interopDefaultLegacy(errCode);

const IPFS_PREFIX = 'ipfs';
const toMfsPath = async (context, path, options) => {
  const root = await withMfsRoot.loadMfsRoot(context, options);
  let output = { entryType: 'file' };
  let ipfsPath = '';
  if (cid.CID.asCID(path)) {
    ipfsPath = `/ipfs/${ path }`;
  } else {
    ipfsPath = path.toString();
  }
  ipfsPath = ipfsPath.trim();
  ipfsPath = ipfsPath.replace(/(\/\/+)/g, '/');
  if (ipfsPath.endsWith('/') && ipfsPath.length > 1) {
    ipfsPath = ipfsPath.substring(0, ipfsPath.length - 1);
  }
  if (!ipfsPath) {
    throw errCode__default["default"](new Error('paths must not be empty'), 'ERR_NO_PATH');
  }
  if (ipfsPath.substring(0, 1) !== '/') {
    throw errCode__default["default"](new Error('paths must start with a leading slash'), 'ERR_INVALID_PATH');
  }
  if (ipfsPath.substring(ipfsPath.length - 1) === '/') {
    ipfsPath = ipfsPath.substring(0, ipfsPath.length - 1);
  }
  const pathComponents = toPathComponents.toPathComponents(ipfsPath);
  if (pathComponents[0] === IPFS_PREFIX) {
    let mfsDirectory;
    if (pathComponents.length === 2) {
      mfsDirectory = `/${ pathComponents.join('/') }`;
    } else {
      mfsDirectory = `/${ pathComponents.slice(0, pathComponents.length - 1).join('/') }`;
    }
    output = {
      type: 'ipfs',
      depth: pathComponents.length - 2,
      entryType: 'file',
      mfsPath: `/${ pathComponents.join('/') }`,
      mfsDirectory,
      parts: pathComponents,
      path: `/${ pathComponents.join('/') }`,
      name: pathComponents[pathComponents.length - 1]
    };
  } else {
    const mfsPath = `/${ IPFS_PREFIX }/${ root }${ pathComponents.length ? '/' + pathComponents.join('/') : '' }`;
    const mfsDirectory = `/${ IPFS_PREFIX }/${ root }/${ pathComponents.slice(0, pathComponents.length - 1).join('/') }`;
    output = {
      type: 'mfs',
      depth: pathComponents.length,
      entryType: 'file',
      mfsDirectory,
      mfsPath,
      parts: pathComponents,
      path: `/${ pathComponents.join('/') }`,
      name: pathComponents[pathComponents.length - 1]
    };
  }
  const cidPath = output.type === 'mfs' ? output.mfsPath : output.path;
  try {
    const res = await ipfsUnixfsExporter.exporter(cidPath, context.repo.blocks, options);
    output.cid = res.cid;
    output.mfsPath = `/ipfs/${ res.path }`;
    output.entryType = res.type;
    output.content = res.content;
    if ((output.entryType === 'file' || output.entryType === 'directory') && (res.type === 'file' || res.type === 'directory')) {
      output.unixfs = res.unixfs;
    }
  } catch (err) {
    if (err.code !== 'ERR_NOT_FOUND') {
      throw err;
    }
  }
  output.exists = Boolean(output.cid);
  return output;
};

exports.toMfsPath = toMfsPath;
