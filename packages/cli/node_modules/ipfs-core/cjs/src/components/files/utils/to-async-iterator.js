'use strict';

Object.defineProperty(exports, '__esModule', { value: true });

var errCode = require('err-code');
var debug = require('debug');
var utils = require('../../../utils.js');
var fromString = require('uint8arrays/from-string');

function _interopDefaultLegacy (e) { return e && typeof e === 'object' && 'default' in e ? e : { 'default': e }; }

var errCode__default = /*#__PURE__*/_interopDefaultLegacy(errCode);
var debug__default = /*#__PURE__*/_interopDefaultLegacy(debug);

const log = debug__default["default"]('ipfs:mfs:utils:to-async-iterator');
function toAsyncIterator(content) {
  if (!content) {
    throw errCode__default["default"](new Error('paths must start with a leading slash'), 'ERR_INVALID_PATH');
  }
  if (typeof content === 'string' || content instanceof String) {
    log('Content was a string');
    content = fromString.fromString(content.toString());
  }
  if (content.length) {
    log('Content was array-like');
    return {
      [Symbol.asyncIterator]: function* bufferContent() {
        yield content;
      }
    };
  }
  if (content[Symbol.asyncIterator]) {
    log('Content was an async iterator');
    return content;
  }
  if (content[Symbol.iterator]) {
    log('Content was an iterator');
    return content;
  }
  if (global.Blob && content instanceof global.Blob) {
    log('Content was an HTML5 Blob');
    let index = 0;
    const iterator = {
      next: () => {
        if (index > content.size) {
          return { done: true };
        }
        return new Promise((resolve, reject) => {
          const chunk = content.slice(index, utils.MFS_MAX_CHUNK_SIZE);
          index += utils.MFS_MAX_CHUNK_SIZE;
          const reader = new global.FileReader();
          const handleLoad = ev => {
            reader.removeEventListener('loadend', handleLoad, false);
            if (ev.error) {
              return reject(ev.error);
            }
            resolve({
              done: false,
              value: new Uint8Array(reader.result)
            });
          };
          reader.addEventListener('loadend', handleLoad);
          reader.readAsArrayBuffer(chunk);
        });
      }
    };
    return {
      [Symbol.asyncIterator]: () => {
        return iterator;
      }
    };
  }
  throw errCode__default["default"](new Error(`Don't know how to convert ${ content } into an async iterator`), 'ERR_INVALID_PARAMS');
}

exports.toAsyncIterator = toAsyncIterator;
