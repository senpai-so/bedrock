'use strict';

Object.defineProperty(exports, '__esModule', { value: true });

var mkdir = require('./mkdir.js');
var stat = require('./stat.js');
var debug = require('debug');
var errCode = require('err-code');
var updateTree = require('./utils/update-tree.js');
var updateMfsRoot = require('./utils/update-mfs-root.js');
var addLink = require('./utils/add-link.js');
var toMfsPath = require('./utils/to-mfs-path.js');
var mergeOpts = require('merge-options');
var toTrail = require('./utils/to-trail.js');
var withTimeoutOption = require('ipfs-core-utils/with-timeout-option');

function _interopDefaultLegacy (e) { return e && typeof e === 'object' && 'default' in e ? e : { 'default': e }; }

var debug__default = /*#__PURE__*/_interopDefaultLegacy(debug);
var errCode__default = /*#__PURE__*/_interopDefaultLegacy(errCode);
var mergeOpts__default = /*#__PURE__*/_interopDefaultLegacy(mergeOpts);

const mergeOptions = mergeOpts__default["default"].bind({ ignoreUndefined: true });
const log = debug__default["default"]('ipfs:mfs:cp');
const defaultOptions = {
  parents: false,
  flush: true,
  hashAlg: 'sha2-256',
  cidVersion: 0,
  shardSplitThreshold: 1000
};
function createCp(context) {
  async function mfsCp(from, to, opts = {}) {
    const options = mergeOptions(defaultOptions, opts);
    if (!Array.isArray(from)) {
      from = [from];
    }
    const sources = await Promise.all(from.map(path => toMfsPath.toMfsPath(context, path, options)));
    let destination = await toMfsPath.toMfsPath(context, to, options);
    if (!sources.length || !destination) {
      throw errCode__default["default"](new Error('Please supply at least one source'), 'ERR_INVALID_PARAMS');
    }
    const missing = sources.find(source => !source.exists);
    if (missing) {
      throw errCode__default["default"](new Error(`${ missing.path } does not exist`), 'ERR_INVALID_PARAMS');
    }
    const destinationIsDirectory = isDirectory(destination);
    if (destination.exists) {
      log('Destination exists');
      if (sources.length === 1 && !destinationIsDirectory) {
        throw errCode__default["default"](new Error('directory already has entry by that name'), 'ERR_ALREADY_EXISTS');
      }
    } else {
      log('Destination does not exist');
      if (sources.length > 1) {
        if (!options.parents) {
          throw errCode__default["default"](new Error('destination did not exist, pass -p to create intermediate directories'), 'ERR_INVALID_PARAMS');
        }
        await mkdir.createMkdir(context)(destination.path, options);
        destination = await toMfsPath.toMfsPath(context, destination.path, options);
      } else if (destination.parts.length > 1) {
        const parentFolder = `/${ destination.parts.slice(0, -1).join('/') }`;
        try {
          await stat.createStat(context)(parentFolder, options);
        } catch (err) {
          if (err.code !== 'ERR_NOT_FOUND') {
            throw err;
          }
          if (!options.parents) {
            throw errCode__default["default"](new Error('destination did not exist, pass -p to create intermediate directories'), 'ERR_INVALID_PARAMS');
          }
          await mkdir.createMkdir(context)(parentFolder, options);
          destination = await toMfsPath.toMfsPath(context, destination.path, options);
        }
      }
    }
    const destinationPath = isDirectory(destination) ? destination.mfsPath : destination.mfsDirectory;
    const trail = await toTrail.toTrail(context, destinationPath);
    if (sources.length === 1) {
      const source = sources.pop();
      if (!source) {
        throw errCode__default["default"](new Error('could not find source'), 'ERR_INVALID_PARAMS');
      }
      const destinationName = destinationIsDirectory ? source.name : destination.name;
      log(`Only one source, copying to destination ${ destinationIsDirectory ? 'directory' : 'file' } ${ destinationName }`);
      return copyToFile(context, source, destinationName, trail, options);
    }
    log('Multiple sources, wrapping in a directory');
    return copyToDirectory(context, sources, destination, trail, options);
  }
  return withTimeoutOption.withTimeoutOption(mfsCp);
}
const isDirectory = destination => {
  return destination.unixfs && destination.unixfs.type && destination.unixfs.type.includes('directory');
};
const copyToFile = async (context, source, destination, destinationTrail, options) => {
  let parent = destinationTrail.pop();
  if (!parent) {
    throw errCode__default["default"](new Error('destination had no parent'), 'ERR_INVALID_PARAMS');
  }
  parent = await addSourceToParent(context, source, destination, parent, options);
  destinationTrail.push(parent);
  const newRootCid = await updateTree.updateTree(context, destinationTrail, options);
  await updateMfsRoot.updateMfsRoot(context, newRootCid, options);
};
const copyToDirectory = async (context, sources, destination, destinationTrail, options) => {
  for (let i = 0; i < sources.length; i++) {
    const source = sources[i];
    destination = await addSourceToParent(context, source, source.name, destination, options);
  }
  destinationTrail[destinationTrail.length - 1] = destination;
  const newRootCid = await updateTree.updateTree(context, destinationTrail, options);
  await updateMfsRoot.updateMfsRoot(context, newRootCid, options);
};
const addSourceToParent = async (context, source, childName, parent, options) => {
  const sourceBlock = await context.repo.blocks.get(source.cid);
  const {node, cid, size} = await addLink.addLink(context, {
    parentCid: parent.cid,
    size: sourceBlock.length,
    cid: source.cid,
    name: childName,
    hashAlg: options.hashAlg,
    cidVersion: options.cidVersion,
    flush: options.flush,
    shardSplitThreshold: options.shardSplitThreshold
  });
  parent.node = node;
  parent.cid = cid;
  parent.size = size;
  return parent;
};

exports.createCp = createCp;
