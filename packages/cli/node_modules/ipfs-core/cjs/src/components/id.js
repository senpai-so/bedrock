'use strict';

Object.defineProperty(exports, '__esModule', { value: true });

var version = require('../version.js');
var multiaddr = require('multiaddr');
var withTimeoutOption = require('ipfs-core-utils/with-timeout-option');
var toString = require('uint8arrays/to-string');
var PeerId = require('peer-id');
var errors = require('../errors.js');
var errCode = require('err-code');

function _interopDefaultLegacy (e) { return e && typeof e === 'object' && 'default' in e ? e : { 'default': e }; }

var PeerId__default = /*#__PURE__*/_interopDefaultLegacy(PeerId);
var errCode__default = /*#__PURE__*/_interopDefaultLegacy(errCode);

function createId({peerId, network}) {
  async function id(options = {}) {
    const net = network.try();
    if (!net) {
      if (options.peerId) {
        throw new errors.NotStartedError();
      }
      const idStr = peerId.toB58String();
      return {
        id: idStr,
        publicKey: toString.toString(peerId.pubKey.bytes, 'base64pad'),
        addresses: [],
        agentVersion: `js-ipfs/${ version.ipfsCore }`,
        protocolVersion: '9000',
        protocols: []
      };
    }
    const {libp2p} = net;
    const peerIdToId = options.peerId ? PeerId__default["default"].parse(options.peerId) : peerId;
    const peer = await findPeer(peerIdToId, libp2p, options);
    const agentVersion = toString.toString(peer.metadata.get('AgentVersion') || new Uint8Array());
    const protocolVersion = toString.toString(peer.metadata.get('ProtocolVersion') || new Uint8Array());
    const idStr = peer.id.toB58String();
    return {
      id: idStr,
      publicKey: toString.toString(peer.publicKey.bytes, 'base64pad'),
      addresses: (peer.addresses || []).map(ma => {
        const str = ma.toString();
        if (str.endsWith(`/p2p/${ idStr }`)) {
          return str;
        }
        return `${ str }/p2p/${ idStr }`;
      }).sort().map(ma => new multiaddr.Multiaddr(ma)),
      agentVersion,
      protocolVersion,
      protocols: (peer.protocols || []).sort()
    };
  }
  return withTimeoutOption.withTimeoutOption(id);
}
async function findPeer(peerId, libp2p, options) {
  let peer = libp2p.peerStore.get(peerId);
  if (!peer) {
    peer = await findPeerOnDht(peerId, libp2p, options);
  }
  let publicKey = peerId.pubKey ? peerId.pubKey : libp2p.peerStore.keyBook.get(peerId);
  if (!publicKey) {
    publicKey = await libp2p._dht.getPublicKey(peerId, options);
  }
  return {
    ...peer,
    publicKey,
    metadata: peer.metadata || new Map(),
    addresses: peer.addresses.map(addr => addr.multiaddr)
  };
}
async function findPeerOnDht(peerId, libp2p, options) {
  for await (const event of libp2p._dht.findPeer(peerId, options)) {
    if (event.name === 'FINAL_PEER') {
      break;
    }
  }
  const peer = libp2p.peerStore.get(peerId);
  if (!peer) {
    throw errCode__default["default"](new Error('Could not find peer'), 'ERR_NOT_FOUND');
  }
  return peer;
}

exports.createId = createId;
