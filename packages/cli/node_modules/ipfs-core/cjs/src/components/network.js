'use strict';

Object.defineProperty(exports, '__esModule', { value: true });

var ipfsBitswap = require('ipfs-bitswap');
var libp2p = require('./libp2p.js');
var multiaddr = require('multiaddr');
var errCode = require('err-code');
var blockStorage = require('../block-storage.js');

function _interopDefaultLegacy (e) { return e && typeof e === 'object' && 'default' in e ? e : { 'default': e }; }

var errCode__default = /*#__PURE__*/_interopDefaultLegacy(errCode);

class Network {
  constructor(peerId, libp2p, bitswap, repo, blockstore) {
    this.peerId = peerId;
    this.libp2p = libp2p;
    this.bitswap = bitswap;
    this.repo = repo;
    this.blockstore = blockstore;
  }
  static async start({peerId, repo, print, hashers, options}) {
    if (repo.closed) {
      await repo.open();
    }
    const config = await repo.config.getAll();
    const libp2p$1 = await libp2p.createLibp2p({
      options,
      repo,
      peerId,
      multiaddrs: readAddrs(peerId, config),
      config,
      keychainConfig: undefined
    });
    if (libp2p$1.keychain) {
      await libp2p$1.loadKeychain();
    }
    await libp2p$1.start();
    for (const ma of libp2p$1.multiaddrs) {
      print(`Swarm listening on ${ ma }/p2p/${ peerId.toB58String() }`);
    }
    const bitswap = ipfsBitswap.createBitswap(libp2p$1, repo.blocks, {
      statsEnabled: true,
      hashLoader: hashers
    });
    await bitswap.start();
    const blockstore = new blockStorage.BlockStorage(repo.blocks, bitswap);
    repo.blocks = blockstore;
    repo.pins.blockstore = blockstore;
    return new Network(peerId, libp2p$1, bitswap, repo, blockstore);
  }
  static async stop(network) {
    network.repo.blocks = network.blockstore.unwrap();
    network.repo.pins.blockstore = network.blockstore.unwrap();
    await Promise.all([
      network.bitswap.stop(),
      network.libp2p.stop()
    ]);
  }
}
const readAddrs = (peerId, config) => {
  const peerIdStr = peerId.toB58String();
  const addrs = [];
  const swarm = config.Addresses && config.Addresses.Swarm || [];
  for (const addr of swarm) {
    let ma = new multiaddr.Multiaddr(addr);
    if (ma.protoCodes().includes(WEBSOCKET_STAR_PROTO_CODE)) {
      throw errCode__default["default"](new Error('websocket-star swarm addresses are not supported. See https://github.com/ipfs/js-ipfs/issues/2779'), 'ERR_WEBSOCKET_STAR_SWARM_ADDR_NOT_SUPPORTED');
    }
    const maId = ma.getPeerId();
    if (maId && maId !== peerIdStr) {
      ma = ma.encapsulate(`/p2p/${ peerIdStr }`);
    }
    addrs.push(ma);
  }
  return addrs;
};
const WEBSOCKET_STAR_PROTO_CODE = 479;

exports.Network = Network;
