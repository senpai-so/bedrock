'use strict';

Object.defineProperty(exports, '__esModule', { value: true });

var parseDuration = require('parse-duration');
var errCode = require('err-code');
var withTimeoutOption = require('ipfs-core-utils/with-timeout-option');
var PeerId = require('peer-id');

function _interopDefaultLegacy (e) { return e && typeof e === 'object' && 'default' in e ? e : { 'default': e }; }

var parseDuration__default = /*#__PURE__*/_interopDefaultLegacy(parseDuration);
var errCode__default = /*#__PURE__*/_interopDefaultLegacy(errCode);
var PeerId__default = /*#__PURE__*/_interopDefaultLegacy(PeerId);

function getBandwidthStats(libp2p, opts) {
  let stats;
  if (!libp2p.metrics) {
    stats = undefined;
  } else if (opts.peer) {
    stats = libp2p.metrics.forPeer(PeerId__default["default"].parse(opts.peer));
  } else if (opts.proto) {
    stats = libp2p.metrics.forProtocol(opts.proto);
  } else {
    stats = libp2p.metrics.global;
  }
  if (!stats) {
    return {
      totalIn: BigInt(0),
      totalOut: BigInt(0),
      rateIn: 0,
      rateOut: 0
    };
  }
  const {movingAverages, snapshot} = stats;
  return {
    totalIn: BigInt(snapshot.dataReceived.integerValue().toString()),
    totalOut: BigInt(snapshot.dataSent.integerValue().toString()),
    rateIn: movingAverages.dataReceived[60000].movingAverage() / 60,
    rateOut: movingAverages.dataSent[60000].movingAverage() / 60
  };
}
function createBw({network}) {
  const bw = async function* (options = {}) {
    const {libp2p} = await network.use(options);
    if (!options.poll) {
      yield getBandwidthStats(libp2p, options);
      return;
    }
    const interval = options.interval || 1000;
    let ms = -1;
    try {
      ms = typeof interval === 'string' ? parseDuration__default["default"](interval) || -1 : interval;
      if (!ms || ms < 0)
        throw new Error('invalid duration');
    } catch (err) {
      throw errCode__default["default"](err, 'ERR_INVALID_POLL_INTERVAL');
    }
    let timeoutId;
    try {
      while (true) {
        yield getBandwidthStats(libp2p, options);
        await new Promise(resolve => {
          timeoutId = setTimeout(resolve, ms);
        });
      }
    } finally {
      clearTimeout(timeoutId);
    }
  };
  return withTimeoutOption.withTimeoutOption(bw);
}

exports.createBw = createBw;
