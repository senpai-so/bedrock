'use strict';

Object.defineProperty(exports, '__esModule', { value: true });

var toUri = require('multiaddr-to-uri');
var debug = require('debug');
var shuffle = require('array-shuffle');
var nativeAbortController = require('native-abort-controller');
var preload = require('ipfs-core-config/preload');
var hashlru = require('hashlru');

function _interopDefaultLegacy (e) { return e && typeof e === 'object' && 'default' in e ? e : { 'default': e }; }

var toUri__default = /*#__PURE__*/_interopDefaultLegacy(toUri);
var debug__default = /*#__PURE__*/_interopDefaultLegacy(debug);
var shuffle__default = /*#__PURE__*/_interopDefaultLegacy(shuffle);
var hashlru__default = /*#__PURE__*/_interopDefaultLegacy(hashlru);

const log = Object.assign(debug__default["default"]('ipfs:preload'), { error: debug__default["default"]('ipfs:preload:error') });
function createPreloader(options = {}) {
  options.enabled = Boolean(options.enabled);
  options.addresses = options.addresses || [];
  options.cache = options.cache || 1000;
  if (!options.enabled || !options.addresses.length) {
    log('preload disabled');
    const api = () => {
    };
    return Object.assign(api, {
      start: () => {
      },
      stop: () => {
      }
    });
  }
  let stopped = true;
  let requests = [];
  const apiUris = options.addresses.map(toUri__default["default"]);
  const cache = hashlru__default["default"](options.cache);
  const api = async cid => {
    try {
      if (stopped) {
        throw new Error(`preload ${ cid } but preloader is not started`);
      }
      const path = cid.toString();
      if (cache.has(path)) {
        return;
      }
      cache.set(path, true);
      const fallbackApiUris = shuffle__default["default"](apiUris);
      let success = false;
      const now = Date.now();
      for (const uri of fallbackApiUris) {
        if (stopped)
          throw new Error(`preload aborted for ${ path }`);
        let controller;
        try {
          controller = new nativeAbortController.AbortController();
          requests = requests.concat(controller);
          await preload.preload(`${ uri }/api/v0/refs?r=true&arg=${ encodeURIComponent(path) }`, { signal: controller.signal });
          success = true;
        } catch (err) {
          if (err.type !== 'aborted')
            log.error(err);
        } finally {
          requests = requests.filter(r => r !== controller);
        }
        if (success)
          break;
      }
      log(`${ success ? '' : 'un' }successfully preloaded ${ path } in ${ Date.now() - now }ms`);
    } catch (err) {
      log.error(err);
    }
  };
  api.start = () => {
    stopped = false;
  };
  api.stop = () => {
    stopped = true;
    log(`aborting ${ requests.length } pending preload request(s)`);
    requests.forEach(r => r.abort());
    requests = [];
  };
  return api;
}

exports.createPreloader = createPreloader;
