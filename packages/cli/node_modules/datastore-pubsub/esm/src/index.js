import { Key } from 'interface-datastore';
import { BaseDatastore } from 'datastore-core';
import {
  encodeBase32,
  keyToTopic,
  topicToKey
} from './utils.js';
import { equals as uint8ArrayEquals } from 'uint8arrays/equals';
import errcode from 'err-code';
import debug from 'debug';
const log = Object.assign(debug('datastore-pubsub:publisher'), { error: debug('datastore-pubsub:publisher:error') });
export class PubsubDatastore extends BaseDatastore {
  constructor(pubsub, datastore, peerId, validator, subscriptionKeyFn) {
    super();
    if (!validator) {
      throw errcode(new TypeError('missing validator'), 'ERR_INVALID_PARAMETERS');
    }
    if (typeof validator.validate !== 'function') {
      throw errcode(new TypeError('missing validate function'), 'ERR_INVALID_PARAMETERS');
    }
    if (typeof validator.select !== 'function') {
      throw errcode(new TypeError('missing select function'), 'ERR_INVALID_PARAMETERS');
    }
    if (subscriptionKeyFn && typeof subscriptionKeyFn !== 'function') {
      throw errcode(new TypeError('invalid subscriptionKeyFn received'), 'ERR_INVALID_PARAMETERS');
    }
    this._pubsub = pubsub;
    this._datastore = datastore;
    this._peerId = peerId;
    this._validator = validator;
    this._handleSubscriptionKeyFn = subscriptionKeyFn;
    this._onMessage = this._onMessage.bind(this);
  }
  async put(key, val) {
    if (!(key instanceof Uint8Array)) {
      const errMsg = 'datastore key does not have a valid format';
      log.error(errMsg);
      throw errcode(new Error(errMsg), 'ERR_INVALID_DATASTORE_KEY');
    }
    if (!(val instanceof Uint8Array)) {
      const errMsg = 'received value is not a Uint8Array';
      log.error(errMsg);
      throw errcode(new Error(errMsg), 'ERR_INVALID_VALUE_RECEIVED');
    }
    const stringifiedTopic = keyToTopic(key);
    log(`publish value for topic ${ stringifiedTopic }`);
    await this._pubsub.publish(stringifiedTopic, val);
  }
  async get(key) {
    if (!(key instanceof Uint8Array)) {
      const errMsg = 'datastore key does not have a valid format';
      log.error(errMsg);
      throw errcode(new Error(errMsg), 'ERR_INVALID_DATASTORE_KEY');
    }
    const stringifiedTopic = keyToTopic(key);
    const subscriptions = await this._pubsub.getTopics();
    if (subscriptions && Array.isArray(subscriptions) && subscriptions.indexOf(stringifiedTopic) > -1) {
      return this._getLocal(key);
    }
    try {
      this._pubsub.on(stringifiedTopic, this._onMessage);
      await this._pubsub.subscribe(stringifiedTopic);
    } catch (err) {
      const errMsg = `cannot subscribe topic ${ stringifiedTopic }`;
      log.error(errMsg);
      throw errcode(new Error(errMsg), 'ERR_SUBSCRIBING_TOPIC');
    }
    log(`subscribed values for key ${ stringifiedTopic }`);
    return this._getLocal(key);
  }
  unsubscribe(key) {
    const stringifiedTopic = keyToTopic(key);
    this._pubsub.removeListener(stringifiedTopic, this._onMessage);
    return this._pubsub.unsubscribe(stringifiedTopic);
  }
  async _getLocal(key) {
    const routingKey = new Key('/' + encodeBase32(key), false);
    let dsVal;
    try {
      dsVal = await this._datastore.get(routingKey);
    } catch (err) {
      if (err.code !== 'ERR_NOT_FOUND') {
        const errMsg = `unexpected error getting the ipns record for ${ routingKey.toString() }`;
        log.error(errMsg);
        throw errcode(new Error(errMsg), 'ERR_UNEXPECTED_ERROR_GETTING_RECORD');
      }
      const errMsg = `local record requested was not found for ${ routingKey.toString() }`;
      log.error(errMsg);
      throw errcode(new Error(errMsg), 'ERR_NOT_FOUND');
    }
    if (!(dsVal instanceof Uint8Array)) {
      const errMsg = 'found record that we couldn\'t convert to a value';
      log.error(errMsg);
      throw errcode(new Error(errMsg), 'ERR_INVALID_RECORD_RECEIVED');
    }
    return dsVal;
  }
  async _onMessage(msg) {
    const {data, from, topicIDs} = msg;
    let key;
    try {
      key = topicToKey(topicIDs[0]);
    } catch (err) {
      log.error(err);
      return;
    }
    log(`message received for topic ${ topicIDs[0] }`);
    if (from === this._peerId.toB58String()) {
      log('message discarded as it is from the same peer');
      return;
    }
    if (this._handleSubscriptionKeyFn) {
      let res;
      try {
        res = await this._handleSubscriptionKeyFn(key);
      } catch (err) {
        log.error('message discarded by the subscriptionKeyFn');
        return;
      }
      key = res;
    }
    try {
      await this._storeIfSubscriptionIsBetter(key, data);
    } catch (err) {
      log.error(err);
    }
  }
  async _storeIfSubscriptionIsBetter(key, data) {
    let isBetter = false;
    try {
      isBetter = await this._isBetter(key, data);
    } catch (err) {
      if (err.code !== 'ERR_NOT_VALID_RECORD') {
        throw err;
      }
    }
    if (isBetter) {
      await this._storeRecord(key, data);
    }
  }
  async _validateRecord(value, peerId) {
    return this._validator.validate(value, peerId);
  }
  async _selectRecord(key, records) {
    const res = await this._validator.select(key, records);
    return res === 0;
  }
  async _isBetter(key, val) {
    try {
      await this._validateRecord(val, key);
    } catch (err) {
      const errMsg = 'record received through pubsub is not valid';
      log.error(errMsg);
      throw errcode(new Error(errMsg), 'ERR_NOT_VALID_RECORD');
    }
    const dsKey = new Key(key);
    let currentRecord;
    try {
      currentRecord = await this._getLocal(dsKey.uint8Array());
    } catch (err) {
      return true;
    }
    if (uint8ArrayEquals(currentRecord, val)) {
      return false;
    }
    return this._selectRecord(key, [
      currentRecord,
      val
    ]);
  }
  async _storeRecord(key, data) {
    const routingKey = new Key('/' + encodeBase32(key), false);
    await this._datastore.put(routingKey, data);
    log(`record for ${ keyToTopic(key) } was stored in the datastore`);
  }
}