import drain from 'it-drain';
import pushable from 'it-pushable';
import { Key } from 'interface-datastore/key';
import { CID } from 'multiformats/cid';
import * as raw from 'multiformats/codecs/raw';
import * as Digest from 'multiformats/hashes/digest';
import {
  base32,
  base32pad
} from 'multiformats/bases/base32';
import { base58btc } from 'multiformats/bases/base58';
import errcode from 'err-code';
import { BaseBlockstore } from 'blockstore-core/base';
function cidToKey(cid) {
  const c = CID.asCID(cid);
  if (!c) {
    throw errcode(new Error('Not a valid cid'), 'ERR_INVALID_CID');
  }
  return new Key('/' + base32.encode(c.multihash.bytes).slice(1).toUpperCase(), false);
}
function keyToCid(key) {
  return CID.createV1(raw.code, Digest.decode(base32.decode('b' + key.toString().slice(1).toLowerCase())));
}
function convertPrefix(prefix) {
  const firstChar = prefix.substring(0, 1);
  if (firstChar === '/') {
    return convertPrefix(prefix.substring(1));
  }
  let decoder;
  if (firstChar.toLowerCase() === 'b') {
    decoder = input => base32.decode(input.toLowerCase()).subarray(2);
  } else if (firstChar.toLowerCase() === 'c') {
    decoder = input => base32pad.decode(input.toLowerCase()).subarray(2);
  } else if (firstChar === 'z') {
    decoder = input => base58btc.decode(input).subarray(2);
  } else if (firstChar === 'Q') {
    decoder = input => base58btc.decode('z' + input);
  } else {
    decoder = input => base32.decode('b' + input.toLowerCase()).subarray(2);
  }
  let bytes;
  for (let i = 1; i < prefix.length; i++) {
    try {
      bytes = decoder(prefix.substring(0, i));
    } catch (err) {
      if (err.message !== 'Unexpected end of data') {
        throw err;
      }
    }
  }
  let str = '/C';
  if (bytes) {
    str = `/${ base32.encode(bytes).slice(1, -1).toUpperCase() || 'C' }`;
  }
  return str;
}
function convertQuery(query) {
  return {
    ...query,
    prefix: query.prefix ? convertPrefix(query.prefix) : undefined,
    filters: query.filters ? query.filters.map(filter => pair => {
      return filter({
        key: keyToCid(pair.key),
        value: pair.value
      });
    }) : undefined,
    orders: query.orders ? query.orders.map(order => (a, b) => {
      return order({
        key: keyToCid(a.key),
        value: a.value
      }, {
        key: keyToCid(b.key),
        value: b.value
      });
    }) : undefined
  };
}
function convertKeyQuery(query) {
  return {
    ...query,
    prefix: query.prefix ? convertPrefix(query.prefix) : undefined,
    filters: query.filters ? query.filters.map(filter => key => {
      return filter(keyToCid(key));
    }) : undefined,
    orders: query.orders ? query.orders.map(order => (a, b) => {
      return order(keyToCid(a), keyToCid(b));
    }) : undefined
  };
}
export class BlockstoreDatastoreAdapter extends BaseBlockstore {
  constructor(datastore) {
    super();
    this.child = datastore;
  }
  open() {
    return this.child.open();
  }
  close() {
    return this.child.close();
  }
  async *query(query, options) {
    for await (const {key, value} of this.child.query(convertQuery(query), options)) {
      yield {
        key: keyToCid(key),
        value
      };
    }
  }
  async *queryKeys(query, options) {
    for await (const key of this.child.queryKeys(convertKeyQuery(query), options)) {
      yield keyToCid(key);
    }
  }
  async get(cid, options) {
    return this.child.get(cidToKey(cid), options);
  }
  async *getMany(cids, options) {
    for await (const cid of cids) {
      yield this.get(cid, options);
    }
  }
  async put(cid, value, options) {
    await this.child.put(cidToKey(cid), value, options);
  }
  async *putMany(blocks, options) {
    const output = pushable();
    const runner = globalThis.process && globalThis.process.nextTick ? globalThis.process.nextTick : globalThis.setImmediate || globalThis.setTimeout;
    runner(async () => {
      try {
        const store = this.child;
        await drain(this.child.putMany(async function* () {
          for await (const block of blocks) {
            const key = cidToKey(block.key);
            const exists = await store.has(key, options);
            if (!exists) {
              yield {
                key,
                value: block.value
              };
            }
            output.push(block);
          }
        }()));
        output.end();
      } catch (err) {
        output.end(err);
      }
    });
    yield* output;
  }
  has(cid, options) {
    return this.child.has(cidToKey(cid), options);
  }
  delete(cid, options) {
    return this.child.delete(cidToKey(cid), options);
  }
  deleteMany(cids, options) {
    const out = pushable();
    drain(this.child.deleteMany(async function* () {
      for await (const cid of cids) {
        yield cidToKey(cid);
        out.push(cid);
      }
      out.end();
    }(), options)).catch(err => {
      out.end(err);
    });
    return out;
  }
}