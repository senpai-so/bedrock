'use strict';

Object.defineProperty(exports, '__esModule', { value: true });

var drain = require('it-drain');
var pushable = require('it-pushable');
var key = require('interface-datastore/key');
var cid = require('multiformats/cid');
var raw = require('multiformats/codecs/raw');
var Digest = require('multiformats/hashes/digest');
var base32 = require('multiformats/bases/base32');
var base58 = require('multiformats/bases/base58');
var errcode = require('err-code');
var base = require('blockstore-core/base');

function _interopDefaultLegacy (e) { return e && typeof e === 'object' && 'default' in e ? e : { 'default': e }; }

function _interopNamespace(e) {
  if (e && e.__esModule) return e;
  var n = Object.create(null);
  if (e) {
    Object.keys(e).forEach(function (k) {
      if (k !== 'default') {
        var d = Object.getOwnPropertyDescriptor(e, k);
        Object.defineProperty(n, k, d.get ? d : {
          enumerable: true,
          get: function () {
            return e[k];
          }
        });
      }
    });
  }
  n['default'] = e;
  return Object.freeze(n);
}

var drain__default = /*#__PURE__*/_interopDefaultLegacy(drain);
var pushable__default = /*#__PURE__*/_interopDefaultLegacy(pushable);
var raw__namespace = /*#__PURE__*/_interopNamespace(raw);
var Digest__namespace = /*#__PURE__*/_interopNamespace(Digest);
var errcode__default = /*#__PURE__*/_interopDefaultLegacy(errcode);

function cidToKey(cid$1) {
  const c = cid.CID.asCID(cid$1);
  if (!c) {
    throw errcode__default['default'](new Error('Not a valid cid'), 'ERR_INVALID_CID');
  }
  return new key.Key('/' + base32.base32.encode(c.multihash.bytes).slice(1).toUpperCase(), false);
}
function keyToCid(key) {
  return cid.CID.createV1(raw__namespace.code, Digest__namespace.decode(base32.base32.decode('b' + key.toString().slice(1).toLowerCase())));
}
function convertPrefix(prefix) {
  const firstChar = prefix.substring(0, 1);
  if (firstChar === '/') {
    return convertPrefix(prefix.substring(1));
  }
  let decoder;
  if (firstChar.toLowerCase() === 'b') {
    decoder = input => base32.base32.decode(input.toLowerCase()).subarray(2);
  } else if (firstChar.toLowerCase() === 'c') {
    decoder = input => base32.base32pad.decode(input.toLowerCase()).subarray(2);
  } else if (firstChar === 'z') {
    decoder = input => base58.base58btc.decode(input).subarray(2);
  } else if (firstChar === 'Q') {
    decoder = input => base58.base58btc.decode('z' + input);
  } else {
    decoder = input => base32.base32.decode('b' + input.toLowerCase()).subarray(2);
  }
  let bytes;
  for (let i = 1; i < prefix.length; i++) {
    try {
      bytes = decoder(prefix.substring(0, i));
    } catch (err) {
      if (err.message !== 'Unexpected end of data') {
        throw err;
      }
    }
  }
  let str = '/C';
  if (bytes) {
    str = `/${ base32.base32.encode(bytes).slice(1, -1).toUpperCase() || 'C' }`;
  }
  return str;
}
function convertQuery(query) {
  return {
    ...query,
    prefix: query.prefix ? convertPrefix(query.prefix) : undefined,
    filters: query.filters ? query.filters.map(filter => pair => {
      return filter({
        key: keyToCid(pair.key),
        value: pair.value
      });
    }) : undefined,
    orders: query.orders ? query.orders.map(order => (a, b) => {
      return order({
        key: keyToCid(a.key),
        value: a.value
      }, {
        key: keyToCid(b.key),
        value: b.value
      });
    }) : undefined
  };
}
function convertKeyQuery(query) {
  return {
    ...query,
    prefix: query.prefix ? convertPrefix(query.prefix) : undefined,
    filters: query.filters ? query.filters.map(filter => key => {
      return filter(keyToCid(key));
    }) : undefined,
    orders: query.orders ? query.orders.map(order => (a, b) => {
      return order(keyToCid(a), keyToCid(b));
    }) : undefined
  };
}
class BlockstoreDatastoreAdapter extends base.BaseBlockstore {
  constructor(datastore) {
    super();
    this.child = datastore;
  }
  open() {
    return this.child.open();
  }
  close() {
    return this.child.close();
  }
  async *query(query, options) {
    for await (const {key, value} of this.child.query(convertQuery(query), options)) {
      yield {
        key: keyToCid(key),
        value
      };
    }
  }
  async *queryKeys(query, options) {
    for await (const key of this.child.queryKeys(convertKeyQuery(query), options)) {
      yield keyToCid(key);
    }
  }
  async get(cid, options) {
    return this.child.get(cidToKey(cid), options);
  }
  async *getMany(cids, options) {
    for await (const cid of cids) {
      yield this.get(cid, options);
    }
  }
  async put(cid, value, options) {
    await this.child.put(cidToKey(cid), value, options);
  }
  async *putMany(blocks, options) {
    const output = pushable__default['default']();
    const runner = globalThis.process && globalThis.process.nextTick ? globalThis.process.nextTick : globalThis.setImmediate || globalThis.setTimeout;
    runner(async () => {
      try {
        const store = this.child;
        await drain__default['default'](this.child.putMany(async function* () {
          for await (const block of blocks) {
            const key = cidToKey(block.key);
            const exists = await store.has(key, options);
            if (!exists) {
              yield {
                key,
                value: block.value
              };
            }
            output.push(block);
          }
        }()));
        output.end();
      } catch (err) {
        output.end(err);
      }
    });
    yield* output;
  }
  has(cid, options) {
    return this.child.has(cidToKey(cid), options);
  }
  delete(cid, options) {
    return this.child.delete(cidToKey(cid), options);
  }
  deleteMany(cids, options) {
    const out = pushable__default['default']();
    drain__default['default'](this.child.deleteMany(async function* () {
      for await (const cid of cids) {
        yield cidToKey(cid);
        out.push(cid);
      }
      out.end();
    }(), options)).catch(err => {
      out.end(err);
    });
    return out;
  }
}

exports.BlockstoreDatastoreAdapter = BlockstoreDatastoreAdapter;
