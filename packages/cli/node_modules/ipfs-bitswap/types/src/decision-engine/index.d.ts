export class DecisionEngine {
    /**
     * @param {PeerId} peerId
     * @param {import('interface-blockstore').Blockstore} blockstore
     * @param {import('../network').Network} network
     * @param {import('../stats').Stats} stats
     * @param {Object} [opts]
     * @param {number} [opts.targetMessageSize]
     * @param {number} [opts.maxSizeReplaceHasWithBlock]
     */
    constructor(peerId: PeerId, blockstore: import('interface-blockstore').Blockstore, network: import('../network').Network, stats: import('../stats').Stats, opts?: {
        targetMessageSize?: number | undefined;
        maxSizeReplaceHasWithBlock?: number | undefined;
    } | undefined);
    _log: import("debug").Debugger & {
        error: import("debug").Debugger;
    };
    blockstore: import("interface-blockstore").Blockstore;
    network: import("../network").Network;
    _stats: import("../stats").Stats;
    _opts: {
        targetMessageSize?: number | undefined;
        maxSizeReplaceHasWithBlock?: number | undefined;
    } & {
        maxSizeReplaceHasWithBlock: number;
        targetMessageSize: number;
    };
    /** @type {Map<string, Ledger>} */
    ledgerMap: Map<string, Ledger>;
    _running: boolean;
    _requestQueue: RequestQueue;
    /**
     * @template {Object} Opts
     * @param {Opts} opts
     * @returns {Opts & {maxSizeReplaceHasWithBlock:number, targetMessageSize:number}}
     * @private
     */
    private _processOpts;
    _scheduleProcessTasks(): void;
    /**
     * Pull tasks off the request queue and send a message to the corresponding
     * peer
     */
    _processTasks(): Promise<void>;
    /**
     * @param {PeerId} peerId
     * @returns {Map<string, import('../wantlist/entry').WantListEntry>}
     */
    wantlistForPeer(peerId: PeerId): Map<string, import('../wantlist/entry').WantListEntry>;
    /**
     * @param {PeerId} peerId
     */
    ledgerForPeer(peerId: PeerId): {
        peer: import("peer-id");
        value: number;
        sent: number;
        recv: number;
        exchanged: number;
    } | null;
    /**
     * @returns {PeerId[]}
     */
    peers(): PeerId[];
    /**
     * Receive blocks either from an incoming message from the network, or from
     * blocks being added by the client on the localhost (eg IPFS add)
     *
     * @param {{ cid: CID, data: Uint8Array }[]} blocks
     */
    receivedBlocks(blocks: {
        cid: CID;
        data: Uint8Array;
    }[]): void;
    /**
     * Handle incoming messages
     *
     * @param {PeerId} peerId
     * @param {Message} msg
     * @returns {Promise<void>}
     */
    messageReceived(peerId: PeerId, msg: Message): Promise<void>;
    /**
     * @private
     * @param {PeerId} peerId
     * @param {CID[]} cids
     * @returns {void}
     */
    private _cancelWants;
    /**
     * @private
     * @param {PeerId} peerId
     * @param {BitswapMessageEntry[]} wants
     * @returns {Promise<void>}
     */
    private _addWants;
    /**
     * @private
     * @param {import('../message/message').Message.Wantlist.WantType} wantType
     * @param {number} blockSize
     */
    private _sendAsBlock;
    /**
     * @private
     * @param {CID[]} cids
     * @returns {Promise<Map<string, number>>}
     */
    private _getBlockSizes;
    /**
     * @private
     * @param {CID[]} cids
     * @returns {Promise<Map<string, Uint8Array>>}
     */
    private _getBlocks;
    /**
     * @private
     * @param {Map<string, Uint8Array>} blocksMap
     * @param {Ledger} ledger
     */
    private _updateBlockAccounting;
    /**
     * Clear up all accounting things after message was sent
     *
     * @param {PeerId} peerId
     * @param {CID} cid
     * @param {Uint8Array} block
     */
    messageSent(peerId: PeerId, cid: CID, block: Uint8Array): void;
    /**
     * @param {PeerId} peerId
     * @returns {number}
     */
    numBytesSentTo(peerId: PeerId): number;
    /**
     * @param {PeerId} peerId
     * @returns {number}
     */
    numBytesReceivedFrom(peerId: PeerId): number;
    /**
     *
     * @param {PeerId} _peerId
     * @returns {void}
     */
    peerDisconnected(_peerId: PeerId): void;
    /**
     * @private
     * @param {PeerId} peerId
     * @returns {Ledger}
     */
    private _findOrCreate;
    start(): void;
    stop(): void;
}
export type BitswapMessageEntry = import('../message/entry').BitswapMessageEntry;
export type PeerId = import('peer-id');
import { Ledger } from "./ledger.js";
import { RequestQueue } from "./req-queue.js";
import { CID } from "multiformats/cid";
import { BitswapMessage as Message } from "../message/index.js";
//# sourceMappingURL=index.d.ts.map