/**
 * JavaScript implementation of the Bitswap 'data exchange' protocol
 * used by IPFS.
 *
 * @implements {IPFSBitswap}
 */
export class Bitswap extends BaseBlockstore implements IPFSBitswap {
    /**
     * @param {import('libp2p')} libp2p
     * @param {Blockstore} blockstore
     * @param {Object} [options]
     * @param {boolean} [options.statsEnabled=false]
     * @param {number} [options.statsComputeThrottleTimeout=1000]
     * @param {number} [options.statsComputeThrottleMaxQueueSize=1000]
     * @param {MultihashHasherLoader} [options.hashLoader]
     */
    constructor(libp2p: import('libp2p'), blockstore: Blockstore, options?: {
        statsEnabled?: boolean | undefined;
        statsComputeThrottleTimeout?: number | undefined;
        statsComputeThrottleMaxQueueSize?: number | undefined;
        hashLoader?: import("./types").MultihashHasherLoader | undefined;
    } | undefined);
    _libp2p: import("libp2p");
    _log: import("debug").Debugger & {
        error: import("debug").Debugger;
    };
    _options: {
        statsEnabled: boolean;
        statsComputeThrottleTimeout: number;
        statsComputeThrottleMaxQueueSize: number;
    } & {
        statsEnabled?: boolean | undefined;
        statsComputeThrottleTimeout?: number | undefined;
        statsComputeThrottleMaxQueueSize?: number | undefined;
        hashLoader?: import("./types").MultihashHasherLoader | undefined;
    };
    _stats: Stats;
    network: Network;
    blockstore: import("interface-blockstore").Blockstore;
    engine: DecisionEngine;
    wm: WantManager;
    notifications: Notifications;
    started: boolean;
    isStarted(): boolean;
    /**
     * @type {PeerId}
     */
    get peerId(): import("peer-id");
    /**
     * handle messages received through the network
     *
     * @param {PeerId} peerId
     * @param {BitswapMessage} incoming
     */
    _receiveMessage(peerId: PeerId, incoming: BitswapMessage): Promise<void>;
    /**
     * @private
     * @param {PeerId} peerId
     * @param {CID} cid
     * @param {Uint8Array} data
     * @param {boolean} wasWanted
     */
    private _handleReceivedBlock;
    /**
     * @private
     * @param {string} peerIdStr
     * @param {CID} cid
     * @param {Uint8Array} data
     * @param {boolean} exists
     */
    private _updateReceiveCounters;
    /**
     * handle errors on the receiving channel
     *
     * @param {Error} err
     */
    _receiveError(err: Error): void;
    /**
     * handle new peers
     *
     * @param {PeerId} peerId
     */
    _onPeerConnected(peerId: PeerId): void;
    /**
     * handle peers being disconnected
     *
     * @param {PeerId} peerId
     */
    _onPeerDisconnected(peerId: PeerId): void;
    enableStats(): void;
    disableStats(): void;
    /**
     * Return the current wantlist for a given `peerId`
     *
     * @param {PeerId} peerId
     * @param {any} [_options]
     */
    wantlistForPeer(peerId: PeerId, _options?: any): Map<string, import("./wantlist/entry.js").WantListEntry>;
    /**
     * Return ledger information for a given `peerId`
     *
     * @param {PeerId} peerId
     */
    ledgerForPeer(peerId: PeerId): {
        peer: import("peer-id");
        value: number;
        sent: number;
        recv: number;
        exchanged: number;
    } | null;
    /**
     * Removes the given CIDs from the wantlist independent of any ref counts.
     *
     * This will cause all outstanding promises for a given block to reject.
     *
     * If you want to cancel the want for a block without doing that, pass an
     * AbortSignal in to `.get` or `.getMany` and abort it.
     *
     * @param {CID[]|CID} cids
     */
    unwant(cids: CID[] | CID): void;
    /**
     * Removes the given keys from the want list. This may cause pending promises
     * for blocks to never resolve.  If you wish these promises to abort instead
     * call `unwant(cids)` instead.
     *
     * @param {CID[]|CID} cids
     */
    cancelWants(cids: CID[] | CID): void;
    /**
     * Sends notifications about the arrival of a block
     *
     * @private
     * @param {CID} cid
     * @param {Uint8Array} data
     */
    private _sendHaveBlockNotifications;
    /**
     * Get the current list of wants
     */
    getWantlist(): IterableIterator<[string, import("./wantlist/entry.js").WantListEntry]>;
    /**
     * Get the current list of partners
     */
    peers(): import("peer-id")[];
    /**
     * Get stats about the bitswap node
     */
    stat(): Stats;
    /**
     * Start the bitswap node
     */
    start(): void;
    /**
     * Stop the bitswap node
     */
    stop(): void;
    unwrap(): import("interface-blockstore").Blockstore;
}
export type IPFSBitswap = import('./types').IPFSBitswap;
export type MultihashHasherLoader = import('./types').MultihashHasherLoader;
export type BitswapMessage = import('./message').BitswapMessage;
export type PeerId = import('peer-id');
export type Blockstore = import('interface-blockstore').Blockstore;
export type Pair = import('interface-blockstore').Pair;
export type Options = import('interface-blockstore').Options;
import { BaseBlockstore } from "blockstore-core/base";
import { Stats } from "./stats/index.js";
import { Network } from "./network.js";
import { DecisionEngine } from "./decision-engine/index.js";
import { WantManager } from "./want-manager/index.js";
import { Notifications } from "./notifications.js";
import { CID } from "multiformats/cid";
//# sourceMappingURL=bitswap.d.ts.map