'use strict';

Object.defineProperty(exports, '__esModule', { value: true });

var cid = require('multiformats/cid');
var sha2 = require('multiformats/hashes/sha2');
var base58 = require('multiformats/bases/base58');
var vd = require('varint-decoder');
var varintEncoder = require('../utils/varint-encoder.js');
var index = require('../utils/index.js');
var message = require('./message.js');
var entry = require('./entry.js');
var errcode = require('err-code');

function _interopDefaultLegacy (e) { return e && typeof e === 'object' && 'default' in e ? e : { 'default': e }; }

var vd__default = /*#__PURE__*/_interopDefaultLegacy(vd);
var errcode__default = /*#__PURE__*/_interopDefaultLegacy(errcode);

class BitswapMessage {
  constructor(full) {
    this.full = full;
    this.wantlist = new Map();
    this.blocks = new Map();
    this.blockPresences = new Map();
    this.pendingBytes = 0;
  }
  get empty() {
    return this.blocks.size === 0 && this.wantlist.size === 0 && this.blockPresences.size === 0;
  }
  addEntry(cid, priority, wantType, cancel, sendDontHave) {
    if (wantType == null) {
      wantType = BitswapMessage.WantType.Block;
    }
    const cidStr = cid.toString(base58.base58btc);
    const entry$1 = this.wantlist.get(cidStr);
    if (entry$1) {
      if (entry$1.wantType === wantType) {
        entry$1.priority = priority;
      }
      if (cancel) {
        entry$1.cancel = Boolean(cancel);
      }
      if (sendDontHave) {
        entry$1.sendDontHave = Boolean(sendDontHave);
      }
      if (wantType === BitswapMessage.WantType.Block && entry$1.wantType === BitswapMessage.WantType.Have) {
        entry$1.wantType = wantType;
      }
    } else {
      this.wantlist.set(cidStr, new entry.BitswapMessageEntry(cid, priority, wantType, cancel, sendDontHave));
    }
  }
  addBlock(cid, block) {
    const cidStr = cid.toString(base58.base58btc);
    this.blocks.set(cidStr, block);
  }
  addHave(cid) {
    const cidStr = cid.toString(base58.base58btc);
    if (!this.blockPresences.has(cidStr)) {
      this.blockPresences.set(cidStr, BitswapMessage.BlockPresenceType.Have);
    }
  }
  addDontHave(cid) {
    const cidStr = cid.toString(base58.base58btc);
    if (!this.blockPresences.has(cidStr)) {
      this.blockPresences.set(cidStr, BitswapMessage.BlockPresenceType.DontHave);
    }
  }
  cancel(cid) {
    const cidStr = cid.toString(base58.base58btc);
    this.wantlist.delete(cidStr);
    this.addEntry(cid, 0, BitswapMessage.WantType.Block, true, false);
  }
  setPendingBytes(size) {
    this.pendingBytes = size;
  }
  serializeToBitswap100() {
    const msg = {
      wantlist: {
        entries: Array.from(this.wantlist.values()).map(entry => {
          return {
            block: entry.cid.bytes,
            priority: Number(entry.priority),
            cancel: Boolean(entry.cancel)
          };
        }),
        full: this.full ? true : undefined
      },
      blocks: Array.from(this.blocks.values())
    };
    return message.Message.encode(msg).finish();
  }
  serializeToBitswap110() {
    const msg = {
      wantlist: {
        entries: Array.from(this.wantlist.values()).map(entry => {
          return {
            block: entry.cid.bytes,
            priority: Number(entry.priority),
            wantType: entry.wantType,
            cancel: Boolean(entry.cancel),
            sendDontHave: Boolean(entry.sendDontHave)
          };
        }),
        full: this.full ? true : undefined
      },
      blockPresences: [],
      payload: [],
      pendingBytes: this.pendingBytes
    };
    for (const [cidStr, data] of this.blocks.entries()) {
      const cid$1 = cid.CID.parse(cidStr);
      const version = cid$1.version;
      const codec = cid$1.code;
      const multihash = cid$1.multihash.code;
      const digestLength = cid$1.multihash.digest.length;
      const prefix = varintEncoder([
        version,
        codec,
        multihash,
        digestLength
      ]);
      msg.payload.push(new message.Message.Block({
        prefix,
        data
      }));
    }
    for (const [cidStr, bpType] of this.blockPresences) {
      msg.blockPresences.push(new message.Message.BlockPresence({
        cid: cid.CID.parse(cidStr).bytes,
        type: bpType
      }));
    }
    if (this.pendingBytes > 0) {
      msg.pendingBytes = this.pendingBytes;
    }
    return message.Message.encode(msg).finish();
  }
  equals(other) {
    if (this.full !== other.full || this.pendingBytes !== other.pendingBytes || !index.isMapEqual(this.wantlist, other.wantlist) || !index.isMapEqual(this.blocks, other.blocks) || !index.isMapEqual(this.blockPresences, other.blockPresences)) {
      return false;
    }
    return true;
  }
  get [Symbol.toStringTag]() {
    const list = Array.from(this.wantlist.keys());
    const blocks = Array.from(this.blocks.keys());
    return `BitswapMessage <full: ${ this.full }, list: ${ list }, blocks: ${ blocks }>`;
  }
}
BitswapMessage.deserialize = async (raw, hashLoader) => {
  const decoded = message.Message.decode(raw);
  const isFull = decoded.wantlist && decoded.wantlist.full || false;
  const msg = new BitswapMessage(isFull);
  if (decoded.wantlist && decoded.wantlist.entries) {
    decoded.wantlist.entries.forEach(entry => {
      if (!entry.block) {
        return;
      }
      const cid$1 = cid.CID.decode(entry.block);
      msg.addEntry(cid$1, entry.priority || 0, entry.wantType, Boolean(entry.cancel), Boolean(entry.sendDontHave));
    });
  }
  if (decoded.blockPresences) {
    decoded.blockPresences.forEach(blockPresence => {
      if (!blockPresence.cid) {
        return;
      }
      const cid$1 = cid.CID.decode(blockPresence.cid);
      if (blockPresence.type === BitswapMessage.BlockPresenceType.Have) {
        msg.addHave(cid$1);
      } else {
        msg.addDontHave(cid$1);
      }
    });
  }
  if (decoded.blocks.length > 0) {
    await Promise.all(decoded.blocks.map(async b => {
      const hash = await sha2.sha256.digest(b);
      const cid$1 = cid.CID.createV0(hash);
      msg.addBlock(cid$1, b);
    }));
    return msg;
  }
  if (decoded.payload.length > 0) {
    await Promise.all(decoded.payload.map(async p => {
      if (!p.prefix || !p.data) {
        return;
      }
      const values = vd__default["default"](p.prefix);
      const cidVersion = values[0];
      const multicodec = values[1];
      const hashAlg = values[2];
      const hasher = hashAlg === sha2.sha256.code ? sha2.sha256 : hashLoader && await hashLoader.getHasher(hashAlg);
      if (!hasher) {
        throw errcode__default["default"](new Error('Unknown hash algorithm'), 'ERR_UNKNOWN_HASH_ALG');
      }
      const hash = await hasher.digest(p.data);
      const cid$1 = cid.CID.create(cidVersion, multicodec, hash);
      msg.addBlock(cid$1, p.data);
    }));
    msg.setPendingBytes(decoded.pendingBytes);
    return msg;
  }
  return msg;
};
BitswapMessage.blockPresenceSize = cid => {
  return cid.bytes.length + 1;
};
BitswapMessage.Entry = entry.BitswapMessageEntry;
BitswapMessage.WantType = {
  Block: message.Message.Wantlist.WantType.Block,
  Have: message.Message.Wantlist.WantType.Have
};
BitswapMessage.BlockPresenceType = {
  Have: message.Message.BlockPresenceType.Have,
  DontHave: message.Message.BlockPresenceType.DontHave
};

exports.BitswapMessage = BitswapMessage;
