import $protobuf from 'protobufjs/minimal.js';
const $Reader = $protobuf.Reader, $Writer = $protobuf.Writer, $util = $protobuf.util;
const $root = $protobuf.roots['ipfs-bitswap'] || ($protobuf.roots['ipfs-bitswap'] = {});
export const Message = $root.Message = (() => {
  function Message(p) {
    this.blocks = [];
    this.payload = [];
    this.blockPresences = [];
    if (p)
      for (var ks = Object.keys(p), i = 0; i < ks.length; ++i)
        if (p[ks[i]] != null)
          this[ks[i]] = p[ks[i]];
  }
  Message.prototype.wantlist = null;
  Message.prototype.blocks = $util.emptyArray;
  Message.prototype.payload = $util.emptyArray;
  Message.prototype.blockPresences = $util.emptyArray;
  Message.prototype.pendingBytes = 0;
  Message.encode = function encode(m, w) {
    if (!w)
      w = $Writer.create();
    if (m.wantlist != null && Object.hasOwnProperty.call(m, 'wantlist'))
      $root.Message.Wantlist.encode(m.wantlist, w.uint32(10).fork()).ldelim();
    if (m.blocks != null && m.blocks.length) {
      for (var i = 0; i < m.blocks.length; ++i)
        w.uint32(18).bytes(m.blocks[i]);
    }
    if (m.payload != null && m.payload.length) {
      for (var i = 0; i < m.payload.length; ++i)
        $root.Message.Block.encode(m.payload[i], w.uint32(26).fork()).ldelim();
    }
    if (m.blockPresences != null && m.blockPresences.length) {
      for (var i = 0; i < m.blockPresences.length; ++i)
        $root.Message.BlockPresence.encode(m.blockPresences[i], w.uint32(34).fork()).ldelim();
    }
    if (m.pendingBytes != null && Object.hasOwnProperty.call(m, 'pendingBytes'))
      w.uint32(40).int32(m.pendingBytes);
    return w;
  };
  Message.decode = function decode(r, l) {
    if (!(r instanceof $Reader))
      r = $Reader.create(r);
    var c = l === undefined ? r.len : r.pos + l, m = new $root.Message();
    while (r.pos < c) {
      var t = r.uint32();
      switch (t >>> 3) {
      case 1:
        m.wantlist = $root.Message.Wantlist.decode(r, r.uint32());
        break;
      case 2:
        if (!(m.blocks && m.blocks.length))
          m.blocks = [];
        m.blocks.push(r.bytes());
        break;
      case 3:
        if (!(m.payload && m.payload.length))
          m.payload = [];
        m.payload.push($root.Message.Block.decode(r, r.uint32()));
        break;
      case 4:
        if (!(m.blockPresences && m.blockPresences.length))
          m.blockPresences = [];
        m.blockPresences.push($root.Message.BlockPresence.decode(r, r.uint32()));
        break;
      case 5:
        m.pendingBytes = r.int32();
        break;
      default:
        r.skipType(t & 7);
        break;
      }
    }
    return m;
  };
  Message.fromObject = function fromObject(d) {
    if (d instanceof $root.Message)
      return d;
    var m = new $root.Message();
    if (d.wantlist != null) {
      if (typeof d.wantlist !== 'object')
        throw TypeError('.Message.wantlist: object expected');
      m.wantlist = $root.Message.Wantlist.fromObject(d.wantlist);
    }
    if (d.blocks) {
      if (!Array.isArray(d.blocks))
        throw TypeError('.Message.blocks: array expected');
      m.blocks = [];
      for (var i = 0; i < d.blocks.length; ++i) {
        if (typeof d.blocks[i] === 'string')
          $util.base64.decode(d.blocks[i], m.blocks[i] = $util.newBuffer($util.base64.length(d.blocks[i])), 0);
        else if (d.blocks[i].length)
          m.blocks[i] = d.blocks[i];
      }
    }
    if (d.payload) {
      if (!Array.isArray(d.payload))
        throw TypeError('.Message.payload: array expected');
      m.payload = [];
      for (var i = 0; i < d.payload.length; ++i) {
        if (typeof d.payload[i] !== 'object')
          throw TypeError('.Message.payload: object expected');
        m.payload[i] = $root.Message.Block.fromObject(d.payload[i]);
      }
    }
    if (d.blockPresences) {
      if (!Array.isArray(d.blockPresences))
        throw TypeError('.Message.blockPresences: array expected');
      m.blockPresences = [];
      for (var i = 0; i < d.blockPresences.length; ++i) {
        if (typeof d.blockPresences[i] !== 'object')
          throw TypeError('.Message.blockPresences: object expected');
        m.blockPresences[i] = $root.Message.BlockPresence.fromObject(d.blockPresences[i]);
      }
    }
    if (d.pendingBytes != null) {
      m.pendingBytes = d.pendingBytes | 0;
    }
    return m;
  };
  Message.toObject = function toObject(m, o) {
    if (!o)
      o = {};
    var d = {};
    if (o.arrays || o.defaults) {
      d.blocks = [];
      d.payload = [];
      d.blockPresences = [];
    }
    if (o.defaults) {
      d.wantlist = null;
      d.pendingBytes = 0;
    }
    if (m.wantlist != null && m.hasOwnProperty('wantlist')) {
      d.wantlist = $root.Message.Wantlist.toObject(m.wantlist, o);
    }
    if (m.blocks && m.blocks.length) {
      d.blocks = [];
      for (var j = 0; j < m.blocks.length; ++j) {
        d.blocks[j] = o.bytes === String ? $util.base64.encode(m.blocks[j], 0, m.blocks[j].length) : o.bytes === Array ? Array.prototype.slice.call(m.blocks[j]) : m.blocks[j];
      }
    }
    if (m.payload && m.payload.length) {
      d.payload = [];
      for (var j = 0; j < m.payload.length; ++j) {
        d.payload[j] = $root.Message.Block.toObject(m.payload[j], o);
      }
    }
    if (m.blockPresences && m.blockPresences.length) {
      d.blockPresences = [];
      for (var j = 0; j < m.blockPresences.length; ++j) {
        d.blockPresences[j] = $root.Message.BlockPresence.toObject(m.blockPresences[j], o);
      }
    }
    if (m.pendingBytes != null && m.hasOwnProperty('pendingBytes')) {
      d.pendingBytes = m.pendingBytes;
    }
    return d;
  };
  Message.prototype.toJSON = function toJSON() {
    return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
  };
  Message.Wantlist = function () {
    function Wantlist(p) {
      this.entries = [];
      if (p)
        for (var ks = Object.keys(p), i = 0; i < ks.length; ++i)
          if (p[ks[i]] != null)
            this[ks[i]] = p[ks[i]];
    }
    Wantlist.prototype.entries = $util.emptyArray;
    Wantlist.prototype.full = false;
    Wantlist.encode = function encode(m, w) {
      if (!w)
        w = $Writer.create();
      if (m.entries != null && m.entries.length) {
        for (var i = 0; i < m.entries.length; ++i)
          $root.Message.Wantlist.Entry.encode(m.entries[i], w.uint32(10).fork()).ldelim();
      }
      if (m.full != null && Object.hasOwnProperty.call(m, 'full'))
        w.uint32(16).bool(m.full);
      return w;
    };
    Wantlist.decode = function decode(r, l) {
      if (!(r instanceof $Reader))
        r = $Reader.create(r);
      var c = l === undefined ? r.len : r.pos + l, m = new $root.Message.Wantlist();
      while (r.pos < c) {
        var t = r.uint32();
        switch (t >>> 3) {
        case 1:
          if (!(m.entries && m.entries.length))
            m.entries = [];
          m.entries.push($root.Message.Wantlist.Entry.decode(r, r.uint32()));
          break;
        case 2:
          m.full = r.bool();
          break;
        default:
          r.skipType(t & 7);
          break;
        }
      }
      return m;
    };
    Wantlist.fromObject = function fromObject(d) {
      if (d instanceof $root.Message.Wantlist)
        return d;
      var m = new $root.Message.Wantlist();
      if (d.entries) {
        if (!Array.isArray(d.entries))
          throw TypeError('.Message.Wantlist.entries: array expected');
        m.entries = [];
        for (var i = 0; i < d.entries.length; ++i) {
          if (typeof d.entries[i] !== 'object')
            throw TypeError('.Message.Wantlist.entries: object expected');
          m.entries[i] = $root.Message.Wantlist.Entry.fromObject(d.entries[i]);
        }
      }
      if (d.full != null) {
        m.full = Boolean(d.full);
      }
      return m;
    };
    Wantlist.toObject = function toObject(m, o) {
      if (!o)
        o = {};
      var d = {};
      if (o.arrays || o.defaults) {
        d.entries = [];
      }
      if (o.defaults) {
        d.full = false;
      }
      if (m.entries && m.entries.length) {
        d.entries = [];
        for (var j = 0; j < m.entries.length; ++j) {
          d.entries[j] = $root.Message.Wantlist.Entry.toObject(m.entries[j], o);
        }
      }
      if (m.full != null && m.hasOwnProperty('full')) {
        d.full = m.full;
      }
      return d;
    };
    Wantlist.prototype.toJSON = function toJSON() {
      return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
    };
    Wantlist.WantType = function () {
      const valuesById = {}, values = Object.create(valuesById);
      values[valuesById[0] = 'Block'] = 0;
      values[valuesById[1] = 'Have'] = 1;
      return values;
    }();
    Wantlist.Entry = function () {
      function Entry(p) {
        if (p)
          for (var ks = Object.keys(p), i = 0; i < ks.length; ++i)
            if (p[ks[i]] != null)
              this[ks[i]] = p[ks[i]];
      }
      Entry.prototype.block = $util.newBuffer([]);
      Entry.prototype.priority = 0;
      Entry.prototype.cancel = false;
      Entry.prototype.wantType = 0;
      Entry.prototype.sendDontHave = false;
      Entry.encode = function encode(m, w) {
        if (!w)
          w = $Writer.create();
        if (m.block != null && Object.hasOwnProperty.call(m, 'block'))
          w.uint32(10).bytes(m.block);
        if (m.priority != null && Object.hasOwnProperty.call(m, 'priority'))
          w.uint32(16).int32(m.priority);
        if (m.cancel != null && Object.hasOwnProperty.call(m, 'cancel'))
          w.uint32(24).bool(m.cancel);
        if (m.wantType != null && Object.hasOwnProperty.call(m, 'wantType'))
          w.uint32(32).int32(m.wantType);
        if (m.sendDontHave != null && Object.hasOwnProperty.call(m, 'sendDontHave'))
          w.uint32(40).bool(m.sendDontHave);
        return w;
      };
      Entry.decode = function decode(r, l) {
        if (!(r instanceof $Reader))
          r = $Reader.create(r);
        var c = l === undefined ? r.len : r.pos + l, m = new $root.Message.Wantlist.Entry();
        while (r.pos < c) {
          var t = r.uint32();
          switch (t >>> 3) {
          case 1:
            m.block = r.bytes();
            break;
          case 2:
            m.priority = r.int32();
            break;
          case 3:
            m.cancel = r.bool();
            break;
          case 4:
            m.wantType = r.int32();
            break;
          case 5:
            m.sendDontHave = r.bool();
            break;
          default:
            r.skipType(t & 7);
            break;
          }
        }
        return m;
      };
      Entry.fromObject = function fromObject(d) {
        if (d instanceof $root.Message.Wantlist.Entry)
          return d;
        var m = new $root.Message.Wantlist.Entry();
        if (d.block != null) {
          if (typeof d.block === 'string')
            $util.base64.decode(d.block, m.block = $util.newBuffer($util.base64.length(d.block)), 0);
          else if (d.block.length)
            m.block = d.block;
        }
        if (d.priority != null) {
          m.priority = d.priority | 0;
        }
        if (d.cancel != null) {
          m.cancel = Boolean(d.cancel);
        }
        switch (d.wantType) {
        case 'Block':
        case 0:
          m.wantType = 0;
          break;
        case 'Have':
        case 1:
          m.wantType = 1;
          break;
        }
        if (d.sendDontHave != null) {
          m.sendDontHave = Boolean(d.sendDontHave);
        }
        return m;
      };
      Entry.toObject = function toObject(m, o) {
        if (!o)
          o = {};
        var d = {};
        if (o.defaults) {
          if (o.bytes === String)
            d.block = '';
          else {
            d.block = [];
            if (o.bytes !== Array)
              d.block = $util.newBuffer(d.block);
          }
          d.priority = 0;
          d.cancel = false;
          d.wantType = o.enums === String ? 'Block' : 0;
          d.sendDontHave = false;
        }
        if (m.block != null && m.hasOwnProperty('block')) {
          d.block = o.bytes === String ? $util.base64.encode(m.block, 0, m.block.length) : o.bytes === Array ? Array.prototype.slice.call(m.block) : m.block;
        }
        if (m.priority != null && m.hasOwnProperty('priority')) {
          d.priority = m.priority;
        }
        if (m.cancel != null && m.hasOwnProperty('cancel')) {
          d.cancel = m.cancel;
        }
        if (m.wantType != null && m.hasOwnProperty('wantType')) {
          d.wantType = o.enums === String ? $root.Message.Wantlist.WantType[m.wantType] : m.wantType;
        }
        if (m.sendDontHave != null && m.hasOwnProperty('sendDontHave')) {
          d.sendDontHave = m.sendDontHave;
        }
        return d;
      };
      Entry.prototype.toJSON = function toJSON() {
        return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
      };
      return Entry;
    }();
    return Wantlist;
  }();
  Message.Block = function () {
    function Block(p) {
      if (p)
        for (var ks = Object.keys(p), i = 0; i < ks.length; ++i)
          if (p[ks[i]] != null)
            this[ks[i]] = p[ks[i]];
    }
    Block.prototype.prefix = $util.newBuffer([]);
    Block.prototype.data = $util.newBuffer([]);
    Block.encode = function encode(m, w) {
      if (!w)
        w = $Writer.create();
      if (m.prefix != null && Object.hasOwnProperty.call(m, 'prefix'))
        w.uint32(10).bytes(m.prefix);
      if (m.data != null && Object.hasOwnProperty.call(m, 'data'))
        w.uint32(18).bytes(m.data);
      return w;
    };
    Block.decode = function decode(r, l) {
      if (!(r instanceof $Reader))
        r = $Reader.create(r);
      var c = l === undefined ? r.len : r.pos + l, m = new $root.Message.Block();
      while (r.pos < c) {
        var t = r.uint32();
        switch (t >>> 3) {
        case 1:
          m.prefix = r.bytes();
          break;
        case 2:
          m.data = r.bytes();
          break;
        default:
          r.skipType(t & 7);
          break;
        }
      }
      return m;
    };
    Block.fromObject = function fromObject(d) {
      if (d instanceof $root.Message.Block)
        return d;
      var m = new $root.Message.Block();
      if (d.prefix != null) {
        if (typeof d.prefix === 'string')
          $util.base64.decode(d.prefix, m.prefix = $util.newBuffer($util.base64.length(d.prefix)), 0);
        else if (d.prefix.length)
          m.prefix = d.prefix;
      }
      if (d.data != null) {
        if (typeof d.data === 'string')
          $util.base64.decode(d.data, m.data = $util.newBuffer($util.base64.length(d.data)), 0);
        else if (d.data.length)
          m.data = d.data;
      }
      return m;
    };
    Block.toObject = function toObject(m, o) {
      if (!o)
        o = {};
      var d = {};
      if (o.defaults) {
        if (o.bytes === String)
          d.prefix = '';
        else {
          d.prefix = [];
          if (o.bytes !== Array)
            d.prefix = $util.newBuffer(d.prefix);
        }
        if (o.bytes === String)
          d.data = '';
        else {
          d.data = [];
          if (o.bytes !== Array)
            d.data = $util.newBuffer(d.data);
        }
      }
      if (m.prefix != null && m.hasOwnProperty('prefix')) {
        d.prefix = o.bytes === String ? $util.base64.encode(m.prefix, 0, m.prefix.length) : o.bytes === Array ? Array.prototype.slice.call(m.prefix) : m.prefix;
      }
      if (m.data != null && m.hasOwnProperty('data')) {
        d.data = o.bytes === String ? $util.base64.encode(m.data, 0, m.data.length) : o.bytes === Array ? Array.prototype.slice.call(m.data) : m.data;
      }
      return d;
    };
    Block.prototype.toJSON = function toJSON() {
      return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
    };
    return Block;
  }();
  Message.BlockPresenceType = function () {
    const valuesById = {}, values = Object.create(valuesById);
    values[valuesById[0] = 'Have'] = 0;
    values[valuesById[1] = 'DontHave'] = 1;
    return values;
  }();
  Message.BlockPresence = function () {
    function BlockPresence(p) {
      if (p)
        for (var ks = Object.keys(p), i = 0; i < ks.length; ++i)
          if (p[ks[i]] != null)
            this[ks[i]] = p[ks[i]];
    }
    BlockPresence.prototype.cid = $util.newBuffer([]);
    BlockPresence.prototype.type = 0;
    BlockPresence.encode = function encode(m, w) {
      if (!w)
        w = $Writer.create();
      if (m.cid != null && Object.hasOwnProperty.call(m, 'cid'))
        w.uint32(10).bytes(m.cid);
      if (m.type != null && Object.hasOwnProperty.call(m, 'type'))
        w.uint32(16).int32(m.type);
      return w;
    };
    BlockPresence.decode = function decode(r, l) {
      if (!(r instanceof $Reader))
        r = $Reader.create(r);
      var c = l === undefined ? r.len : r.pos + l, m = new $root.Message.BlockPresence();
      while (r.pos < c) {
        var t = r.uint32();
        switch (t >>> 3) {
        case 1:
          m.cid = r.bytes();
          break;
        case 2:
          m.type = r.int32();
          break;
        default:
          r.skipType(t & 7);
          break;
        }
      }
      return m;
    };
    BlockPresence.fromObject = function fromObject(d) {
      if (d instanceof $root.Message.BlockPresence)
        return d;
      var m = new $root.Message.BlockPresence();
      if (d.cid != null) {
        if (typeof d.cid === 'string')
          $util.base64.decode(d.cid, m.cid = $util.newBuffer($util.base64.length(d.cid)), 0);
        else if (d.cid.length)
          m.cid = d.cid;
      }
      switch (d.type) {
      case 'Have':
      case 0:
        m.type = 0;
        break;
      case 'DontHave':
      case 1:
        m.type = 1;
        break;
      }
      return m;
    };
    BlockPresence.toObject = function toObject(m, o) {
      if (!o)
        o = {};
      var d = {};
      if (o.defaults) {
        if (o.bytes === String)
          d.cid = '';
        else {
          d.cid = [];
          if (o.bytes !== Array)
            d.cid = $util.newBuffer(d.cid);
        }
        d.type = o.enums === String ? 'Have' : 0;
      }
      if (m.cid != null && m.hasOwnProperty('cid')) {
        d.cid = o.bytes === String ? $util.base64.encode(m.cid, 0, m.cid.length) : o.bytes === Array ? Array.prototype.slice.call(m.cid) : m.cid;
      }
      if (m.type != null && m.hasOwnProperty('type')) {
        d.type = o.enums === String ? $root.Message.BlockPresenceType[m.type] : m.type;
      }
      return d;
    };
    BlockPresence.prototype.toJSON = function toJSON() {
      return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
    };
    return BlockPresence;
  }();
  return Message;
})();
export {
  $root as default
};