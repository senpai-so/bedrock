import lp from 'it-length-prefixed';
import { pipe } from 'it-pipe';
import MulticodecTopology from 'libp2p-interfaces/src/topology/multicodec-topology.js';
import { BitswapMessage as Message } from './message/index.js';
import * as CONSTANTS from './constants.js';
import { logger } from './utils/index.js';
const BITSWAP100 = '/ipfs/bitswap/1.0.0';
const BITSWAP110 = '/ipfs/bitswap/1.1.0';
const BITSWAP120 = '/ipfs/bitswap/1.2.0';
export class Network {
  constructor(libp2p, bitswap, stats, options = {}) {
    this._log = logger(libp2p.peerId, 'network');
    this._libp2p = libp2p;
    this._bitswap = bitswap;
    this._protocols = [BITSWAP100];
    if (!options.b100Only) {
      this._protocols.unshift(BITSWAP110);
      this._protocols.unshift(BITSWAP120);
    }
    this._stats = stats;
    this._running = false;
    this._onPeerConnect = this._onPeerConnect.bind(this);
    this._onPeerDisconnect = this._onPeerDisconnect.bind(this);
    this._onConnection = this._onConnection.bind(this);
    this._hashLoader = options.hashLoader;
  }
  start() {
    this._running = true;
    this._libp2p.handle(this._protocols, this._onConnection);
    const topology = new MulticodecTopology({
      multicodecs: this._protocols,
      handlers: {
        onConnect: this._onPeerConnect,
        onDisconnect: this._onPeerDisconnect
      }
    });
    this._registrarId = this._libp2p.registrar.register(topology);
    for (const peer of this._libp2p.peerStore.peers.values()) {
      const conn = this._libp2p.connectionManager.get(peer.id);
      conn && this._onPeerConnect(conn.remotePeer);
    }
  }
  stop() {
    this._running = false;
    this._libp2p.unhandle(this._protocols);
    if (this._registrarId != null) {
      this._libp2p.registrar.unregister(this._registrarId);
    }
  }
  async _onConnection({protocol, stream, connection}) {
    if (!this._running) {
      return;
    }
    this._log('incoming new bitswap %s connection from %s', protocol, connection.remotePeer.toB58String());
    try {
      await pipe(stream, lp.decode(), async source => {
        for await (const data of source) {
          try {
            const message = await Message.deserialize(data.slice(), this._hashLoader);
            await this._bitswap._receiveMessage(connection.remotePeer, message);
          } catch (err) {
            this._bitswap._receiveError(err);
            break;
          }
        }
      });
    } catch (err) {
      this._log(err);
    }
  }
  _onPeerConnect(peerId) {
    this._bitswap._onPeerConnected(peerId);
  }
  _onPeerDisconnect(peerId) {
    this._bitswap._onPeerDisconnected(peerId);
  }
  findProviders(cid, maxProviders, options = {}) {
    return this._libp2p.contentRouting.findProviders(cid, {
      timeout: CONSTANTS.providerRequestTimeout,
      maxNumProviders: maxProviders
    });
  }
  async findAndConnect(cid, options) {
    const connectAttempts = [];
    for await (const provider of this.findProviders(cid, CONSTANTS.maxProvidersPerRequest, options)) {
      this._log(`connecting to provider ${ provider.id }`);
      connectAttempts.push(this.connectTo(provider.id, options).catch(err => {
        this._log.error(err);
      }));
    }
    await Promise.all(connectAttempts);
  }
  async provide(cid, options) {
    await this._libp2p.contentRouting.provide(cid, options);
  }
  async sendMessage(peer, msg) {
    if (!this._running)
      throw new Error('network isn\'t running');
    const stringId = peer.toB58String();
    this._log('sendMessage to %s', stringId, msg);
    const connection = await this._libp2p.dial(peer);
    const {stream, protocol} = await connection.newStream([
      BITSWAP120,
      BITSWAP110,
      BITSWAP100
    ]);
    let serialized;
    switch (protocol) {
    case BITSWAP100:
      serialized = msg.serializeToBitswap100();
      break;
    case BITSWAP110:
    case BITSWAP120:
      serialized = msg.serializeToBitswap110();
      break;
    default:
      throw new Error('Unknown protocol: ' + protocol);
    }
    writeMessage(stream, serialized, this._log);
    this._updateSentStats(peer, msg.blocks);
  }
  async connectTo(peer, options) {
    if (!this._running) {
      throw new Error('network isn\'t running');
    }
    return this._libp2p.dial(peer, options);
  }
  _updateSentStats(peer, blocks) {
    const peerId = peer.toB58String();
    if (this._stats) {
      for (const block of blocks.values()) {
        this._stats.push(peerId, 'dataSent', block.length);
      }
      this._stats.push(peerId, 'blocksSent', blocks.size);
    }
  }
}
async function writeMessage(stream, msg, log) {
  try {
    await pipe([msg], lp.encode(), stream);
  } catch (err) {
    log(err);
  }
}