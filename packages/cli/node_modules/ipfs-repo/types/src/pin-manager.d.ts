/**
 * @implements {Pins}
 */
export class PinManager implements Pins {
    /**
     * Throws an error if the pin type is invalid
     *
     * @param {any} type
     * @returns {type is PinType}
     */
    static checkPinType(type: any): type is import("./types").PinType;
    /**
     * @param {Object} config
     * @param {import('interface-datastore').Datastore} config.pinstore
     * @param {import('interface-blockstore').Blockstore} config.blockstore
     * @param {import('./types').loadCodec} config.loadCodec
     */
    constructor({ pinstore, blockstore, loadCodec }: {
        pinstore: import('interface-datastore').Datastore;
        blockstore: import('interface-blockstore').Blockstore;
        loadCodec: import('./types').loadCodec;
    });
    pinstore: import("interface-datastore").Datastore;
    blockstore: import("interface-blockstore").Blockstore;
    loadCodec: import("./types").loadCodec;
    log: debug.Debugger;
    directPins: Set<any>;
    recursivePins: Set<any>;
    /**
     * @param {CID} cid
     * @param {PinOptions & AbortOptions} [options]
     */
    pinDirectly(cid: CID, options?: (import("./types").PinOptions & import("./types").AbortOptions) | undefined): Promise<void>;
    /**
     * @param {CID} cid
     * @param {AbortOptions} [options]
     */
    unpin(cid: CID, options?: import("./types").AbortOptions | undefined): Promise<void>;
    /**
     * @param {CID} cid
     * @param {PinOptions & AbortOptions} [options]
     */
    pinRecursively(cid: CID, options?: (import("./types").PinOptions & import("./types").AbortOptions) | undefined): Promise<void>;
    /**
     * @param {AbortOptions} [options]
     */
    directKeys(options?: import("./types").AbortOptions | undefined): AsyncGenerator<{
        cid: CID;
        metadata: any;
    }, void, unknown>;
    /**
     * @param {AbortOptions} [options]
     */
    recursiveKeys(options?: import("./types").AbortOptions | undefined): AsyncGenerator<{
        cid: CID;
        metadata: any;
    }, void, unknown>;
    /**
     * @param {AbortOptions} [options]
     */
    indirectKeys(options?: import("./types").AbortOptions | undefined): AsyncGenerator<CID, void, unknown>;
    /**
     * @param {CID} cid
     * @param {PinQueryType|PinQueryType[]} types
     * @param {AbortOptions} [options]
     */
    isPinnedWithType(cid: CID, types: PinQueryType | PinQueryType[], options?: import("./types").AbortOptions | undefined): Promise<{
        cid: CID;
        pinned: boolean;
        reason: "recursive" | "direct";
        metadata: any;
        parent?: undefined;
    } | {
        cid: CID;
        pinned: boolean;
        reason: "indirect";
        parent: CID;
        metadata?: undefined;
    } | {
        cid: CID;
        pinned: boolean;
        reason?: undefined;
        metadata?: undefined;
        parent?: undefined;
    }>;
    /**
     * @param {CID} cid
     * @param {AbortOptions} options
     */
    fetchCompleteDag(cid: CID, options: AbortOptions): Promise<void>;
}
export type PinInternal = {
    depth: number;
    version?: import("multiformats/cid").CIDVersion | undefined;
    codec?: number | undefined;
    metadata?: Record<string, any> | undefined;
};
export type PinType = import('./types').PinType;
export type PinQueryType = import('./types').PinQueryType;
export type BlockCodec = import('multiformats/codecs/interface').BlockCodec<any, any>;
export type PinOptions = import('./types').PinOptions;
export type AbortOptions = import('./types').AbortOptions;
export type Pins = import('./types').Pins;
import debug from "debug";
import { CID } from "multiformats/cid";
//# sourceMappingURL=pin-manager.d.ts.map