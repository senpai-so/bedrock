import { Key } from 'interface-datastore/key';
import PQueue from 'p-queue';
import _get from 'just-safe-get';
import _set from 'just-safe-set';
import errCode from 'err-code';
import { NotFoundError } from './errors.js';
import { toString as uint8ArrayToString } from 'uint8arrays/to-string';
import { fromString as uint8ArrayFromString } from 'uint8arrays/from-string';
import {
  getWithFallback,
  hasWithFallback
} from './utils/level.js';
const Queue = PQueue.default ? PQueue.default : PQueue;
const configKey = new Key('config');
export function config(store) {
  const setQueue = new Queue({ concurrency: 1 });
  const configStore = {
    async getAll(options = {}) {
      const encodedValue = await getWithFallback(configKey, store.get.bind(store), store.has.bind(store), store);
      return JSON.parse(uint8ArrayToString(encodedValue));
    },
    async get(key, options = {}) {
      if (key == null) {
        throw new NotFoundError(`Key ${ key } does not exist in config`);
      }
      const config = await this.getAll(options);
      const value = _get(config, key);
      if (value === undefined) {
        throw new NotFoundError(`Key ${ key } does not exist in config`);
      }
      return value;
    },
    set(key, value, options = {}) {
      if (typeof key !== 'string' && !(key instanceof String)) {
        throw errCode(new Error('Invalid key type: ' + typeof key), 'ERR_INVALID_KEY');
      }
      if (value === undefined || value instanceof Uint8Array) {
        throw errCode(new Error('Invalid value type: ' + typeof value), 'ERR_INVALID_VALUE');
      }
      return setQueue.add(() => _maybeDoSet({
        key: key,
        value: value
      }, options.signal));
    },
    replace(value, options = {}) {
      if (!value || value instanceof Uint8Array) {
        throw errCode(new Error('Invalid value type: ' + typeof value), 'ERR_INVALID_VALUE');
      }
      return setQueue.add(() => _maybeDoSet({
        key: undefined,
        value: value
      }, options.signal));
    },
    async exists() {
      return hasWithFallback(configKey, store.has.bind(store), store);
    }
  };
  return configStore;
  async function _maybeDoSet(m, signal) {
    if (signal && signal.aborted) {
      return;
    }
    const key = m.key;
    const value = m.value;
    if (key) {
      const config = await configStore.getAll();
      if (typeof config === 'object' && config !== null) {
        _set(config, key, value);
      }
      return _saveAll(config);
    }
    return _saveAll(value);
  }
  function _saveAll(config) {
    const buf = uint8ArrayFromString(JSON.stringify(config, null, 2));
    return store.put(configKey, buf);
  }
}