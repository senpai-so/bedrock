import { CID } from 'multiformats/cid';
import debug from 'debug';
import { notFoundError } from 'datastore-core/errors';
import parallelBatch from 'it-parallel-batch';
import { pipe } from 'it-pipe';
import merge from 'it-merge';
import map from 'it-map';
import filter from 'it-filter';
import { Key } from 'interface-datastore/key';
import { base32 } from 'multiformats/bases/base32';
import { walkDag } from './utils/walk-dag.js';
const log = debug('ipfs:repo:gc');
const ERR_NOT_FOUND = notFoundError().code;
const BLOCK_RM_CONCURRENCY = 256;
const MFS_ROOT_KEY = new Key('/local/filesroot');
export function gc({gcLock, pins, blockstore, root, loadCodec}) {
  async function* gc() {
    const start = Date.now();
    log('Creating set of marked blocks');
    const release = await gcLock.writeLock();
    try {
      const markedSet = await createMarkedSet({
        pins,
        blockstore,
        root,
        loadCodec
      });
      const blockKeys = blockstore.queryKeys({});
      yield* deleteUnmarkedBlocks({ blockstore }, markedSet, blockKeys);
      log(`Complete (${ Date.now() - start }ms)`);
    } finally {
      release();
    }
  }
  return gc;
}
async function createMarkedSet({pins, blockstore, loadCodec, root}) {
  const mfsSource = async function* () {
    let mh;
    try {
      mh = await root.get(MFS_ROOT_KEY);
    } catch (err) {
      if (err.code === ERR_NOT_FOUND) {
        log('No blocks in MFS');
        return;
      }
      throw err;
    }
    const rootCid = CID.decode(mh);
    yield rootCid;
    yield* walkDag(rootCid, blockstore, loadCodec);
  }();
  const pinsSource = merge(map(pins.recursiveKeys(), ({cid}) => cid), pins.indirectKeys(), map(pins.directKeys(), ({cid}) => cid), mfsSource);
  const output = new Set();
  for await (const cid of merge(pinsSource, mfsSource)) {
    output.add(base32.encode(cid.multihash.bytes));
  }
  return output;
}
async function* deleteUnmarkedBlocks({blockstore}, markedSet, blockKeys) {
  let blocksCount = 0;
  let removedBlocksCount = 0;
  const removeBlock = async cid => {
    return async function remove() {
      blocksCount++;
      try {
        const b32 = base32.encode(cid.multihash.bytes);
        if (markedSet.has(b32)) {
          return null;
        }
        try {
          await blockstore.delete(cid);
          removedBlocksCount++;
        } catch (err) {
          return { err: new Error(`Could not delete block with CID ${ cid }: ${ err.message }`) };
        }
        return { cid };
      } catch (err) {
        const msg = `Could delete block with CID ${ cid }`;
        log(msg, err);
        return { err: new Error(msg + `: ${ err.message }`) };
      }
    };
  };
  yield* pipe(parallelBatch(map(blockKeys, removeBlock), BLOCK_RM_CONCURRENCY), source => filter(source, Boolean));
  log(`Marked set has ${ markedSet.size } unique blocks. Blockstore has ${ blocksCount } blocks. ` + `Deleted ${ removedBlocksCount } blocks.`);
}