'use strict';

Object.defineProperty(exports, '__esModule', { value: true });

var _get = require('just-safe-get');
var debug = require('debug');
var errCode = require('err-code');
var migrator = require('ipfs-repo-migrations');
var bytes = require('bytes');
var merge = require('merge-options');
var constants = require('./constants.js');
var version = require('./version.js');
var config = require('./config.js');
var spec = require('./spec.js');
var apiAddr = require('./api-addr.js');
var idstore = require('./idstore.js');
var defaultOptions = require('./default-options.js');
var defaultDatastore = require('./default-datastore.js');
var errors = require('./errors.js');
var pinManager = require('./pin-manager.js');
var pinnedBlockstore = require('./pinned-blockstore.js');
var mortice = require('mortice');
var gc = require('./gc.js');

function _interopDefaultLegacy (e) { return e && typeof e === 'object' && 'default' in e ? e : { 'default': e }; }

function _interopNamespace(e) {
  if (e && e.__esModule) return e;
  var n = Object.create(null);
  if (e) {
    Object.keys(e).forEach(function (k) {
      if (k !== 'default') {
        var d = Object.getOwnPropertyDescriptor(e, k);
        Object.defineProperty(n, k, d.get ? d : {
          enumerable: true,
          get: function () { return e[k]; }
        });
      }
    });
  }
  n["default"] = e;
  return Object.freeze(n);
}

var _get__default = /*#__PURE__*/_interopDefaultLegacy(_get);
var debug__default = /*#__PURE__*/_interopDefaultLegacy(debug);
var errCode__default = /*#__PURE__*/_interopDefaultLegacy(errCode);
var migrator__namespace = /*#__PURE__*/_interopNamespace(migrator);
var bytes__default = /*#__PURE__*/_interopDefaultLegacy(bytes);
var merge__default = /*#__PURE__*/_interopDefaultLegacy(merge);
var mortice__default = /*#__PURE__*/_interopDefaultLegacy(mortice);

const log = debug__default["default"]('ipfs:repo');
const noLimit = Number.MAX_SAFE_INTEGER;
const AUTO_MIGRATE_CONFIG_KEY = 'repoAutoMigrate';
class Repo {
  constructor(path, loadCodec, backends, options) {
    if (typeof path !== 'string') {
      throw new Error('missing repo path');
    }
    if (typeof loadCodec !== 'function') {
      throw new Error('missing codec loader');
    }
    this.options = merge__default["default"](defaultOptions, options);
    this.closed = true;
    this.path = path;
    this.root = backends.root;
    this.datastore = backends.datastore;
    this.keys = backends.keys;
    const blockstore = backends.blocks;
    const pinstore = backends.pins;
    this.pins = new pinManager.PinManager({
      pinstore,
      blockstore,
      loadCodec
    });
    const pinnedBlockstore$1 = pinnedBlockstore.createPinnedBlockstore(this.pins, blockstore);
    this.blocks = idstore.createIdStore(pinnedBlockstore$1);
    this.version = version.version(this.root);
    this.config = config.config(this.root);
    this.spec = spec.spec(this.root);
    this.apiAddr = apiAddr.apiAddr(this.root);
    this.gcLock = mortice__default["default"](path, { singleProcess: this.options.repoOwner !== false });
    this.gc = gc.gc({
      gcLock: this.gcLock,
      pins: this.pins,
      blockstore: this.blocks,
      root: this.root,
      loadCodec
    });
  }
  async init(config) {
    log('initializing at: %s', this.path);
    await this._openRoot();
    await this.config.replace(buildConfig(config));
    await this.spec.set(buildDatastoreSpec(config));
    await this.version.set(constants.repoVersion);
  }
  async isInitialized() {
    if (!this.closed) {
      return true;
    }
    try {
      await this._openRoot();
      await this._checkInitialized();
      await this.root.close();
      return true;
    } catch (err) {
      return false;
    }
  }
  async open() {
    if (!this.closed) {
      throw errCode__default["default"](new Error('repo is already open'), errors.ERR_REPO_ALREADY_OPEN);
    }
    log('opening at: %s', this.path);
    try {
      await this._openRoot();
      await this._checkInitialized();
      this._lockfile = await this._openLock();
      log('acquired repo.lock');
      const isCompatible = await this.version.check(constants.repoVersion);
      if (!isCompatible) {
        if (await this._isAutoMigrationEnabled()) {
          await this._migrate(constants.repoVersion, {
            root: this.root,
            datastore: this.datastore,
            pins: this.pins.pinstore,
            blocks: this.pins.blockstore,
            keys: this.keys
          });
        } else {
          throw new errors.InvalidRepoVersionError('Incompatible repo versions. Automatic migrations disabled. Please migrate the repo manually.');
        }
      }
      log('creating datastore');
      await this.datastore.open();
      log('creating blocks');
      await this.blocks.open();
      log('creating keystore');
      await this.keys.open();
      log('creating pins');
      await this.pins.pinstore.open();
      this.closed = false;
      log('all opened');
    } catch (err) {
      if (this._lockfile) {
        try {
          await this._closeLock();
          this._lockfile = null;
        } catch (err2) {
          log('error removing lock', err2);
        }
      }
      throw err;
    }
  }
  async _openRoot() {
    try {
      await this.root.open();
    } catch (err) {
      if (err.message !== 'Already open') {
        throw err;
      }
    }
  }
  async _openLock() {
    const lockfile = await this.options.repoLock.lock(this.path);
    if (typeof lockfile.close !== 'function') {
      throw errCode__default["default"](new Error('Locks must have a close method'), 'ERR_NO_CLOSE_FUNCTION');
    }
    return lockfile;
  }
  _closeLock() {
    return this._lockfile && this._lockfile.close();
  }
  async _checkInitialized() {
    log('init check');
    let config;
    try {
      [config] = await Promise.all([
        this.config.exists(),
        this.spec.exists(),
        this.version.exists()
      ]);
    } catch (err) {
      if (err.code === 'ERR_NOT_FOUND') {
        throw errCode__default["default"](new Error('repo is not initialized yet'), errors.ERR_REPO_NOT_INITIALIZED, { path: this.path });
      }
      throw err;
    }
    if (!config) {
      throw errCode__default["default"](new Error('repo is not initialized yet'), errors.ERR_REPO_NOT_INITIALIZED, { path: this.path });
    }
  }
  async close() {
    if (this.closed) {
      throw errCode__default["default"](new Error('repo is already closed'), errors.ERR_REPO_ALREADY_CLOSED);
    }
    log('closing at: %s', this.path);
    try {
      await this.apiAddr.delete();
    } catch (err) {
      if (err.code !== errors.ERR_REPO_NOT_INITIALIZED && !err.message.startsWith('ENOENT')) {
        throw err;
      }
    }
    await Promise.all([
      this.root,
      this.blocks,
      this.keys,
      this.datastore,
      this.pins.pinstore
    ].map(store => store && store.close()));
    log('unlocking');
    this.closed = true;
    await this._closeLock();
  }
  exists() {
    return this.version.exists();
  }
  async stat() {
    if (this.datastore && this.keys) {
      const [storageMax, blocks, version, datastore, keys] = await Promise.all([
        this._storageMaxStat(),
        this._blockStat(),
        this.version.get(),
        getSize(this.datastore),
        getSize(this.keys)
      ]);
      const size = blocks.size + datastore + keys;
      return {
        repoPath: this.path,
        storageMax,
        version: version,
        numObjects: blocks.count,
        repoSize: size
      };
    }
    throw errCode__default["default"](new Error('repo is not initialized yet'), errors.ERR_REPO_NOT_INITIALIZED, { path: this.path });
  }
  async _isAutoMigrationEnabled() {
    if (this.options.autoMigrate !== undefined) {
      return this.options.autoMigrate;
    }
    let autoMigrateConfig;
    try {
      autoMigrateConfig = await this.config.get(AUTO_MIGRATE_CONFIG_KEY);
    } catch (e) {
      if (e.code === errors.NotFoundError.code) {
        autoMigrateConfig = true;
      } else {
        throw e;
      }
    }
    return autoMigrateConfig;
  }
  async _migrate(toVersion, backends) {
    const currentRepoVersion = await this.version.get();
    if (currentRepoVersion > toVersion) {
      log(`reverting to version ${ toVersion }`);
      return migrator__namespace.revert(this.path, backends, this.options, toVersion, {
        ignoreLock: true,
        onProgress: this.options.onMigrationProgress
      });
    } else {
      log(`migrating to version ${ toVersion }`);
      return migrator__namespace.migrate(this.path, backends, this.options, toVersion, {
        ignoreLock: true,
        onProgress: this.options.onMigrationProgress
      });
    }
  }
  async _storageMaxStat() {
    try {
      const max = await this.config.get('Datastore.StorageMax');
      return BigInt(bytes__default["default"](max));
    } catch (err) {
      return BigInt(noLimit);
    }
  }
  async _blockStat() {
    let count = BigInt(0);
    let size = BigInt(0);
    if (this.blocks) {
      for await (const {key, value} of this.blocks.query({})) {
        count += BigInt(1);
        size += BigInt(value.byteLength);
        size += BigInt(key.bytes.byteLength);
      }
    }
    return {
      count,
      size
    };
  }
}
async function getSize(datastore) {
  let sum = BigInt(0);
  for await (const block of datastore.query({})) {
    sum += BigInt(block.value.byteLength);
    sum += BigInt(block.key.uint8Array().byteLength);
  }
  return sum;
}
function createRepo(path, loadCodec, backends, options) {
  return new Repo(path, loadCodec, backends, options);
}
function buildConfig(_config) {
  _config.Datastore = Object.assign({}, defaultDatastore, _get__default["default"](_config, 'datastore'));
  return _config;
}
function buildDatastoreSpec(_config) {
  const spec = {
    ...defaultDatastore.Spec,
    ..._get__default["default"](_config, 'Datastore.Spec')
  };
  return {
    type: spec.type,
    mounts: spec.mounts.map(mounting => ({
      mountpoint: mounting.mountpoint,
      type: mounting.child.type,
      path: mounting.child.path,
      shardFunc: mounting.child.shardFunc
    }))
  };
}

exports.createRepo = createRepo;
