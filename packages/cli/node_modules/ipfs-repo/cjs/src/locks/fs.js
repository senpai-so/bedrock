'use strict';

Object.defineProperty(exports, '__esModule', { value: true });

var errors = require('../errors.js');
var path = require('path');
var debug = require('debug');
var properLockfile = require('proper-lockfile');

function _interopDefaultLegacy (e) { return e && typeof e === 'object' && 'default' in e ? e : { 'default': e }; }

var path__default = /*#__PURE__*/_interopDefaultLegacy(path);
var debug__default = /*#__PURE__*/_interopDefaultLegacy(debug);

const log = debug__default["default"]('ipfs:repo:lock:fs');
const lockFile = 'repo.lock';
const STALE_TIME = 20000;
const lock = async dir => {
  const file = path__default["default"].join(dir, lockFile);
  log('locking %s', file);
  let release;
  try {
    release = await properLockfile.lock(dir, {
      lockfilePath: file,
      stale: STALE_TIME
    });
  } catch (err) {
    if (err.code === 'ELOCKED') {
      throw new errors.LockExistsError(`Lock already being held for file: ${ file }`);
    } else {
      throw err;
    }
  }
  return { close: release };
};
const locked = dir => {
  const file = path__default["default"].join(dir, lockFile);
  return properLockfile.check(dir, {
    lockfilePath: file,
    stale: STALE_TIME
  });
};
const FSLock = {
  lock,
  locked
};

exports.FSLock = FSLock;
