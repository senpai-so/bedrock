'use strict';

Object.defineProperty(exports, '__esModule', { value: true });

var filter = require('it-filter');
var pushable = require('it-pushable');
var drain = require('it-drain');
var cid = require('multiformats/cid');
var errCode = require('err-code');
var identity = require('multiformats/hashes/identity');

function _interopDefaultLegacy (e) { return e && typeof e === 'object' && 'default' in e ? e : { 'default': e }; }

var filter__default = /*#__PURE__*/_interopDefaultLegacy(filter);
var pushable__default = /*#__PURE__*/_interopDefaultLegacy(pushable);
var drain__default = /*#__PURE__*/_interopDefaultLegacy(drain);
var errCode__default = /*#__PURE__*/_interopDefaultLegacy(errCode);

function createIdStore(store) {
  return {
    open() {
      return store.open();
    },
    close() {
      return store.close();
    },
    query(query, options) {
      return store.query(query, options);
    },
    queryKeys(query, options) {
      return store.queryKeys(query, options);
    },
    async get(cid, options) {
      const extracted = extractContents(cid);
      if (extracted.isIdentity) {
        return Promise.resolve(extracted.digest);
      }
      return store.get(cid, options);
    },
    async *getMany(cids, options) {
      for await (const cid of cids) {
        yield this.get(cid, options);
      }
    },
    async put(cid, buf, options) {
      const {isIdentity} = extractContents(cid);
      if (isIdentity) {
        return;
      }
      await store.put(cid, buf, options);
    },
    async *putMany(pairs, options) {
      const output = pushable__default["default"]();
      const runner = globalThis.process && globalThis.process.nextTick ? globalThis.process.nextTick : globalThis.setImmediate || globalThis.setTimeout;
      runner(async () => {
        try {
          await drain__default["default"](store.putMany(async function* () {
            for await (const {key, value} of pairs) {
              if (!extractContents(key).isIdentity) {
                yield {
                  key,
                  value
                };
              }
              output.push({
                key,
                value
              });
            }
          }()));
          output.end();
        } catch (err) {
          output.end(err);
        }
      });
      yield* output;
    },
    has(cid, options) {
      const {isIdentity} = extractContents(cid);
      if (isIdentity) {
        return Promise.resolve(true);
      }
      return store.has(cid, options);
    },
    delete(cid, options) {
      const {isIdentity} = extractContents(cid);
      if (isIdentity) {
        return Promise.resolve();
      }
      return store.delete(cid, options);
    },
    deleteMany(cids, options) {
      return store.deleteMany(filter__default["default"](cids, cid => !extractContents(cid).isIdentity), options);
    },
    batch() {
      const batch = store.batch();
      return {
        put(cid, buf) {
          const {isIdentity} = extractContents(cid);
          if (isIdentity) {
            return;
          }
          batch.put(cid, buf);
        },
        delete(cid) {
          const {isIdentity} = extractContents(cid);
          if (isIdentity) {
            return;
          }
          batch.delete(cid);
        },
        commit: options => {
          return batch.commit(options);
        }
      };
    }
  };
}
function extractContents(k) {
  const cid$1 = cid.CID.asCID(k);
  if (cid$1 == null) {
    throw errCode__default["default"](new Error('Not a valid cid'), 'ERR_INVALID_CID');
  }
  if (cid$1.multihash.code !== identity.identity.code) {
    return { isIdentity: false };
  }
  return {
    isIdentity: true,
    digest: cid$1.multihash.digest
  };
}

exports.createIdStore = createIdStore;
