'use strict';

Object.defineProperty(exports, '__esModule', { value: true });

var key = require('interface-datastore/key');
var PQueue = require('p-queue');
var _get = require('just-safe-get');
var _set = require('just-safe-set');
var errCode = require('err-code');
var errors = require('./errors.js');
var toString = require('uint8arrays/to-string');
var fromString = require('uint8arrays/from-string');
var level = require('./utils/level.js');

function _interopDefaultLegacy (e) { return e && typeof e === 'object' && 'default' in e ? e : { 'default': e }; }

var PQueue__default = /*#__PURE__*/_interopDefaultLegacy(PQueue);
var _get__default = /*#__PURE__*/_interopDefaultLegacy(_get);
var _set__default = /*#__PURE__*/_interopDefaultLegacy(_set);
var errCode__default = /*#__PURE__*/_interopDefaultLegacy(errCode);

const Queue = PQueue__default["default"].default ? PQueue__default["default"].default : PQueue__default["default"];
const configKey = new key.Key('config');
function config(store) {
  const setQueue = new Queue({ concurrency: 1 });
  const configStore = {
    async getAll(options = {}) {
      const encodedValue = await level.getWithFallback(configKey, store.get.bind(store), store.has.bind(store), store);
      return JSON.parse(toString.toString(encodedValue));
    },
    async get(key, options = {}) {
      if (key == null) {
        throw new errors.NotFoundError(`Key ${ key } does not exist in config`);
      }
      const config = await this.getAll(options);
      const value = _get__default["default"](config, key);
      if (value === undefined) {
        throw new errors.NotFoundError(`Key ${ key } does not exist in config`);
      }
      return value;
    },
    set(key, value, options = {}) {
      if (typeof key !== 'string' && !(key instanceof String)) {
        throw errCode__default["default"](new Error('Invalid key type: ' + typeof key), 'ERR_INVALID_KEY');
      }
      if (value === undefined || value instanceof Uint8Array) {
        throw errCode__default["default"](new Error('Invalid value type: ' + typeof value), 'ERR_INVALID_VALUE');
      }
      return setQueue.add(() => _maybeDoSet({
        key: key,
        value: value
      }, options.signal));
    },
    replace(value, options = {}) {
      if (!value || value instanceof Uint8Array) {
        throw errCode__default["default"](new Error('Invalid value type: ' + typeof value), 'ERR_INVALID_VALUE');
      }
      return setQueue.add(() => _maybeDoSet({
        key: undefined,
        value: value
      }, options.signal));
    },
    async exists() {
      return level.hasWithFallback(configKey, store.has.bind(store), store);
    }
  };
  return configStore;
  async function _maybeDoSet(m, signal) {
    if (signal && signal.aborted) {
      return;
    }
    const key = m.key;
    const value = m.value;
    if (key) {
      const config = await configStore.getAll();
      if (typeof config === 'object' && config !== null) {
        _set__default["default"](config, key, value);
      }
      return _saveAll(config);
    }
    return _saveAll(value);
  }
  function _saveAll(config) {
    const buf = fromString.fromString(JSON.stringify(config, null, 2));
    return store.put(configKey, buf);
  }
}

exports.config = config;
