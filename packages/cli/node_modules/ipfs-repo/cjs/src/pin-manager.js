'use strict';

Object.defineProperty(exports, '__esModule', { value: true });

var cid = require('multiformats/cid');
var errCode = require('err-code');
var debug = require('debug');
var first = require('it-first');
var block = require('multiformats/block');
var cborg = require('cborg');
var dagPb = require('@ipld/dag-pb');
var blockstore = require('./utils/blockstore.js');
var walkDag = require('./utils/walk-dag.js');
var pinTypes = require('./pin-types.js');

function _interopDefaultLegacy (e) { return e && typeof e === 'object' && 'default' in e ? e : { 'default': e }; }

function _interopNamespace(e) {
  if (e && e.__esModule) return e;
  var n = Object.create(null);
  if (e) {
    Object.keys(e).forEach(function (k) {
      if (k !== 'default') {
        var d = Object.getOwnPropertyDescriptor(e, k);
        Object.defineProperty(n, k, d.get ? d : {
          enumerable: true,
          get: function () { return e[k]; }
        });
      }
    });
  }
  n["default"] = e;
  return Object.freeze(n);
}

var errCode__default = /*#__PURE__*/_interopDefaultLegacy(errCode);
var debug__default = /*#__PURE__*/_interopDefaultLegacy(debug);
var first__default = /*#__PURE__*/_interopDefaultLegacy(first);
var cborg__namespace = /*#__PURE__*/_interopNamespace(cborg);
var dagPb__namespace = /*#__PURE__*/_interopNamespace(dagPb);

function invalidPinTypeErr(type) {
  const errMsg = `Invalid type '${ type }', must be one of {direct, indirect, recursive, all}`;
  return errCode__default["default"](new Error(errMsg), 'ERR_INVALID_PIN_TYPE');
}
class PinManager {
  constructor({pinstore, blockstore, loadCodec}) {
    this.pinstore = pinstore;
    this.blockstore = blockstore;
    this.loadCodec = loadCodec;
    this.log = debug__default["default"]('ipfs:repo:pin');
    this.directPins = new Set();
    this.recursivePins = new Set();
  }
  async pinDirectly(cid, options = {}) {
    await this.blockstore.get(cid, options);
    const pin = { depth: 0 };
    if (cid.version !== 0) {
      pin.version = cid.version;
    }
    if (cid.code !== dagPb__namespace.code) {
      pin.codec = cid.code;
    }
    if (options.metadata) {
      pin.metadata = options.metadata;
    }
    return this.pinstore.put(blockstore.cidToKey(cid), cborg__namespace.encode(pin));
  }
  unpin(cid, options) {
    return this.pinstore.delete(blockstore.cidToKey(cid), options);
  }
  async pinRecursively(cid, options = {}) {
    await this.fetchCompleteDag(cid, options);
    const pin = { depth: Infinity };
    if (cid.version !== 0) {
      pin.version = cid.version;
    }
    if (cid.code !== dagPb__namespace.code) {
      pin.codec = cid.code;
    }
    if (options.metadata) {
      pin.metadata = options.metadata;
    }
    await this.pinstore.put(blockstore.cidToKey(cid), cborg__namespace.encode(pin));
  }
  async *directKeys(options) {
    for await (const entry of this.pinstore.query({
        filters: [entry => {
            const pin = cborg__namespace.decode(entry.value);
            return pin.depth === 0;
          }]
      })) {
      const pin = cborg__namespace.decode(entry.value);
      const version = pin.version || 0;
      const codec = pin.codec != null ? pin.codec : dagPb__namespace.code;
      const multihash = blockstore.keyToMultihash(entry.key);
      yield {
        cid: cid.CID.create(version, codec, multihash),
        metadata: pin.metadata
      };
    }
  }
  async *recursiveKeys(options) {
    for await (const entry of this.pinstore.query({
        filters: [entry => {
            const pin = cborg__namespace.decode(entry.value);
            return pin.depth === Infinity;
          }]
      })) {
      const pin = cborg__namespace.decode(entry.value);
      const version = pin.version || 0;
      const codec = pin.codec != null ? pin.codec : dagPb__namespace.code;
      const multihash = blockstore.keyToMultihash(entry.key);
      yield {
        cid: cid.CID.create(version, codec, multihash),
        metadata: pin.metadata
      };
    }
  }
  async *indirectKeys(options) {
    for await (const {cid} of this.recursiveKeys()) {
      for await (const childCid of walkDag.walkDag(cid, this.blockstore, this.loadCodec, options)) {
        const types = [pinTypes.PinTypes.recursive];
        const result = await this.isPinnedWithType(childCid, types);
        if (result.pinned) {
          continue;
        }
        yield childCid;
      }
    }
  }
  async isPinnedWithType(cid, types, options) {
    if (!Array.isArray(types)) {
      types = [types];
    }
    const all = types.includes(pinTypes.PinTypes.all);
    const direct = types.includes(pinTypes.PinTypes.direct);
    const recursive = types.includes(pinTypes.PinTypes.recursive);
    const indirect = types.includes(pinTypes.PinTypes.indirect);
    if (recursive || direct || all) {
      const result = await first__default["default"](this.pinstore.query({
        prefix: blockstore.cidToKey(cid).toString(),
        filters: [entry => {
            if (all) {
              return true;
            }
            const pin = cborg__namespace.decode(entry.value);
            return types.includes(pin.depth === 0 ? pinTypes.PinTypes.direct : pinTypes.PinTypes.recursive);
          }],
        limit: 1
      }));
      if (result) {
        const pin = cborg__namespace.decode(result.value);
        return {
          cid,
          pinned: true,
          reason: pin.depth === 0 ? pinTypes.PinTypes.direct : pinTypes.PinTypes.recursive,
          metadata: pin.metadata
        };
      }
    }
    const self = this;
    async function* findChild(key, source) {
      for await (const {cid: parentCid} of source) {
        for await (const childCid of walkDag.walkDag(parentCid, self.blockstore, self.loadCodec)) {
          if (childCid.equals(key)) {
            yield parentCid;
            return;
          }
        }
      }
    }
    if (all || indirect) {
      const parentCid = await first__default["default"](findChild(cid, this.recursiveKeys()));
      if (parentCid) {
        return {
          cid,
          pinned: true,
          reason: pinTypes.PinTypes.indirect,
          parent: parentCid
        };
      }
    }
    return {
      cid,
      pinned: false
    };
  }
  async fetchCompleteDag(cid, options) {
    const seen = new Set();
    const walkDag = async (cid, options) => {
      if (seen.has(cid.toString())) {
        return;
      }
      seen.add(cid.toString());
      const bytes = await this.blockstore.get(cid, options);
      const codec = await this.loadCodec(cid.code);
      const block$1 = block.createUnsafe({
        bytes,
        cid,
        codec
      });
      await Promise.all([...block$1.links()].map(([, childCid]) => walkDag(childCid, options)));
    };
    await walkDag(cid, options);
  }
  static checkPinType(type) {
    if (typeof type !== 'string' || !Object.keys(pinTypes.PinTypes).includes(type)) {
      throw invalidPinTypeErr(type);
    }
    return true;
  }
}

exports.PinManager = PinManager;
