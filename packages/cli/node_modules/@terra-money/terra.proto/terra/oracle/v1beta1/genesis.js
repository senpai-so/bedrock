"use strict";
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.TobinTax = exports.MissCounter = exports.FeederDelegation = exports.GenesisState = exports.protobufPackage = void 0;
/* eslint-disable */
const long_1 = __importDefault(require("long"));
const minimal_1 = __importDefault(require("protobufjs/minimal"));
const oracle_1 = require("../../../terra/oracle/v1beta1/oracle");
exports.protobufPackage = "terra.oracle.v1beta1";
const baseGenesisState = {};
exports.GenesisState = {
    encode(message, writer = minimal_1.default.Writer.create()) {
        if (message.params !== undefined) {
            oracle_1.Params.encode(message.params, writer.uint32(10).fork()).ldelim();
        }
        for (const v of message.feederDelegations) {
            exports.FeederDelegation.encode(v, writer.uint32(18).fork()).ldelim();
        }
        for (const v of message.exchangeRates) {
            oracle_1.ExchangeRateTuple.encode(v, writer.uint32(26).fork()).ldelim();
        }
        for (const v of message.missCounters) {
            exports.MissCounter.encode(v, writer.uint32(34).fork()).ldelim();
        }
        for (const v of message.aggregateExchangeRatePrevotes) {
            oracle_1.AggregateExchangeRatePrevote.encode(v, writer.uint32(42).fork()).ldelim();
        }
        for (const v of message.aggregateExchangeRateVotes) {
            oracle_1.AggregateExchangeRateVote.encode(v, writer.uint32(50).fork()).ldelim();
        }
        for (const v of message.tobinTaxes) {
            exports.TobinTax.encode(v, writer.uint32(58).fork()).ldelim();
        }
        return writer;
    },
    decode(input, length) {
        const reader = input instanceof minimal_1.default.Reader ? input : new minimal_1.default.Reader(input);
        let end = length === undefined ? reader.len : reader.pos + length;
        const message = Object.assign({}, baseGenesisState);
        message.feederDelegations = [];
        message.exchangeRates = [];
        message.missCounters = [];
        message.aggregateExchangeRatePrevotes = [];
        message.aggregateExchangeRateVotes = [];
        message.tobinTaxes = [];
        while (reader.pos < end) {
            const tag = reader.uint32();
            switch (tag >>> 3) {
                case 1:
                    message.params = oracle_1.Params.decode(reader, reader.uint32());
                    break;
                case 2:
                    message.feederDelegations.push(exports.FeederDelegation.decode(reader, reader.uint32()));
                    break;
                case 3:
                    message.exchangeRates.push(oracle_1.ExchangeRateTuple.decode(reader, reader.uint32()));
                    break;
                case 4:
                    message.missCounters.push(exports.MissCounter.decode(reader, reader.uint32()));
                    break;
                case 5:
                    message.aggregateExchangeRatePrevotes.push(oracle_1.AggregateExchangeRatePrevote.decode(reader, reader.uint32()));
                    break;
                case 6:
                    message.aggregateExchangeRateVotes.push(oracle_1.AggregateExchangeRateVote.decode(reader, reader.uint32()));
                    break;
                case 7:
                    message.tobinTaxes.push(exports.TobinTax.decode(reader, reader.uint32()));
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
            }
        }
        return message;
    },
    fromJSON(object) {
        const message = Object.assign({}, baseGenesisState);
        message.feederDelegations = [];
        message.exchangeRates = [];
        message.missCounters = [];
        message.aggregateExchangeRatePrevotes = [];
        message.aggregateExchangeRateVotes = [];
        message.tobinTaxes = [];
        if (object.params !== undefined && object.params !== null) {
            message.params = oracle_1.Params.fromJSON(object.params);
        }
        else {
            message.params = undefined;
        }
        if (object.feederDelegations !== undefined && object.feederDelegations !== null) {
            for (const e of object.feederDelegations) {
                message.feederDelegations.push(exports.FeederDelegation.fromJSON(e));
            }
        }
        if (object.exchangeRates !== undefined && object.exchangeRates !== null) {
            for (const e of object.exchangeRates) {
                message.exchangeRates.push(oracle_1.ExchangeRateTuple.fromJSON(e));
            }
        }
        if (object.missCounters !== undefined && object.missCounters !== null) {
            for (const e of object.missCounters) {
                message.missCounters.push(exports.MissCounter.fromJSON(e));
            }
        }
        if (object.aggregateExchangeRatePrevotes !== undefined && object.aggregateExchangeRatePrevotes !== null) {
            for (const e of object.aggregateExchangeRatePrevotes) {
                message.aggregateExchangeRatePrevotes.push(oracle_1.AggregateExchangeRatePrevote.fromJSON(e));
            }
        }
        if (object.aggregateExchangeRateVotes !== undefined && object.aggregateExchangeRateVotes !== null) {
            for (const e of object.aggregateExchangeRateVotes) {
                message.aggregateExchangeRateVotes.push(oracle_1.AggregateExchangeRateVote.fromJSON(e));
            }
        }
        if (object.tobinTaxes !== undefined && object.tobinTaxes !== null) {
            for (const e of object.tobinTaxes) {
                message.tobinTaxes.push(exports.TobinTax.fromJSON(e));
            }
        }
        return message;
    },
    toJSON(message) {
        const obj = {};
        message.params !== undefined && (obj.params = message.params ? oracle_1.Params.toJSON(message.params) : undefined);
        if (message.feederDelegations) {
            obj.feederDelegations = message.feederDelegations.map((e) => e ? exports.FeederDelegation.toJSON(e) : undefined);
        }
        else {
            obj.feederDelegations = [];
        }
        if (message.exchangeRates) {
            obj.exchangeRates = message.exchangeRates.map((e) => (e ? oracle_1.ExchangeRateTuple.toJSON(e) : undefined));
        }
        else {
            obj.exchangeRates = [];
        }
        if (message.missCounters) {
            obj.missCounters = message.missCounters.map((e) => (e ? exports.MissCounter.toJSON(e) : undefined));
        }
        else {
            obj.missCounters = [];
        }
        if (message.aggregateExchangeRatePrevotes) {
            obj.aggregateExchangeRatePrevotes = message.aggregateExchangeRatePrevotes.map((e) => e ? oracle_1.AggregateExchangeRatePrevote.toJSON(e) : undefined);
        }
        else {
            obj.aggregateExchangeRatePrevotes = [];
        }
        if (message.aggregateExchangeRateVotes) {
            obj.aggregateExchangeRateVotes = message.aggregateExchangeRateVotes.map((e) => e ? oracle_1.AggregateExchangeRateVote.toJSON(e) : undefined);
        }
        else {
            obj.aggregateExchangeRateVotes = [];
        }
        if (message.tobinTaxes) {
            obj.tobinTaxes = message.tobinTaxes.map((e) => (e ? exports.TobinTax.toJSON(e) : undefined));
        }
        else {
            obj.tobinTaxes = [];
        }
        return obj;
    },
    fromPartial(object) {
        const message = Object.assign({}, baseGenesisState);
        message.feederDelegations = [];
        message.exchangeRates = [];
        message.missCounters = [];
        message.aggregateExchangeRatePrevotes = [];
        message.aggregateExchangeRateVotes = [];
        message.tobinTaxes = [];
        if (object.params !== undefined && object.params !== null) {
            message.params = oracle_1.Params.fromPartial(object.params);
        }
        else {
            message.params = undefined;
        }
        if (object.feederDelegations !== undefined && object.feederDelegations !== null) {
            for (const e of object.feederDelegations) {
                message.feederDelegations.push(exports.FeederDelegation.fromPartial(e));
            }
        }
        if (object.exchangeRates !== undefined && object.exchangeRates !== null) {
            for (const e of object.exchangeRates) {
                message.exchangeRates.push(oracle_1.ExchangeRateTuple.fromPartial(e));
            }
        }
        if (object.missCounters !== undefined && object.missCounters !== null) {
            for (const e of object.missCounters) {
                message.missCounters.push(exports.MissCounter.fromPartial(e));
            }
        }
        if (object.aggregateExchangeRatePrevotes !== undefined && object.aggregateExchangeRatePrevotes !== null) {
            for (const e of object.aggregateExchangeRatePrevotes) {
                message.aggregateExchangeRatePrevotes.push(oracle_1.AggregateExchangeRatePrevote.fromPartial(e));
            }
        }
        if (object.aggregateExchangeRateVotes !== undefined && object.aggregateExchangeRateVotes !== null) {
            for (const e of object.aggregateExchangeRateVotes) {
                message.aggregateExchangeRateVotes.push(oracle_1.AggregateExchangeRateVote.fromPartial(e));
            }
        }
        if (object.tobinTaxes !== undefined && object.tobinTaxes !== null) {
            for (const e of object.tobinTaxes) {
                message.tobinTaxes.push(exports.TobinTax.fromPartial(e));
            }
        }
        return message;
    },
};
const baseFeederDelegation = { feederAddress: "", validatorAddress: "" };
exports.FeederDelegation = {
    encode(message, writer = minimal_1.default.Writer.create()) {
        if (message.feederAddress !== "") {
            writer.uint32(10).string(message.feederAddress);
        }
        if (message.validatorAddress !== "") {
            writer.uint32(18).string(message.validatorAddress);
        }
        return writer;
    },
    decode(input, length) {
        const reader = input instanceof minimal_1.default.Reader ? input : new minimal_1.default.Reader(input);
        let end = length === undefined ? reader.len : reader.pos + length;
        const message = Object.assign({}, baseFeederDelegation);
        while (reader.pos < end) {
            const tag = reader.uint32();
            switch (tag >>> 3) {
                case 1:
                    message.feederAddress = reader.string();
                    break;
                case 2:
                    message.validatorAddress = reader.string();
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
            }
        }
        return message;
    },
    fromJSON(object) {
        const message = Object.assign({}, baseFeederDelegation);
        if (object.feederAddress !== undefined && object.feederAddress !== null) {
            message.feederAddress = String(object.feederAddress);
        }
        else {
            message.feederAddress = "";
        }
        if (object.validatorAddress !== undefined && object.validatorAddress !== null) {
            message.validatorAddress = String(object.validatorAddress);
        }
        else {
            message.validatorAddress = "";
        }
        return message;
    },
    toJSON(message) {
        const obj = {};
        message.feederAddress !== undefined && (obj.feederAddress = message.feederAddress);
        message.validatorAddress !== undefined && (obj.validatorAddress = message.validatorAddress);
        return obj;
    },
    fromPartial(object) {
        const message = Object.assign({}, baseFeederDelegation);
        if (object.feederAddress !== undefined && object.feederAddress !== null) {
            message.feederAddress = object.feederAddress;
        }
        else {
            message.feederAddress = "";
        }
        if (object.validatorAddress !== undefined && object.validatorAddress !== null) {
            message.validatorAddress = object.validatorAddress;
        }
        else {
            message.validatorAddress = "";
        }
        return message;
    },
};
const baseMissCounter = { validatorAddress: "", missCounter: long_1.default.UZERO };
exports.MissCounter = {
    encode(message, writer = minimal_1.default.Writer.create()) {
        if (message.validatorAddress !== "") {
            writer.uint32(10).string(message.validatorAddress);
        }
        if (!message.missCounter.isZero()) {
            writer.uint32(16).uint64(message.missCounter);
        }
        return writer;
    },
    decode(input, length) {
        const reader = input instanceof minimal_1.default.Reader ? input : new minimal_1.default.Reader(input);
        let end = length === undefined ? reader.len : reader.pos + length;
        const message = Object.assign({}, baseMissCounter);
        while (reader.pos < end) {
            const tag = reader.uint32();
            switch (tag >>> 3) {
                case 1:
                    message.validatorAddress = reader.string();
                    break;
                case 2:
                    message.missCounter = reader.uint64();
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
            }
        }
        return message;
    },
    fromJSON(object) {
        const message = Object.assign({}, baseMissCounter);
        if (object.validatorAddress !== undefined && object.validatorAddress !== null) {
            message.validatorAddress = String(object.validatorAddress);
        }
        else {
            message.validatorAddress = "";
        }
        if (object.missCounter !== undefined && object.missCounter !== null) {
            message.missCounter = long_1.default.fromString(object.missCounter);
        }
        else {
            message.missCounter = long_1.default.UZERO;
        }
        return message;
    },
    toJSON(message) {
        const obj = {};
        message.validatorAddress !== undefined && (obj.validatorAddress = message.validatorAddress);
        message.missCounter !== undefined && (obj.missCounter = (message.missCounter || long_1.default.UZERO).toString());
        return obj;
    },
    fromPartial(object) {
        const message = Object.assign({}, baseMissCounter);
        if (object.validatorAddress !== undefined && object.validatorAddress !== null) {
            message.validatorAddress = object.validatorAddress;
        }
        else {
            message.validatorAddress = "";
        }
        if (object.missCounter !== undefined && object.missCounter !== null) {
            message.missCounter = object.missCounter;
        }
        else {
            message.missCounter = long_1.default.UZERO;
        }
        return message;
    },
};
const baseTobinTax = { denom: "", tobinTax: "" };
exports.TobinTax = {
    encode(message, writer = minimal_1.default.Writer.create()) {
        if (message.denom !== "") {
            writer.uint32(10).string(message.denom);
        }
        if (message.tobinTax !== "") {
            writer.uint32(18).string(message.tobinTax);
        }
        return writer;
    },
    decode(input, length) {
        const reader = input instanceof minimal_1.default.Reader ? input : new minimal_1.default.Reader(input);
        let end = length === undefined ? reader.len : reader.pos + length;
        const message = Object.assign({}, baseTobinTax);
        while (reader.pos < end) {
            const tag = reader.uint32();
            switch (tag >>> 3) {
                case 1:
                    message.denom = reader.string();
                    break;
                case 2:
                    message.tobinTax = reader.string();
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
            }
        }
        return message;
    },
    fromJSON(object) {
        const message = Object.assign({}, baseTobinTax);
        if (object.denom !== undefined && object.denom !== null) {
            message.denom = String(object.denom);
        }
        else {
            message.denom = "";
        }
        if (object.tobinTax !== undefined && object.tobinTax !== null) {
            message.tobinTax = String(object.tobinTax);
        }
        else {
            message.tobinTax = "";
        }
        return message;
    },
    toJSON(message) {
        const obj = {};
        message.denom !== undefined && (obj.denom = message.denom);
        message.tobinTax !== undefined && (obj.tobinTax = message.tobinTax);
        return obj;
    },
    fromPartial(object) {
        const message = Object.assign({}, baseTobinTax);
        if (object.denom !== undefined && object.denom !== null) {
            message.denom = object.denom;
        }
        else {
            message.denom = "";
        }
        if (object.tobinTax !== undefined && object.tobinTax !== null) {
            message.tobinTax = object.tobinTax;
        }
        else {
            message.tobinTax = "";
        }
        return message;
    },
};
if (minimal_1.default.util.Long !== long_1.default) {
    minimal_1.default.util.Long = long_1.default;
    minimal_1.default.configure();
}
//# sourceMappingURL=genesis.js.map