"use strict";
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.QueryClientImpl = exports.QueryParamsResponse = exports.QueryParamsRequest = exports.QueryAggregateVotesResponse = exports.QueryAggregateVotesRequest = exports.QueryAggregateVoteResponse = exports.QueryAggregateVoteRequest = exports.QueryAggregatePrevotesResponse = exports.QueryAggregatePrevotesRequest = exports.QueryAggregatePrevoteResponse = exports.QueryAggregatePrevoteRequest = exports.QueryMissCounterResponse = exports.QueryMissCounterRequest = exports.QueryFeederDelegationResponse = exports.QueryFeederDelegationRequest = exports.QueryVoteTargetsResponse = exports.QueryVoteTargetsRequest = exports.QueryActivesResponse = exports.QueryActivesRequest = exports.QueryTobinTaxesResponse = exports.QueryTobinTaxesRequest = exports.QueryTobinTaxResponse = exports.QueryTobinTaxRequest = exports.QueryExchangeRatesResponse = exports.QueryExchangeRatesRequest = exports.QueryExchangeRateResponse = exports.QueryExchangeRateRequest = exports.protobufPackage = void 0;
/* eslint-disable */
const long_1 = __importDefault(require("long"));
const minimal_1 = __importDefault(require("protobufjs/minimal"));
const oracle_1 = require("../../../terra/oracle/v1beta1/oracle");
const coin_1 = require("../../../cosmos/base/v1beta1/coin");
exports.protobufPackage = "terra.oracle.v1beta1";
const baseQueryExchangeRateRequest = { denom: "" };
exports.QueryExchangeRateRequest = {
    encode(message, writer = minimal_1.default.Writer.create()) {
        if (message.denom !== "") {
            writer.uint32(10).string(message.denom);
        }
        return writer;
    },
    decode(input, length) {
        const reader = input instanceof minimal_1.default.Reader ? input : new minimal_1.default.Reader(input);
        let end = length === undefined ? reader.len : reader.pos + length;
        const message = Object.assign({}, baseQueryExchangeRateRequest);
        while (reader.pos < end) {
            const tag = reader.uint32();
            switch (tag >>> 3) {
                case 1:
                    message.denom = reader.string();
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
            }
        }
        return message;
    },
    fromJSON(object) {
        const message = Object.assign({}, baseQueryExchangeRateRequest);
        if (object.denom !== undefined && object.denom !== null) {
            message.denom = String(object.denom);
        }
        else {
            message.denom = "";
        }
        return message;
    },
    toJSON(message) {
        const obj = {};
        message.denom !== undefined && (obj.denom = message.denom);
        return obj;
    },
    fromPartial(object) {
        const message = Object.assign({}, baseQueryExchangeRateRequest);
        if (object.denom !== undefined && object.denom !== null) {
            message.denom = object.denom;
        }
        else {
            message.denom = "";
        }
        return message;
    },
};
const baseQueryExchangeRateResponse = { exchangeRate: "" };
exports.QueryExchangeRateResponse = {
    encode(message, writer = minimal_1.default.Writer.create()) {
        if (message.exchangeRate !== "") {
            writer.uint32(10).string(message.exchangeRate);
        }
        return writer;
    },
    decode(input, length) {
        const reader = input instanceof minimal_1.default.Reader ? input : new minimal_1.default.Reader(input);
        let end = length === undefined ? reader.len : reader.pos + length;
        const message = Object.assign({}, baseQueryExchangeRateResponse);
        while (reader.pos < end) {
            const tag = reader.uint32();
            switch (tag >>> 3) {
                case 1:
                    message.exchangeRate = reader.string();
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
            }
        }
        return message;
    },
    fromJSON(object) {
        const message = Object.assign({}, baseQueryExchangeRateResponse);
        if (object.exchangeRate !== undefined && object.exchangeRate !== null) {
            message.exchangeRate = String(object.exchangeRate);
        }
        else {
            message.exchangeRate = "";
        }
        return message;
    },
    toJSON(message) {
        const obj = {};
        message.exchangeRate !== undefined && (obj.exchangeRate = message.exchangeRate);
        return obj;
    },
    fromPartial(object) {
        const message = Object.assign({}, baseQueryExchangeRateResponse);
        if (object.exchangeRate !== undefined && object.exchangeRate !== null) {
            message.exchangeRate = object.exchangeRate;
        }
        else {
            message.exchangeRate = "";
        }
        return message;
    },
};
const baseQueryExchangeRatesRequest = {};
exports.QueryExchangeRatesRequest = {
    encode(_, writer = minimal_1.default.Writer.create()) {
        return writer;
    },
    decode(input, length) {
        const reader = input instanceof minimal_1.default.Reader ? input : new minimal_1.default.Reader(input);
        let end = length === undefined ? reader.len : reader.pos + length;
        const message = Object.assign({}, baseQueryExchangeRatesRequest);
        while (reader.pos < end) {
            const tag = reader.uint32();
            switch (tag >>> 3) {
                default:
                    reader.skipType(tag & 7);
                    break;
            }
        }
        return message;
    },
    fromJSON(_) {
        const message = Object.assign({}, baseQueryExchangeRatesRequest);
        return message;
    },
    toJSON(_) {
        const obj = {};
        return obj;
    },
    fromPartial(_) {
        const message = Object.assign({}, baseQueryExchangeRatesRequest);
        return message;
    },
};
const baseQueryExchangeRatesResponse = {};
exports.QueryExchangeRatesResponse = {
    encode(message, writer = minimal_1.default.Writer.create()) {
        for (const v of message.exchangeRates) {
            coin_1.DecCoin.encode(v, writer.uint32(10).fork()).ldelim();
        }
        return writer;
    },
    decode(input, length) {
        const reader = input instanceof minimal_1.default.Reader ? input : new minimal_1.default.Reader(input);
        let end = length === undefined ? reader.len : reader.pos + length;
        const message = Object.assign({}, baseQueryExchangeRatesResponse);
        message.exchangeRates = [];
        while (reader.pos < end) {
            const tag = reader.uint32();
            switch (tag >>> 3) {
                case 1:
                    message.exchangeRates.push(coin_1.DecCoin.decode(reader, reader.uint32()));
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
            }
        }
        return message;
    },
    fromJSON(object) {
        const message = Object.assign({}, baseQueryExchangeRatesResponse);
        message.exchangeRates = [];
        if (object.exchangeRates !== undefined && object.exchangeRates !== null) {
            for (const e of object.exchangeRates) {
                message.exchangeRates.push(coin_1.DecCoin.fromJSON(e));
            }
        }
        return message;
    },
    toJSON(message) {
        const obj = {};
        if (message.exchangeRates) {
            obj.exchangeRates = message.exchangeRates.map((e) => (e ? coin_1.DecCoin.toJSON(e) : undefined));
        }
        else {
            obj.exchangeRates = [];
        }
        return obj;
    },
    fromPartial(object) {
        const message = Object.assign({}, baseQueryExchangeRatesResponse);
        message.exchangeRates = [];
        if (object.exchangeRates !== undefined && object.exchangeRates !== null) {
            for (const e of object.exchangeRates) {
                message.exchangeRates.push(coin_1.DecCoin.fromPartial(e));
            }
        }
        return message;
    },
};
const baseQueryTobinTaxRequest = { denom: "" };
exports.QueryTobinTaxRequest = {
    encode(message, writer = minimal_1.default.Writer.create()) {
        if (message.denom !== "") {
            writer.uint32(10).string(message.denom);
        }
        return writer;
    },
    decode(input, length) {
        const reader = input instanceof minimal_1.default.Reader ? input : new minimal_1.default.Reader(input);
        let end = length === undefined ? reader.len : reader.pos + length;
        const message = Object.assign({}, baseQueryTobinTaxRequest);
        while (reader.pos < end) {
            const tag = reader.uint32();
            switch (tag >>> 3) {
                case 1:
                    message.denom = reader.string();
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
            }
        }
        return message;
    },
    fromJSON(object) {
        const message = Object.assign({}, baseQueryTobinTaxRequest);
        if (object.denom !== undefined && object.denom !== null) {
            message.denom = String(object.denom);
        }
        else {
            message.denom = "";
        }
        return message;
    },
    toJSON(message) {
        const obj = {};
        message.denom !== undefined && (obj.denom = message.denom);
        return obj;
    },
    fromPartial(object) {
        const message = Object.assign({}, baseQueryTobinTaxRequest);
        if (object.denom !== undefined && object.denom !== null) {
            message.denom = object.denom;
        }
        else {
            message.denom = "";
        }
        return message;
    },
};
const baseQueryTobinTaxResponse = { tobinTax: "" };
exports.QueryTobinTaxResponse = {
    encode(message, writer = minimal_1.default.Writer.create()) {
        if (message.tobinTax !== "") {
            writer.uint32(10).string(message.tobinTax);
        }
        return writer;
    },
    decode(input, length) {
        const reader = input instanceof minimal_1.default.Reader ? input : new minimal_1.default.Reader(input);
        let end = length === undefined ? reader.len : reader.pos + length;
        const message = Object.assign({}, baseQueryTobinTaxResponse);
        while (reader.pos < end) {
            const tag = reader.uint32();
            switch (tag >>> 3) {
                case 1:
                    message.tobinTax = reader.string();
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
            }
        }
        return message;
    },
    fromJSON(object) {
        const message = Object.assign({}, baseQueryTobinTaxResponse);
        if (object.tobinTax !== undefined && object.tobinTax !== null) {
            message.tobinTax = String(object.tobinTax);
        }
        else {
            message.tobinTax = "";
        }
        return message;
    },
    toJSON(message) {
        const obj = {};
        message.tobinTax !== undefined && (obj.tobinTax = message.tobinTax);
        return obj;
    },
    fromPartial(object) {
        const message = Object.assign({}, baseQueryTobinTaxResponse);
        if (object.tobinTax !== undefined && object.tobinTax !== null) {
            message.tobinTax = object.tobinTax;
        }
        else {
            message.tobinTax = "";
        }
        return message;
    },
};
const baseQueryTobinTaxesRequest = {};
exports.QueryTobinTaxesRequest = {
    encode(_, writer = minimal_1.default.Writer.create()) {
        return writer;
    },
    decode(input, length) {
        const reader = input instanceof minimal_1.default.Reader ? input : new minimal_1.default.Reader(input);
        let end = length === undefined ? reader.len : reader.pos + length;
        const message = Object.assign({}, baseQueryTobinTaxesRequest);
        while (reader.pos < end) {
            const tag = reader.uint32();
            switch (tag >>> 3) {
                default:
                    reader.skipType(tag & 7);
                    break;
            }
        }
        return message;
    },
    fromJSON(_) {
        const message = Object.assign({}, baseQueryTobinTaxesRequest);
        return message;
    },
    toJSON(_) {
        const obj = {};
        return obj;
    },
    fromPartial(_) {
        const message = Object.assign({}, baseQueryTobinTaxesRequest);
        return message;
    },
};
const baseQueryTobinTaxesResponse = {};
exports.QueryTobinTaxesResponse = {
    encode(message, writer = minimal_1.default.Writer.create()) {
        for (const v of message.tobinTaxes) {
            oracle_1.Denom.encode(v, writer.uint32(10).fork()).ldelim();
        }
        return writer;
    },
    decode(input, length) {
        const reader = input instanceof minimal_1.default.Reader ? input : new minimal_1.default.Reader(input);
        let end = length === undefined ? reader.len : reader.pos + length;
        const message = Object.assign({}, baseQueryTobinTaxesResponse);
        message.tobinTaxes = [];
        while (reader.pos < end) {
            const tag = reader.uint32();
            switch (tag >>> 3) {
                case 1:
                    message.tobinTaxes.push(oracle_1.Denom.decode(reader, reader.uint32()));
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
            }
        }
        return message;
    },
    fromJSON(object) {
        const message = Object.assign({}, baseQueryTobinTaxesResponse);
        message.tobinTaxes = [];
        if (object.tobinTaxes !== undefined && object.tobinTaxes !== null) {
            for (const e of object.tobinTaxes) {
                message.tobinTaxes.push(oracle_1.Denom.fromJSON(e));
            }
        }
        return message;
    },
    toJSON(message) {
        const obj = {};
        if (message.tobinTaxes) {
            obj.tobinTaxes = message.tobinTaxes.map((e) => (e ? oracle_1.Denom.toJSON(e) : undefined));
        }
        else {
            obj.tobinTaxes = [];
        }
        return obj;
    },
    fromPartial(object) {
        const message = Object.assign({}, baseQueryTobinTaxesResponse);
        message.tobinTaxes = [];
        if (object.tobinTaxes !== undefined && object.tobinTaxes !== null) {
            for (const e of object.tobinTaxes) {
                message.tobinTaxes.push(oracle_1.Denom.fromPartial(e));
            }
        }
        return message;
    },
};
const baseQueryActivesRequest = {};
exports.QueryActivesRequest = {
    encode(_, writer = minimal_1.default.Writer.create()) {
        return writer;
    },
    decode(input, length) {
        const reader = input instanceof minimal_1.default.Reader ? input : new minimal_1.default.Reader(input);
        let end = length === undefined ? reader.len : reader.pos + length;
        const message = Object.assign({}, baseQueryActivesRequest);
        while (reader.pos < end) {
            const tag = reader.uint32();
            switch (tag >>> 3) {
                default:
                    reader.skipType(tag & 7);
                    break;
            }
        }
        return message;
    },
    fromJSON(_) {
        const message = Object.assign({}, baseQueryActivesRequest);
        return message;
    },
    toJSON(_) {
        const obj = {};
        return obj;
    },
    fromPartial(_) {
        const message = Object.assign({}, baseQueryActivesRequest);
        return message;
    },
};
const baseQueryActivesResponse = { actives: "" };
exports.QueryActivesResponse = {
    encode(message, writer = minimal_1.default.Writer.create()) {
        for (const v of message.actives) {
            writer.uint32(10).string(v);
        }
        return writer;
    },
    decode(input, length) {
        const reader = input instanceof minimal_1.default.Reader ? input : new minimal_1.default.Reader(input);
        let end = length === undefined ? reader.len : reader.pos + length;
        const message = Object.assign({}, baseQueryActivesResponse);
        message.actives = [];
        while (reader.pos < end) {
            const tag = reader.uint32();
            switch (tag >>> 3) {
                case 1:
                    message.actives.push(reader.string());
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
            }
        }
        return message;
    },
    fromJSON(object) {
        const message = Object.assign({}, baseQueryActivesResponse);
        message.actives = [];
        if (object.actives !== undefined && object.actives !== null) {
            for (const e of object.actives) {
                message.actives.push(String(e));
            }
        }
        return message;
    },
    toJSON(message) {
        const obj = {};
        if (message.actives) {
            obj.actives = message.actives.map((e) => e);
        }
        else {
            obj.actives = [];
        }
        return obj;
    },
    fromPartial(object) {
        const message = Object.assign({}, baseQueryActivesResponse);
        message.actives = [];
        if (object.actives !== undefined && object.actives !== null) {
            for (const e of object.actives) {
                message.actives.push(e);
            }
        }
        return message;
    },
};
const baseQueryVoteTargetsRequest = {};
exports.QueryVoteTargetsRequest = {
    encode(_, writer = minimal_1.default.Writer.create()) {
        return writer;
    },
    decode(input, length) {
        const reader = input instanceof minimal_1.default.Reader ? input : new minimal_1.default.Reader(input);
        let end = length === undefined ? reader.len : reader.pos + length;
        const message = Object.assign({}, baseQueryVoteTargetsRequest);
        while (reader.pos < end) {
            const tag = reader.uint32();
            switch (tag >>> 3) {
                default:
                    reader.skipType(tag & 7);
                    break;
            }
        }
        return message;
    },
    fromJSON(_) {
        const message = Object.assign({}, baseQueryVoteTargetsRequest);
        return message;
    },
    toJSON(_) {
        const obj = {};
        return obj;
    },
    fromPartial(_) {
        const message = Object.assign({}, baseQueryVoteTargetsRequest);
        return message;
    },
};
const baseQueryVoteTargetsResponse = { voteTargets: "" };
exports.QueryVoteTargetsResponse = {
    encode(message, writer = minimal_1.default.Writer.create()) {
        for (const v of message.voteTargets) {
            writer.uint32(10).string(v);
        }
        return writer;
    },
    decode(input, length) {
        const reader = input instanceof minimal_1.default.Reader ? input : new minimal_1.default.Reader(input);
        let end = length === undefined ? reader.len : reader.pos + length;
        const message = Object.assign({}, baseQueryVoteTargetsResponse);
        message.voteTargets = [];
        while (reader.pos < end) {
            const tag = reader.uint32();
            switch (tag >>> 3) {
                case 1:
                    message.voteTargets.push(reader.string());
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
            }
        }
        return message;
    },
    fromJSON(object) {
        const message = Object.assign({}, baseQueryVoteTargetsResponse);
        message.voteTargets = [];
        if (object.voteTargets !== undefined && object.voteTargets !== null) {
            for (const e of object.voteTargets) {
                message.voteTargets.push(String(e));
            }
        }
        return message;
    },
    toJSON(message) {
        const obj = {};
        if (message.voteTargets) {
            obj.voteTargets = message.voteTargets.map((e) => e);
        }
        else {
            obj.voteTargets = [];
        }
        return obj;
    },
    fromPartial(object) {
        const message = Object.assign({}, baseQueryVoteTargetsResponse);
        message.voteTargets = [];
        if (object.voteTargets !== undefined && object.voteTargets !== null) {
            for (const e of object.voteTargets) {
                message.voteTargets.push(e);
            }
        }
        return message;
    },
};
const baseQueryFeederDelegationRequest = { validatorAddr: "" };
exports.QueryFeederDelegationRequest = {
    encode(message, writer = minimal_1.default.Writer.create()) {
        if (message.validatorAddr !== "") {
            writer.uint32(10).string(message.validatorAddr);
        }
        return writer;
    },
    decode(input, length) {
        const reader = input instanceof minimal_1.default.Reader ? input : new minimal_1.default.Reader(input);
        let end = length === undefined ? reader.len : reader.pos + length;
        const message = Object.assign({}, baseQueryFeederDelegationRequest);
        while (reader.pos < end) {
            const tag = reader.uint32();
            switch (tag >>> 3) {
                case 1:
                    message.validatorAddr = reader.string();
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
            }
        }
        return message;
    },
    fromJSON(object) {
        const message = Object.assign({}, baseQueryFeederDelegationRequest);
        if (object.validatorAddr !== undefined && object.validatorAddr !== null) {
            message.validatorAddr = String(object.validatorAddr);
        }
        else {
            message.validatorAddr = "";
        }
        return message;
    },
    toJSON(message) {
        const obj = {};
        message.validatorAddr !== undefined && (obj.validatorAddr = message.validatorAddr);
        return obj;
    },
    fromPartial(object) {
        const message = Object.assign({}, baseQueryFeederDelegationRequest);
        if (object.validatorAddr !== undefined && object.validatorAddr !== null) {
            message.validatorAddr = object.validatorAddr;
        }
        else {
            message.validatorAddr = "";
        }
        return message;
    },
};
const baseQueryFeederDelegationResponse = { feederAddr: "" };
exports.QueryFeederDelegationResponse = {
    encode(message, writer = minimal_1.default.Writer.create()) {
        if (message.feederAddr !== "") {
            writer.uint32(10).string(message.feederAddr);
        }
        return writer;
    },
    decode(input, length) {
        const reader = input instanceof minimal_1.default.Reader ? input : new minimal_1.default.Reader(input);
        let end = length === undefined ? reader.len : reader.pos + length;
        const message = Object.assign({}, baseQueryFeederDelegationResponse);
        while (reader.pos < end) {
            const tag = reader.uint32();
            switch (tag >>> 3) {
                case 1:
                    message.feederAddr = reader.string();
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
            }
        }
        return message;
    },
    fromJSON(object) {
        const message = Object.assign({}, baseQueryFeederDelegationResponse);
        if (object.feederAddr !== undefined && object.feederAddr !== null) {
            message.feederAddr = String(object.feederAddr);
        }
        else {
            message.feederAddr = "";
        }
        return message;
    },
    toJSON(message) {
        const obj = {};
        message.feederAddr !== undefined && (obj.feederAddr = message.feederAddr);
        return obj;
    },
    fromPartial(object) {
        const message = Object.assign({}, baseQueryFeederDelegationResponse);
        if (object.feederAddr !== undefined && object.feederAddr !== null) {
            message.feederAddr = object.feederAddr;
        }
        else {
            message.feederAddr = "";
        }
        return message;
    },
};
const baseQueryMissCounterRequest = { validatorAddr: "" };
exports.QueryMissCounterRequest = {
    encode(message, writer = minimal_1.default.Writer.create()) {
        if (message.validatorAddr !== "") {
            writer.uint32(10).string(message.validatorAddr);
        }
        return writer;
    },
    decode(input, length) {
        const reader = input instanceof minimal_1.default.Reader ? input : new minimal_1.default.Reader(input);
        let end = length === undefined ? reader.len : reader.pos + length;
        const message = Object.assign({}, baseQueryMissCounterRequest);
        while (reader.pos < end) {
            const tag = reader.uint32();
            switch (tag >>> 3) {
                case 1:
                    message.validatorAddr = reader.string();
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
            }
        }
        return message;
    },
    fromJSON(object) {
        const message = Object.assign({}, baseQueryMissCounterRequest);
        if (object.validatorAddr !== undefined && object.validatorAddr !== null) {
            message.validatorAddr = String(object.validatorAddr);
        }
        else {
            message.validatorAddr = "";
        }
        return message;
    },
    toJSON(message) {
        const obj = {};
        message.validatorAddr !== undefined && (obj.validatorAddr = message.validatorAddr);
        return obj;
    },
    fromPartial(object) {
        const message = Object.assign({}, baseQueryMissCounterRequest);
        if (object.validatorAddr !== undefined && object.validatorAddr !== null) {
            message.validatorAddr = object.validatorAddr;
        }
        else {
            message.validatorAddr = "";
        }
        return message;
    },
};
const baseQueryMissCounterResponse = { missCounter: long_1.default.UZERO };
exports.QueryMissCounterResponse = {
    encode(message, writer = minimal_1.default.Writer.create()) {
        if (!message.missCounter.isZero()) {
            writer.uint32(8).uint64(message.missCounter);
        }
        return writer;
    },
    decode(input, length) {
        const reader = input instanceof minimal_1.default.Reader ? input : new minimal_1.default.Reader(input);
        let end = length === undefined ? reader.len : reader.pos + length;
        const message = Object.assign({}, baseQueryMissCounterResponse);
        while (reader.pos < end) {
            const tag = reader.uint32();
            switch (tag >>> 3) {
                case 1:
                    message.missCounter = reader.uint64();
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
            }
        }
        return message;
    },
    fromJSON(object) {
        const message = Object.assign({}, baseQueryMissCounterResponse);
        if (object.missCounter !== undefined && object.missCounter !== null) {
            message.missCounter = long_1.default.fromString(object.missCounter);
        }
        else {
            message.missCounter = long_1.default.UZERO;
        }
        return message;
    },
    toJSON(message) {
        const obj = {};
        message.missCounter !== undefined && (obj.missCounter = (message.missCounter || long_1.default.UZERO).toString());
        return obj;
    },
    fromPartial(object) {
        const message = Object.assign({}, baseQueryMissCounterResponse);
        if (object.missCounter !== undefined && object.missCounter !== null) {
            message.missCounter = object.missCounter;
        }
        else {
            message.missCounter = long_1.default.UZERO;
        }
        return message;
    },
};
const baseQueryAggregatePrevoteRequest = { validatorAddr: "" };
exports.QueryAggregatePrevoteRequest = {
    encode(message, writer = minimal_1.default.Writer.create()) {
        if (message.validatorAddr !== "") {
            writer.uint32(10).string(message.validatorAddr);
        }
        return writer;
    },
    decode(input, length) {
        const reader = input instanceof minimal_1.default.Reader ? input : new minimal_1.default.Reader(input);
        let end = length === undefined ? reader.len : reader.pos + length;
        const message = Object.assign({}, baseQueryAggregatePrevoteRequest);
        while (reader.pos < end) {
            const tag = reader.uint32();
            switch (tag >>> 3) {
                case 1:
                    message.validatorAddr = reader.string();
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
            }
        }
        return message;
    },
    fromJSON(object) {
        const message = Object.assign({}, baseQueryAggregatePrevoteRequest);
        if (object.validatorAddr !== undefined && object.validatorAddr !== null) {
            message.validatorAddr = String(object.validatorAddr);
        }
        else {
            message.validatorAddr = "";
        }
        return message;
    },
    toJSON(message) {
        const obj = {};
        message.validatorAddr !== undefined && (obj.validatorAddr = message.validatorAddr);
        return obj;
    },
    fromPartial(object) {
        const message = Object.assign({}, baseQueryAggregatePrevoteRequest);
        if (object.validatorAddr !== undefined && object.validatorAddr !== null) {
            message.validatorAddr = object.validatorAddr;
        }
        else {
            message.validatorAddr = "";
        }
        return message;
    },
};
const baseQueryAggregatePrevoteResponse = {};
exports.QueryAggregatePrevoteResponse = {
    encode(message, writer = minimal_1.default.Writer.create()) {
        if (message.aggregatePrevote !== undefined) {
            oracle_1.AggregateExchangeRatePrevote.encode(message.aggregatePrevote, writer.uint32(10).fork()).ldelim();
        }
        return writer;
    },
    decode(input, length) {
        const reader = input instanceof minimal_1.default.Reader ? input : new minimal_1.default.Reader(input);
        let end = length === undefined ? reader.len : reader.pos + length;
        const message = Object.assign({}, baseQueryAggregatePrevoteResponse);
        while (reader.pos < end) {
            const tag = reader.uint32();
            switch (tag >>> 3) {
                case 1:
                    message.aggregatePrevote = oracle_1.AggregateExchangeRatePrevote.decode(reader, reader.uint32());
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
            }
        }
        return message;
    },
    fromJSON(object) {
        const message = Object.assign({}, baseQueryAggregatePrevoteResponse);
        if (object.aggregatePrevote !== undefined && object.aggregatePrevote !== null) {
            message.aggregatePrevote = oracle_1.AggregateExchangeRatePrevote.fromJSON(object.aggregatePrevote);
        }
        else {
            message.aggregatePrevote = undefined;
        }
        return message;
    },
    toJSON(message) {
        const obj = {};
        message.aggregatePrevote !== undefined &&
            (obj.aggregatePrevote = message.aggregatePrevote
                ? oracle_1.AggregateExchangeRatePrevote.toJSON(message.aggregatePrevote)
                : undefined);
        return obj;
    },
    fromPartial(object) {
        const message = Object.assign({}, baseQueryAggregatePrevoteResponse);
        if (object.aggregatePrevote !== undefined && object.aggregatePrevote !== null) {
            message.aggregatePrevote = oracle_1.AggregateExchangeRatePrevote.fromPartial(object.aggregatePrevote);
        }
        else {
            message.aggregatePrevote = undefined;
        }
        return message;
    },
};
const baseQueryAggregatePrevotesRequest = {};
exports.QueryAggregatePrevotesRequest = {
    encode(_, writer = minimal_1.default.Writer.create()) {
        return writer;
    },
    decode(input, length) {
        const reader = input instanceof minimal_1.default.Reader ? input : new minimal_1.default.Reader(input);
        let end = length === undefined ? reader.len : reader.pos + length;
        const message = Object.assign({}, baseQueryAggregatePrevotesRequest);
        while (reader.pos < end) {
            const tag = reader.uint32();
            switch (tag >>> 3) {
                default:
                    reader.skipType(tag & 7);
                    break;
            }
        }
        return message;
    },
    fromJSON(_) {
        const message = Object.assign({}, baseQueryAggregatePrevotesRequest);
        return message;
    },
    toJSON(_) {
        const obj = {};
        return obj;
    },
    fromPartial(_) {
        const message = Object.assign({}, baseQueryAggregatePrevotesRequest);
        return message;
    },
};
const baseQueryAggregatePrevotesResponse = {};
exports.QueryAggregatePrevotesResponse = {
    encode(message, writer = minimal_1.default.Writer.create()) {
        for (const v of message.aggregatePrevotes) {
            oracle_1.AggregateExchangeRatePrevote.encode(v, writer.uint32(10).fork()).ldelim();
        }
        return writer;
    },
    decode(input, length) {
        const reader = input instanceof minimal_1.default.Reader ? input : new minimal_1.default.Reader(input);
        let end = length === undefined ? reader.len : reader.pos + length;
        const message = Object.assign({}, baseQueryAggregatePrevotesResponse);
        message.aggregatePrevotes = [];
        while (reader.pos < end) {
            const tag = reader.uint32();
            switch (tag >>> 3) {
                case 1:
                    message.aggregatePrevotes.push(oracle_1.AggregateExchangeRatePrevote.decode(reader, reader.uint32()));
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
            }
        }
        return message;
    },
    fromJSON(object) {
        const message = Object.assign({}, baseQueryAggregatePrevotesResponse);
        message.aggregatePrevotes = [];
        if (object.aggregatePrevotes !== undefined && object.aggregatePrevotes !== null) {
            for (const e of object.aggregatePrevotes) {
                message.aggregatePrevotes.push(oracle_1.AggregateExchangeRatePrevote.fromJSON(e));
            }
        }
        return message;
    },
    toJSON(message) {
        const obj = {};
        if (message.aggregatePrevotes) {
            obj.aggregatePrevotes = message.aggregatePrevotes.map((e) => e ? oracle_1.AggregateExchangeRatePrevote.toJSON(e) : undefined);
        }
        else {
            obj.aggregatePrevotes = [];
        }
        return obj;
    },
    fromPartial(object) {
        const message = Object.assign({}, baseQueryAggregatePrevotesResponse);
        message.aggregatePrevotes = [];
        if (object.aggregatePrevotes !== undefined && object.aggregatePrevotes !== null) {
            for (const e of object.aggregatePrevotes) {
                message.aggregatePrevotes.push(oracle_1.AggregateExchangeRatePrevote.fromPartial(e));
            }
        }
        return message;
    },
};
const baseQueryAggregateVoteRequest = { validatorAddr: "" };
exports.QueryAggregateVoteRequest = {
    encode(message, writer = minimal_1.default.Writer.create()) {
        if (message.validatorAddr !== "") {
            writer.uint32(10).string(message.validatorAddr);
        }
        return writer;
    },
    decode(input, length) {
        const reader = input instanceof minimal_1.default.Reader ? input : new minimal_1.default.Reader(input);
        let end = length === undefined ? reader.len : reader.pos + length;
        const message = Object.assign({}, baseQueryAggregateVoteRequest);
        while (reader.pos < end) {
            const tag = reader.uint32();
            switch (tag >>> 3) {
                case 1:
                    message.validatorAddr = reader.string();
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
            }
        }
        return message;
    },
    fromJSON(object) {
        const message = Object.assign({}, baseQueryAggregateVoteRequest);
        if (object.validatorAddr !== undefined && object.validatorAddr !== null) {
            message.validatorAddr = String(object.validatorAddr);
        }
        else {
            message.validatorAddr = "";
        }
        return message;
    },
    toJSON(message) {
        const obj = {};
        message.validatorAddr !== undefined && (obj.validatorAddr = message.validatorAddr);
        return obj;
    },
    fromPartial(object) {
        const message = Object.assign({}, baseQueryAggregateVoteRequest);
        if (object.validatorAddr !== undefined && object.validatorAddr !== null) {
            message.validatorAddr = object.validatorAddr;
        }
        else {
            message.validatorAddr = "";
        }
        return message;
    },
};
const baseQueryAggregateVoteResponse = {};
exports.QueryAggregateVoteResponse = {
    encode(message, writer = minimal_1.default.Writer.create()) {
        if (message.aggregateVote !== undefined) {
            oracle_1.AggregateExchangeRateVote.encode(message.aggregateVote, writer.uint32(10).fork()).ldelim();
        }
        return writer;
    },
    decode(input, length) {
        const reader = input instanceof minimal_1.default.Reader ? input : new minimal_1.default.Reader(input);
        let end = length === undefined ? reader.len : reader.pos + length;
        const message = Object.assign({}, baseQueryAggregateVoteResponse);
        while (reader.pos < end) {
            const tag = reader.uint32();
            switch (tag >>> 3) {
                case 1:
                    message.aggregateVote = oracle_1.AggregateExchangeRateVote.decode(reader, reader.uint32());
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
            }
        }
        return message;
    },
    fromJSON(object) {
        const message = Object.assign({}, baseQueryAggregateVoteResponse);
        if (object.aggregateVote !== undefined && object.aggregateVote !== null) {
            message.aggregateVote = oracle_1.AggregateExchangeRateVote.fromJSON(object.aggregateVote);
        }
        else {
            message.aggregateVote = undefined;
        }
        return message;
    },
    toJSON(message) {
        const obj = {};
        message.aggregateVote !== undefined &&
            (obj.aggregateVote = message.aggregateVote
                ? oracle_1.AggregateExchangeRateVote.toJSON(message.aggregateVote)
                : undefined);
        return obj;
    },
    fromPartial(object) {
        const message = Object.assign({}, baseQueryAggregateVoteResponse);
        if (object.aggregateVote !== undefined && object.aggregateVote !== null) {
            message.aggregateVote = oracle_1.AggregateExchangeRateVote.fromPartial(object.aggregateVote);
        }
        else {
            message.aggregateVote = undefined;
        }
        return message;
    },
};
const baseQueryAggregateVotesRequest = {};
exports.QueryAggregateVotesRequest = {
    encode(_, writer = minimal_1.default.Writer.create()) {
        return writer;
    },
    decode(input, length) {
        const reader = input instanceof minimal_1.default.Reader ? input : new minimal_1.default.Reader(input);
        let end = length === undefined ? reader.len : reader.pos + length;
        const message = Object.assign({}, baseQueryAggregateVotesRequest);
        while (reader.pos < end) {
            const tag = reader.uint32();
            switch (tag >>> 3) {
                default:
                    reader.skipType(tag & 7);
                    break;
            }
        }
        return message;
    },
    fromJSON(_) {
        const message = Object.assign({}, baseQueryAggregateVotesRequest);
        return message;
    },
    toJSON(_) {
        const obj = {};
        return obj;
    },
    fromPartial(_) {
        const message = Object.assign({}, baseQueryAggregateVotesRequest);
        return message;
    },
};
const baseQueryAggregateVotesResponse = {};
exports.QueryAggregateVotesResponse = {
    encode(message, writer = minimal_1.default.Writer.create()) {
        for (const v of message.aggregateVotes) {
            oracle_1.AggregateExchangeRateVote.encode(v, writer.uint32(10).fork()).ldelim();
        }
        return writer;
    },
    decode(input, length) {
        const reader = input instanceof minimal_1.default.Reader ? input : new minimal_1.default.Reader(input);
        let end = length === undefined ? reader.len : reader.pos + length;
        const message = Object.assign({}, baseQueryAggregateVotesResponse);
        message.aggregateVotes = [];
        while (reader.pos < end) {
            const tag = reader.uint32();
            switch (tag >>> 3) {
                case 1:
                    message.aggregateVotes.push(oracle_1.AggregateExchangeRateVote.decode(reader, reader.uint32()));
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
            }
        }
        return message;
    },
    fromJSON(object) {
        const message = Object.assign({}, baseQueryAggregateVotesResponse);
        message.aggregateVotes = [];
        if (object.aggregateVotes !== undefined && object.aggregateVotes !== null) {
            for (const e of object.aggregateVotes) {
                message.aggregateVotes.push(oracle_1.AggregateExchangeRateVote.fromJSON(e));
            }
        }
        return message;
    },
    toJSON(message) {
        const obj = {};
        if (message.aggregateVotes) {
            obj.aggregateVotes = message.aggregateVotes.map((e) => e ? oracle_1.AggregateExchangeRateVote.toJSON(e) : undefined);
        }
        else {
            obj.aggregateVotes = [];
        }
        return obj;
    },
    fromPartial(object) {
        const message = Object.assign({}, baseQueryAggregateVotesResponse);
        message.aggregateVotes = [];
        if (object.aggregateVotes !== undefined && object.aggregateVotes !== null) {
            for (const e of object.aggregateVotes) {
                message.aggregateVotes.push(oracle_1.AggregateExchangeRateVote.fromPartial(e));
            }
        }
        return message;
    },
};
const baseQueryParamsRequest = {};
exports.QueryParamsRequest = {
    encode(_, writer = minimal_1.default.Writer.create()) {
        return writer;
    },
    decode(input, length) {
        const reader = input instanceof minimal_1.default.Reader ? input : new minimal_1.default.Reader(input);
        let end = length === undefined ? reader.len : reader.pos + length;
        const message = Object.assign({}, baseQueryParamsRequest);
        while (reader.pos < end) {
            const tag = reader.uint32();
            switch (tag >>> 3) {
                default:
                    reader.skipType(tag & 7);
                    break;
            }
        }
        return message;
    },
    fromJSON(_) {
        const message = Object.assign({}, baseQueryParamsRequest);
        return message;
    },
    toJSON(_) {
        const obj = {};
        return obj;
    },
    fromPartial(_) {
        const message = Object.assign({}, baseQueryParamsRequest);
        return message;
    },
};
const baseQueryParamsResponse = {};
exports.QueryParamsResponse = {
    encode(message, writer = minimal_1.default.Writer.create()) {
        if (message.params !== undefined) {
            oracle_1.Params.encode(message.params, writer.uint32(10).fork()).ldelim();
        }
        return writer;
    },
    decode(input, length) {
        const reader = input instanceof minimal_1.default.Reader ? input : new minimal_1.default.Reader(input);
        let end = length === undefined ? reader.len : reader.pos + length;
        const message = Object.assign({}, baseQueryParamsResponse);
        while (reader.pos < end) {
            const tag = reader.uint32();
            switch (tag >>> 3) {
                case 1:
                    message.params = oracle_1.Params.decode(reader, reader.uint32());
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
            }
        }
        return message;
    },
    fromJSON(object) {
        const message = Object.assign({}, baseQueryParamsResponse);
        if (object.params !== undefined && object.params !== null) {
            message.params = oracle_1.Params.fromJSON(object.params);
        }
        else {
            message.params = undefined;
        }
        return message;
    },
    toJSON(message) {
        const obj = {};
        message.params !== undefined && (obj.params = message.params ? oracle_1.Params.toJSON(message.params) : undefined);
        return obj;
    },
    fromPartial(object) {
        const message = Object.assign({}, baseQueryParamsResponse);
        if (object.params !== undefined && object.params !== null) {
            message.params = oracle_1.Params.fromPartial(object.params);
        }
        else {
            message.params = undefined;
        }
        return message;
    },
};
class QueryClientImpl {
    constructor(rpc) {
        this.rpc = rpc;
        this.ExchangeRate = this.ExchangeRate.bind(this);
        this.ExchangeRates = this.ExchangeRates.bind(this);
        this.TobinTax = this.TobinTax.bind(this);
        this.TobinTaxes = this.TobinTaxes.bind(this);
        this.Actives = this.Actives.bind(this);
        this.VoteTargets = this.VoteTargets.bind(this);
        this.FeederDelegation = this.FeederDelegation.bind(this);
        this.MissCounter = this.MissCounter.bind(this);
        this.AggregatePrevote = this.AggregatePrevote.bind(this);
        this.AggregatePrevotes = this.AggregatePrevotes.bind(this);
        this.AggregateVote = this.AggregateVote.bind(this);
        this.AggregateVotes = this.AggregateVotes.bind(this);
        this.Params = this.Params.bind(this);
    }
    ExchangeRate(request) {
        const data = exports.QueryExchangeRateRequest.encode(request).finish();
        const promise = this.rpc.request("terra.oracle.v1beta1.Query", "ExchangeRate", data);
        return promise.then((data) => exports.QueryExchangeRateResponse.decode(new minimal_1.default.Reader(data)));
    }
    ExchangeRates(request) {
        const data = exports.QueryExchangeRatesRequest.encode(request).finish();
        const promise = this.rpc.request("terra.oracle.v1beta1.Query", "ExchangeRates", data);
        return promise.then((data) => exports.QueryExchangeRatesResponse.decode(new minimal_1.default.Reader(data)));
    }
    TobinTax(request) {
        const data = exports.QueryTobinTaxRequest.encode(request).finish();
        const promise = this.rpc.request("terra.oracle.v1beta1.Query", "TobinTax", data);
        return promise.then((data) => exports.QueryTobinTaxResponse.decode(new minimal_1.default.Reader(data)));
    }
    TobinTaxes(request) {
        const data = exports.QueryTobinTaxesRequest.encode(request).finish();
        const promise = this.rpc.request("terra.oracle.v1beta1.Query", "TobinTaxes", data);
        return promise.then((data) => exports.QueryTobinTaxesResponse.decode(new minimal_1.default.Reader(data)));
    }
    Actives(request) {
        const data = exports.QueryActivesRequest.encode(request).finish();
        const promise = this.rpc.request("terra.oracle.v1beta1.Query", "Actives", data);
        return promise.then((data) => exports.QueryActivesResponse.decode(new minimal_1.default.Reader(data)));
    }
    VoteTargets(request) {
        const data = exports.QueryVoteTargetsRequest.encode(request).finish();
        const promise = this.rpc.request("terra.oracle.v1beta1.Query", "VoteTargets", data);
        return promise.then((data) => exports.QueryVoteTargetsResponse.decode(new minimal_1.default.Reader(data)));
    }
    FeederDelegation(request) {
        const data = exports.QueryFeederDelegationRequest.encode(request).finish();
        const promise = this.rpc.request("terra.oracle.v1beta1.Query", "FeederDelegation", data);
        return promise.then((data) => exports.QueryFeederDelegationResponse.decode(new minimal_1.default.Reader(data)));
    }
    MissCounter(request) {
        const data = exports.QueryMissCounterRequest.encode(request).finish();
        const promise = this.rpc.request("terra.oracle.v1beta1.Query", "MissCounter", data);
        return promise.then((data) => exports.QueryMissCounterResponse.decode(new minimal_1.default.Reader(data)));
    }
    AggregatePrevote(request) {
        const data = exports.QueryAggregatePrevoteRequest.encode(request).finish();
        const promise = this.rpc.request("terra.oracle.v1beta1.Query", "AggregatePrevote", data);
        return promise.then((data) => exports.QueryAggregatePrevoteResponse.decode(new minimal_1.default.Reader(data)));
    }
    AggregatePrevotes(request) {
        const data = exports.QueryAggregatePrevotesRequest.encode(request).finish();
        const promise = this.rpc.request("terra.oracle.v1beta1.Query", "AggregatePrevotes", data);
        return promise.then((data) => exports.QueryAggregatePrevotesResponse.decode(new minimal_1.default.Reader(data)));
    }
    AggregateVote(request) {
        const data = exports.QueryAggregateVoteRequest.encode(request).finish();
        const promise = this.rpc.request("terra.oracle.v1beta1.Query", "AggregateVote", data);
        return promise.then((data) => exports.QueryAggregateVoteResponse.decode(new minimal_1.default.Reader(data)));
    }
    AggregateVotes(request) {
        const data = exports.QueryAggregateVotesRequest.encode(request).finish();
        const promise = this.rpc.request("terra.oracle.v1beta1.Query", "AggregateVotes", data);
        return promise.then((data) => exports.QueryAggregateVotesResponse.decode(new minimal_1.default.Reader(data)));
    }
    Params(request) {
        const data = exports.QueryParamsRequest.encode(request).finish();
        const promise = this.rpc.request("terra.oracle.v1beta1.Query", "Params", data);
        return promise.then((data) => exports.QueryParamsResponse.decode(new minimal_1.default.Reader(data)));
    }
}
exports.QueryClientImpl = QueryClientImpl;
if (minimal_1.default.util.Long !== long_1.default) {
    minimal_1.default.util.Long = long_1.default;
    minimal_1.default.configure();
}
//# sourceMappingURL=query.js.map