import Long from "long";
import _m0 from "protobufjs/minimal";
export declare const protobufPackage = "terra.oracle.v1beta1";
/** Params defines the parameters for the oracle module. */
export interface Params {
    votePeriod: Long;
    voteThreshold: string;
    rewardBand: string;
    rewardDistributionWindow: Long;
    whitelist: Denom[];
    slashFraction: string;
    slashWindow: Long;
    minValidPerWindow: string;
}
/** Denom - the object to hold configurations of each denom */
export interface Denom {
    name: string;
    tobinTax: string;
}
/**
 * struct for aggregate prevoting on the ExchangeRateVote.
 * The purpose of aggregate prevote is to hide vote exchange rates with hash
 * which is formatted as hex string in SHA256("{salt}:{exchange rate}{denom},...,{exchange rate}{denom}:{voter}")
 */
export interface AggregateExchangeRatePrevote {
    hash: string;
    voter: string;
    submitBlock: Long;
}
/**
 * MsgAggregateExchangeRateVote - struct for voting on
 * the exchange rates of Luna denominated in various Terra assets.
 */
export interface AggregateExchangeRateVote {
    exchangeRateTuples: ExchangeRateTuple[];
    voter: string;
}
/** ExchangeRateTuple - struct to store interpreted exchange rates data to store */
export interface ExchangeRateTuple {
    denom: string;
    exchangeRate: string;
}
export declare const Params: {
    encode(message: Params, writer?: _m0.Writer): _m0.Writer;
    decode(input: _m0.Reader | Uint8Array, length?: number | undefined): Params;
    fromJSON(object: any): Params;
    toJSON(message: Params): unknown;
    fromPartial(object: DeepPartial<Params>): Params;
};
export declare const Denom: {
    encode(message: Denom, writer?: _m0.Writer): _m0.Writer;
    decode(input: _m0.Reader | Uint8Array, length?: number | undefined): Denom;
    fromJSON(object: any): Denom;
    toJSON(message: Denom): unknown;
    fromPartial(object: DeepPartial<Denom>): Denom;
};
export declare const AggregateExchangeRatePrevote: {
    encode(message: AggregateExchangeRatePrevote, writer?: _m0.Writer): _m0.Writer;
    decode(input: _m0.Reader | Uint8Array, length?: number | undefined): AggregateExchangeRatePrevote;
    fromJSON(object: any): AggregateExchangeRatePrevote;
    toJSON(message: AggregateExchangeRatePrevote): unknown;
    fromPartial(object: DeepPartial<AggregateExchangeRatePrevote>): AggregateExchangeRatePrevote;
};
export declare const AggregateExchangeRateVote: {
    encode(message: AggregateExchangeRateVote, writer?: _m0.Writer): _m0.Writer;
    decode(input: _m0.Reader | Uint8Array, length?: number | undefined): AggregateExchangeRateVote;
    fromJSON(object: any): AggregateExchangeRateVote;
    toJSON(message: AggregateExchangeRateVote): unknown;
    fromPartial(object: DeepPartial<AggregateExchangeRateVote>): AggregateExchangeRateVote;
};
export declare const ExchangeRateTuple: {
    encode(message: ExchangeRateTuple, writer?: _m0.Writer): _m0.Writer;
    decode(input: _m0.Reader | Uint8Array, length?: number | undefined): ExchangeRateTuple;
    fromJSON(object: any): ExchangeRateTuple;
    toJSON(message: ExchangeRateTuple): unknown;
    fromPartial(object: DeepPartial<ExchangeRateTuple>): ExchangeRateTuple;
};
declare type Builtin = Date | Function | Uint8Array | string | number | boolean | undefined | Long;
export declare type DeepPartial<T> = T extends Builtin ? T : T extends Array<infer U> ? Array<DeepPartial<U>> : T extends ReadonlyArray<infer U> ? ReadonlyArray<DeepPartial<U>> : T extends {} ? {
    [K in keyof T]?: DeepPartial<T[K]>;
} : Partial<T>;
export {};
