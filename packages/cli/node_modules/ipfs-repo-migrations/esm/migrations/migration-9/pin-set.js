import { CID } from 'multiformats/cid';
import { ipfs } from './pin.js';
import fnv1a from 'fnv1a';
import varint from 'varint';
import * as dagPb from '@ipld/dag-pb';
import {
  DEFAULT_FANOUT,
  MAX_ITEMS,
  EMPTY_KEY
} from './utils.js';
import { concat as uint8ArrayConcat } from 'uint8arrays/concat';
import { compare as uint8ArrayCompare } from 'uint8arrays/compare';
import { toString as uint8ArrayToString } from 'uint8arrays/to-string';
import { fromString as uint8ArrayFromString } from 'uint8arrays/from-string';
import { sha256 } from 'multiformats/hashes/sha2';
const PinSet = ipfs.pin.Set;
function readHeader(rootNode) {
  const rootData = rootNode.Data;
  if (!rootData) {
    throw new Error('No data present');
  }
  const hdrLength = varint.decode(rootData);
  const vBytes = varint.decode.bytes;
  if (vBytes <= 0) {
    throw new Error('Invalid Set header length');
  }
  if (vBytes + hdrLength > rootData.length) {
    throw new Error('Impossibly large set header length');
  }
  const hdrSlice = rootData.slice(vBytes, hdrLength + vBytes);
  const header = PinSet.toObject(PinSet.decode(hdrSlice), {
    defaults: false,
    arrays: true,
    longs: Number,
    objects: false
  });
  if (header.version !== 1) {
    throw new Error(`Unsupported Set version: ${ header.version }`);
  }
  if (header.fanout > rootNode.Links.length) {
    throw new Error('Impossibly large fanout');
  }
  return {
    header: header,
    data: rootData.slice(hdrLength + vBytes)
  };
}
function hash(seed, key) {
  const buffer = new Uint8Array(4);
  const dataView = new DataView(buffer.buffer);
  dataView.setUint32(0, seed, true);
  const encodedKey = uint8ArrayFromString(key.toString());
  const data = uint8ArrayConcat([
    buffer,
    encodedKey
  ], buffer.byteLength + encodedKey.byteLength);
  return fnv1a(uint8ArrayToString(data));
}
async function* walkItems(blockstore, node) {
  const pbh = readHeader(node);
  let idx = 0;
  for (const link of node.Links) {
    if (idx < pbh.header.fanout) {
      const linkHash = link.Hash;
      if (!EMPTY_KEY.equals(linkHash)) {
        const buf = await blockstore.get(linkHash);
        const node = dagPb.decode(buf);
        yield* walkItems(blockstore, node);
      }
    } else {
      yield link.Hash;
    }
    idx++;
  }
}
export async function* loadSet(blockstore, rootNode, name) {
  const link = rootNode.Links.find(l => l.Name === name);
  if (!link) {
    throw new Error('No link found with name ' + name);
  }
  const buf = await blockstore.get(link.Hash);
  const node = dagPb.decode(buf);
  yield* walkItems(blockstore, node);
}
function storeItems(blockstore, items) {
  return storePins(items, 0);
  async function storePins(pins, depth) {
    const pbHeader = PinSet.encode({
      version: 1,
      fanout: DEFAULT_FANOUT,
      seed: depth
    }).finish();
    const header = varint.encode(pbHeader.length);
    const headerBuf = uint8ArrayConcat([
      header,
      pbHeader
    ]);
    const fanoutLinks = [];
    for (let i = 0; i < DEFAULT_FANOUT; i++) {
      fanoutLinks.push({
        Name: '',
        Tsize: 1,
        Hash: EMPTY_KEY
      });
    }
    if (pins.length <= MAX_ITEMS) {
      const nodes = pins.map(item => {
        return {
          link: {
            Name: '',
            Tsize: 1,
            Hash: item.key
          },
          data: item.data || new Uint8Array()
        };
      }).sort((a, b) => {
        return uint8ArrayCompare(a.link.Hash.bytes, b.link.Hash.bytes);
      });
      const rootLinks = fanoutLinks.concat(nodes.map(item => item.link));
      const rootData = uint8ArrayConcat([
        headerBuf,
        ...nodes.map(item => item.data)
      ]);
      return {
        Data: rootData,
        Links: rootLinks
      };
    } else {
      const bins = pins.reduce((bins, pin) => {
        const n = hash(depth, pin.key) % DEFAULT_FANOUT;
        bins[n] = n in bins ? bins[n].concat([pin]) : [pin];
        return bins;
      }, []);
      let idx = 0;
      for (const bin of bins) {
        const child = await storePins(bin, depth + 1);
        await storeChild(child, idx);
        idx++;
      }
      return {
        Data: headerBuf,
        Links: fanoutLinks
      };
    }
    async function storeChild(child, binIdx) {
      const buf = dagPb.encode(child);
      const digest = await sha256.digest(buf);
      const cid = CID.createV0(digest);
      await blockstore.put(cid, buf);
      const size = child.Links.reduce((acc, curr) => acc + (curr.Tsize || 0), 0) + buf.length;
      fanoutLinks[binIdx] = {
        Name: '',
        Tsize: size,
        Hash: cid
      };
    }
  }
}
export async function storeSet(blockstore, type, cids) {
  const rootNode = await storeItems(blockstore, cids.map(cid => {
    return { key: cid };
  }));
  const buf = dagPb.encode(rootNode);
  const digest = await sha256.digest(buf);
  const cid = CID.createV0(digest);
  await blockstore.put(cid, buf);
  const size = rootNode.Links.reduce((acc, curr) => acc + curr.Tsize, 0) + buf.length;
  return {
    Name: type,
    Tsize: size,
    Hash: cid
  };
}