'use strict';

Object.defineProperty(exports, '__esModule', { value: true });

var index = require('../migrations/index.js');
var version = require('./repo/version.js');
var errors$1 = require('./errors.js');
var utils = require('./utils.js');
var debug = require('debug');

function _interopDefaultLegacy (e) { return e && typeof e === 'object' && 'default' in e ? e : { 'default': e }; }

var debug__default = /*#__PURE__*/_interopDefaultLegacy(debug);

const log = debug__default["default"]('ipfs:repo:migrator');
function getLatestMigrationVersion(migrations) {
  migrations = migrations || index;
  if (!Array.isArray(migrations) || migrations.length === 0) {
    return 0;
  }
  return migrations[migrations.length - 1].version;
}
async function migrate(path, backends, repoOptions, toVersion, {ignoreLock = false, onProgress, isDryRun = false, migrations}) {
  migrations = migrations || index;
  if (!path) {
    throw new errors.RequiredParameterError('Path argument is required!');
  }
  if (!repoOptions) {
    throw new errors.RequiredParameterError('repoOptions argument is required!');
  }
  if (!toVersion) {
    throw new errors.RequiredParameterError('toVersion argument is required!');
  }
  if (!Number.isInteger(toVersion) || toVersion <= 0) {
    throw new errors.InvalidValueError('Version has to be positive integer!');
  }
  backends = utils.wrapBackends(backends);
  const currentVersion = await version.getVersion(backends);
  if (currentVersion === toVersion) {
    log('Nothing to migrate.');
    return;
  }
  if (currentVersion > toVersion) {
    throw new errors.InvalidValueError(`Current repo's version (${ currentVersion }) is higher then toVersion (${ toVersion }), you probably wanted to revert it?`);
  }
  verifyAvailableMigrations(migrations, currentVersion, toVersion);
  let lock;
  if (!isDryRun && !ignoreLock) {
    lock = await repoOptions.repoLock.lock(path);
  }
  try {
    for (const migration of migrations) {
      if (toVersion !== undefined && migration.version > toVersion) {
        break;
      }
      if (migration.version <= currentVersion) {
        continue;
      }
      log(`Migrating version ${ migration.version }`);
      try {
        if (!isDryRun) {
          let progressCallback = () => {
          };
          if (onProgress) {
            progressCallback = (percent, message) => onProgress(migration.version, percent.toFixed(2), message);
          }
          await migration.migrate(backends, progressCallback);
        }
      } catch (e) {
        const lastSuccessfullyMigratedVersion = migration.version - 1;
        log(`An exception was raised during execution of migration. Setting the repo's version to last successfully migrated version: ${ lastSuccessfullyMigratedVersion }`);
        await version.setVersion(lastSuccessfullyMigratedVersion, backends);
        throw new Error(`During migration to version ${ migration.version } exception was raised: ${ e.stack || e.message || e }`);
      }
      log(`Migrating to version ${ migration.version } finished`);
    }
    if (!isDryRun) {
      await version.setVersion(toVersion || getLatestMigrationVersion(migrations), backends);
    }
    log('Repo successfully migrated', toVersion !== undefined ? `to version ${ toVersion }!` : 'to latest version!');
  } finally {
    if (!isDryRun && !ignoreLock && lock) {
      await lock.close();
    }
  }
}
async function revert(path, backends, repoOptions, toVersion, {ignoreLock = false, onProgress, isDryRun = false, migrations}) {
  migrations = migrations || index;
  if (!path) {
    throw new errors.RequiredParameterError('Path argument is required!');
  }
  if (!repoOptions) {
    throw new errors.RequiredParameterError('repoOptions argument is required!');
  }
  if (!toVersion) {
    throw new errors.RequiredParameterError('When reverting migrations, you have to specify to which version to revert!');
  }
  if (!Number.isInteger(toVersion) || toVersion <= 0) {
    throw new errors.InvalidValueError('Version has to be positive integer!');
  }
  backends = utils.wrapBackends(backends);
  const currentVersion = await version.getVersion(backends);
  if (currentVersion === toVersion) {
    log('Nothing to revert.');
    return;
  }
  if (currentVersion < toVersion) {
    throw new errors.InvalidValueError(`Current repo's version (${ currentVersion }) is lower then toVersion (${ toVersion }), you probably wanted to migrate it?`);
  }
  verifyAvailableMigrations(migrations, toVersion, currentVersion, true);
  let lock;
  if (!isDryRun && !ignoreLock) {
    lock = await repoOptions.repoLock.lock(path);
  }
  log(`Reverting from version ${ currentVersion } to ${ toVersion }`);
  try {
    const reversedMigrationArray = migrations.slice().reverse();
    for (const migration of reversedMigrationArray) {
      if (migration.version <= toVersion) {
        break;
      }
      if (migration.version > currentVersion) {
        continue;
      }
      log(`Reverting migration version ${ migration.version }`);
      try {
        if (!isDryRun) {
          let progressCallback = () => {
          };
          if (onProgress) {
            progressCallback = (percent, message) => onProgress(migration.version, percent.toFixed(2), message);
          }
          await migration.revert(backends, progressCallback);
        }
      } catch (e) {
        const lastSuccessfullyRevertedVersion = migration.version;
        log(`An exception was raised during execution of migration. Setting the repo's version to last successfully reverted version: ${ lastSuccessfullyRevertedVersion }`);
        await version.setVersion(lastSuccessfullyRevertedVersion, backends);
        e.message = `During reversion to version ${ migration.version } exception was raised: ${ e.message }`;
        throw e;
      }
      log(`Reverting to version ${ migration.version } finished`);
    }
    if (!isDryRun) {
      await version.setVersion(toVersion, backends);
    }
    log(`All migrations successfully reverted to version ${ toVersion }!`);
  } finally {
    if (!isDryRun && !ignoreLock && lock) {
      await lock.close();
    }
  }
}
function verifyAvailableMigrations(migrations, fromVersion, toVersion, checkReversibility = false) {
  let migrationCounter = 0;
  for (const migration of migrations) {
    if (migration.version > toVersion) {
      break;
    }
    if (migration.version > fromVersion) {
      if (checkReversibility && !migration.revert) {
        throw new errors.NonReversibleMigrationError(`It is not possible to revert to version ${ fromVersion } because migration version ${ migration.version } is not reversible. Cancelling reversion.`);
      }
      migrationCounter++;
    }
  }
  if (migrationCounter !== toVersion - fromVersion) {
    throw new errors.InvalidValueError(`The ipfs-repo-migrations package does not have all migration to migrate from version ${ fromVersion } to ${ toVersion }`);
  }
}
const getCurrentRepoVersion = version.getVersion;
const errors = errors$1;
const migrations = index;

exports.errors = errors;
exports.getCurrentRepoVersion = getCurrentRepoVersion;
exports.getLatestMigrationVersion = getLatestMigrationVersion;
exports.migrate = migrate;
exports.migrations = migrations;
exports.revert = revert;
