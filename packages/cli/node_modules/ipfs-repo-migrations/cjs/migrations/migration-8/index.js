'use strict';

Object.defineProperty(exports, '__esModule', { value: true });

var cid = require('multiformats/cid');
var key = require('interface-datastore/key');
var debug = require('debug');
var length = require('it-length');
var base32 = require('multiformats/bases/base32');
var raw = require('multiformats/codecs/raw');
var mhd = require('multiformats/hashes/digest');

function _interopDefaultLegacy (e) { return e && typeof e === 'object' && 'default' in e ? e : { 'default': e }; }

function _interopNamespace(e) {
  if (e && e.__esModule) return e;
  var n = Object.create(null);
  if (e) {
    Object.keys(e).forEach(function (k) {
      if (k !== 'default') {
        var d = Object.getOwnPropertyDescriptor(e, k);
        Object.defineProperty(n, k, d.get ? d : {
          enumerable: true,
          get: function () { return e[k]; }
        });
      }
    });
  }
  n["default"] = e;
  return Object.freeze(n);
}

var debug__default = /*#__PURE__*/_interopDefaultLegacy(debug);
var length__default = /*#__PURE__*/_interopDefaultLegacy(length);
var raw__namespace = /*#__PURE__*/_interopNamespace(raw);
var mhd__namespace = /*#__PURE__*/_interopNamespace(mhd);

const log = debug__default["default"]('ipfs:repo:migrator:migration-8');
function unwrap(blockstore) {
  if (blockstore.child) {
    return unwrap(blockstore.child);
  }
  return blockstore;
}
function keyToMultihash(key$1) {
  try {
    const buf = base32.base32.decode(`b${ key$1.toString().toLowerCase().slice(1) }`);
    const multihash = cid.CID.decode(buf).multihash.bytes;
    const multihashStr = base32.base32.encode(multihash).slice(1).toUpperCase();
    return new key.Key(`/${ multihashStr }`, false);
  } catch (err) {
    return key$1;
  }
}
function keyToCid(key$1) {
  try {
    const buf = base32.base32.decode(`b${ key$1.toString().toLowerCase().slice(1) }`);
    const digest = mhd__namespace.decode(buf);
    const multihash = base32.base32.encode(cid.CID.createV1(raw__namespace.code, digest).bytes).slice(1);
    return new key.Key(`/${ multihash.toUpperCase() }`, false);
  } catch {
    return key$1;
  }
}
async function process(backends, onProgress, keyFunction) {
  const blockstore = backends.blocks;
  await blockstore.open();
  const unwrapped = unwrap(blockstore);
  const blockCount = await length__default["default"](unwrapped.queryKeys({
    filters: [key => {
        const newKey = keyFunction(key);
        return newKey.toString() !== key.toString();
      }]
  }));
  try {
    let counter = 0;
    for await (const block of unwrapped.query({})) {
      const newKey = keyFunction(block.key);
      if (newKey.toString() !== block.key.toString()) {
        counter += 1;
        log(`Migrating Block from ${ block.key } to ${ newKey }`, await unwrapped.has(block.key));
        await unwrapped.delete(block.key);
        await unwrapped.put(newKey, block.value);
        onProgress(counter / blockCount * 100, `Migrated Block from ${ block.key } to ${ newKey }`);
      }
    }
  } finally {
    await blockstore.close();
  }
}
const migration = {
  version: 8,
  description: 'Transforms key names into base32 encoding and converts Block store to use bare multihashes encoded as base32',
  migrate: (backends, onProgress = () => {
  }) => {
    return process(backends, onProgress, keyToMultihash);
  },
  revert: (backends, onProgress = () => {
  }) => {
    return process(backends, onProgress, keyToCid);
  }
};

exports.migration = migration;
