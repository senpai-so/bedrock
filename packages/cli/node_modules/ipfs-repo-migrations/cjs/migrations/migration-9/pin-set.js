'use strict';

Object.defineProperty(exports, '__esModule', { value: true });

var cid = require('multiformats/cid');
var pin = require('./pin.js');
var fnv1a = require('fnv1a');
var varint = require('varint');
var dagPb = require('@ipld/dag-pb');
var utils = require('./utils.js');
var concat = require('uint8arrays/concat');
var compare = require('uint8arrays/compare');
var toString = require('uint8arrays/to-string');
var fromString = require('uint8arrays/from-string');
var sha2 = require('multiformats/hashes/sha2');

function _interopDefaultLegacy (e) { return e && typeof e === 'object' && 'default' in e ? e : { 'default': e }; }

function _interopNamespace(e) {
  if (e && e.__esModule) return e;
  var n = Object.create(null);
  if (e) {
    Object.keys(e).forEach(function (k) {
      if (k !== 'default') {
        var d = Object.getOwnPropertyDescriptor(e, k);
        Object.defineProperty(n, k, d.get ? d : {
          enumerable: true,
          get: function () { return e[k]; }
        });
      }
    });
  }
  n["default"] = e;
  return Object.freeze(n);
}

var fnv1a__default = /*#__PURE__*/_interopDefaultLegacy(fnv1a);
var varint__default = /*#__PURE__*/_interopDefaultLegacy(varint);
var dagPb__namespace = /*#__PURE__*/_interopNamespace(dagPb);

const PinSet = pin.ipfs.pin.Set;
function readHeader(rootNode) {
  const rootData = rootNode.Data;
  if (!rootData) {
    throw new Error('No data present');
  }
  const hdrLength = varint__default["default"].decode(rootData);
  const vBytes = varint__default["default"].decode.bytes;
  if (vBytes <= 0) {
    throw new Error('Invalid Set header length');
  }
  if (vBytes + hdrLength > rootData.length) {
    throw new Error('Impossibly large set header length');
  }
  const hdrSlice = rootData.slice(vBytes, hdrLength + vBytes);
  const header = PinSet.toObject(PinSet.decode(hdrSlice), {
    defaults: false,
    arrays: true,
    longs: Number,
    objects: false
  });
  if (header.version !== 1) {
    throw new Error(`Unsupported Set version: ${ header.version }`);
  }
  if (header.fanout > rootNode.Links.length) {
    throw new Error('Impossibly large fanout');
  }
  return {
    header: header,
    data: rootData.slice(hdrLength + vBytes)
  };
}
function hash(seed, key) {
  const buffer = new Uint8Array(4);
  const dataView = new DataView(buffer.buffer);
  dataView.setUint32(0, seed, true);
  const encodedKey = fromString.fromString(key.toString());
  const data = concat.concat([
    buffer,
    encodedKey
  ], buffer.byteLength + encodedKey.byteLength);
  return fnv1a__default["default"](toString.toString(data));
}
async function* walkItems(blockstore, node) {
  const pbh = readHeader(node);
  let idx = 0;
  for (const link of node.Links) {
    if (idx < pbh.header.fanout) {
      const linkHash = link.Hash;
      if (!utils.EMPTY_KEY.equals(linkHash)) {
        const buf = await blockstore.get(linkHash);
        const node = dagPb__namespace.decode(buf);
        yield* walkItems(blockstore, node);
      }
    } else {
      yield link.Hash;
    }
    idx++;
  }
}
async function* loadSet(blockstore, rootNode, name) {
  const link = rootNode.Links.find(l => l.Name === name);
  if (!link) {
    throw new Error('No link found with name ' + name);
  }
  const buf = await blockstore.get(link.Hash);
  const node = dagPb__namespace.decode(buf);
  yield* walkItems(blockstore, node);
}
function storeItems(blockstore, items) {
  return storePins(items, 0);
  async function storePins(pins, depth) {
    const pbHeader = PinSet.encode({
      version: 1,
      fanout: utils.DEFAULT_FANOUT,
      seed: depth
    }).finish();
    const header = varint__default["default"].encode(pbHeader.length);
    const headerBuf = concat.concat([
      header,
      pbHeader
    ]);
    const fanoutLinks = [];
    for (let i = 0; i < utils.DEFAULT_FANOUT; i++) {
      fanoutLinks.push({
        Name: '',
        Tsize: 1,
        Hash: utils.EMPTY_KEY
      });
    }
    if (pins.length <= utils.MAX_ITEMS) {
      const nodes = pins.map(item => {
        return {
          link: {
            Name: '',
            Tsize: 1,
            Hash: item.key
          },
          data: item.data || new Uint8Array()
        };
      }).sort((a, b) => {
        return compare.compare(a.link.Hash.bytes, b.link.Hash.bytes);
      });
      const rootLinks = fanoutLinks.concat(nodes.map(item => item.link));
      const rootData = concat.concat([
        headerBuf,
        ...nodes.map(item => item.data)
      ]);
      return {
        Data: rootData,
        Links: rootLinks
      };
    } else {
      const bins = pins.reduce((bins, pin) => {
        const n = hash(depth, pin.key) % utils.DEFAULT_FANOUT;
        bins[n] = n in bins ? bins[n].concat([pin]) : [pin];
        return bins;
      }, []);
      let idx = 0;
      for (const bin of bins) {
        const child = await storePins(bin, depth + 1);
        await storeChild(child, idx);
        idx++;
      }
      return {
        Data: headerBuf,
        Links: fanoutLinks
      };
    }
    async function storeChild(child, binIdx) {
      const buf = dagPb__namespace.encode(child);
      const digest = await sha2.sha256.digest(buf);
      const cid$1 = cid.CID.createV0(digest);
      await blockstore.put(cid$1, buf);
      const size = child.Links.reduce((acc, curr) => acc + (curr.Tsize || 0), 0) + buf.length;
      fanoutLinks[binIdx] = {
        Name: '',
        Tsize: size,
        Hash: cid$1
      };
    }
  }
}
async function storeSet(blockstore, type, cids) {
  const rootNode = await storeItems(blockstore, cids.map(cid => {
    return { key: cid };
  }));
  const buf = dagPb__namespace.encode(rootNode);
  const digest = await sha2.sha256.digest(buf);
  const cid$1 = cid.CID.createV0(digest);
  await blockstore.put(cid$1, buf);
  const size = rootNode.Links.reduce((acc, curr) => acc + curr.Tsize, 0) + buf.length;
  return {
    Name: type,
    Tsize: size,
    Hash: cid$1
  };
}

exports.loadSet = loadSet;
exports.storeSet = storeSet;
