'use strict';

Object.defineProperty(exports, '__esModule', { value: true });

var cid = require('multiformats/cid');
var dagPb = require('@ipld/dag-pb');
var cbor = require('cborg');
var pinSet = require('./pin-set.js');
var utils = require('./utils.js');
var length = require('it-length');
var sha2 = require('multiformats/hashes/sha2');
var mhd = require('multiformats/hashes/digest');
var base32 = require('multiformats/bases/base32');

function _interopDefaultLegacy (e) { return e && typeof e === 'object' && 'default' in e ? e : { 'default': e }; }

function _interopNamespace(e) {
  if (e && e.__esModule) return e;
  var n = Object.create(null);
  if (e) {
    Object.keys(e).forEach(function (k) {
      if (k !== 'default') {
        var d = Object.getOwnPropertyDescriptor(e, k);
        Object.defineProperty(n, k, d.get ? d : {
          enumerable: true,
          get: function () { return e[k]; }
        });
      }
    });
  }
  n["default"] = e;
  return Object.freeze(n);
}

var dagPb__namespace = /*#__PURE__*/_interopNamespace(dagPb);
var cbor__namespace = /*#__PURE__*/_interopNamespace(cbor);
var length__default = /*#__PURE__*/_interopDefaultLegacy(length);
var mhd__namespace = /*#__PURE__*/_interopNamespace(mhd);

async function pinsToDatastore(blockstore, datastore, pinstore, onProgress) {
  if (!await datastore.has(utils.PIN_DS_KEY)) {
    return;
  }
  const mh = await datastore.get(utils.PIN_DS_KEY);
  const cid$1 = cid.CID.decode(mh);
  const pinRootBuf = await blockstore.get(cid$1);
  const pinRoot = dagPb__namespace.decode(pinRootBuf);
  let counter = 0;
  const pinCount = await length__default["default"](pinSet.loadSet(blockstore, pinRoot, utils.PinTypes.recursive)) + await length__default["default"](pinSet.loadSet(blockstore, pinRoot, utils.PinTypes.direct));
  for await (const cid of pinSet.loadSet(blockstore, pinRoot, utils.PinTypes.recursive)) {
    counter++;
    const pin = { depth: Infinity };
    if (cid.version !== 0) {
      pin.version = cid.version;
    }
    if (cid.code !== dagPb__namespace.code) {
      pin.codec = cid.code;
    }
    await pinstore.put(utils.cidToKey(cid), cbor__namespace.encode(pin));
    onProgress(counter / pinCount * 100, `Migrated recursive pin ${ cid }`);
  }
  for await (const cid of pinSet.loadSet(blockstore, pinRoot, utils.PinTypes.direct)) {
    counter++;
    const pin = { depth: 0 };
    if (cid.version !== 0) {
      pin.version = cid.version;
    }
    if (cid.code !== dagPb__namespace.code) {
      pin.codec = cid.code;
    }
    await pinstore.put(utils.cidToKey(cid), cbor__namespace.encode(pin));
    onProgress(counter / pinCount * 100, `Migrated direct pin ${ cid }`);
  }
  await blockstore.delete(cid$1);
  await datastore.delete(utils.PIN_DS_KEY);
}
async function pinsToDAG(blockstore, datastore, pinstore, onProgress) {
  const recursivePins = [];
  const directPins = [];
  let counter = 0;
  const pinCount = await length__default["default"](pinstore.queryKeys({}));
  for await (const {key, value} of pinstore.query({})) {
    counter++;
    const pin = cbor__namespace.decode(value);
    const cid$1 = cid.CID.create(pin.version || 0, pin.codec || dagPb__namespace.code, mhd__namespace.decode(base32.base32.decode('b' + key.toString().toLowerCase().split('/').pop())));
    if (pin.depth === 0) {
      onProgress(counter / pinCount * 100, `Reverted direct pin ${ cid$1 }`);
      directPins.push(cid$1);
    } else {
      onProgress(counter / pinCount * 100, `Reverted recursive pin ${ cid$1 }`);
      recursivePins.push(cid$1);
    }
  }
  onProgress(100, 'Updating pin root');
  const pinRoot = {
    Links: [
      await pinSet.storeSet(blockstore, utils.PinTypes.direct, directPins),
      await pinSet.storeSet(blockstore, utils.PinTypes.recursive, recursivePins)
    ]
  };
  const buf = dagPb__namespace.encode(pinRoot);
  const digest = await sha2.sha256.digest(buf);
  const cid$1 = cid.CID.createV0(digest);
  await blockstore.put(cid$1, buf);
  await datastore.put(utils.PIN_DS_KEY, cid$1.bytes);
}
async function process(backends, onProgress, fn) {
  const blockstore = backends.blocks;
  const datastore = backends.datastore;
  const pinstore = backends.pins;
  await blockstore.open();
  await datastore.open();
  await pinstore.open();
  try {
    await fn(blockstore, datastore, pinstore, onProgress);
  } finally {
    await pinstore.close();
    await datastore.close();
    await blockstore.close();
  }
}
const migration = {
  version: 9,
  description: 'Migrates pins to datastore',
  migrate: (backends, onProgress = () => {
  }) => {
    return process(backends, onProgress, pinsToDatastore);
  },
  revert: (backends, onProgress = () => {
  }) => {
    return process(backends, onProgress, pinsToDAG);
  }
};

exports.migration = migration;
