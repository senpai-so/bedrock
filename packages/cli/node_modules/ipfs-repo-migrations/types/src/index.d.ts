/**
 * @typedef {import('./types').Migration} Migration
 * @typedef {import('./types').MigrationOptions} MigrationOptions
 * @typedef {import('./types').ProgressCallback} ProgressCallback
 * @typedef {import('./types').MigrationProgressCallback} MigrationProgressCallback
 */
/**
 * Returns the version of latest migration.
 * If no migrations are present returns 0.
 *
 * @param {Migration[]} [migrations] - Array of migrations to consider. If undefined, the bundled migrations are used. Mainly for testing purpose.
 */
export function getLatestMigrationVersion(migrations?: import("./types").Migration[] | undefined): number;
/**
 * Main function to execute forward migrations.
 * It acquire lock on the provided path before doing any migrations.
 *
 * Signature of the progress callback is: function(migrationObject: object, currentMigrationNumber: int, totalMigrationsCount: int)
 *
 * @param {string} path - Path to initialized (!) JS-IPFS repo
 * @param {import('./types').Backends} backends
 * @param {import('./types').RepoOptions} repoOptions - Options that are passed to migrations, that can use them to correctly construct datastore. Options are same like for IPFSRepo.
 * @param {number} toVersion - Version to which the repo should be migrated.
 * @param {MigrationOptions} [options] - Options for migration
 */
export function migrate(path: string, backends: import('./types').Backends, repoOptions: import('./types').RepoOptions, toVersion: number, { ignoreLock, onProgress, isDryRun, migrations }?: import("./types").MigrationOptions | undefined): Promise<void>;
/**
 * Main function to execute backward migration (reversion).
 * It acquire lock on the provided path before doing any migrations.
 *
 * Signature of the progress callback is: function(migrationObject: object, currentMigrationNumber: int, totalMigrationsCount: int)
 *
 * @param {string} path - Path to initialized (!) JS-IPFS repo
 * @param {import('./types').Backends} backends
 * @param {import('./types').RepoOptions} repoOptions - Options that are passed to migrations, that can use them to correctly construct datastore. Options are same like for IPFSRepo.
 * @param {number} toVersion - Version to which the repo will be reverted.
 * @param {MigrationOptions} [options] - Options for the reversion
 */
export function revert(path: string, backends: import('./types').Backends, repoOptions: import('./types').RepoOptions, toVersion: number, { ignoreLock, onProgress, isDryRun, migrations }?: import("./types").MigrationOptions | undefined): Promise<void>;
export const getCurrentRepoVersion: typeof repoVersion.getVersion;
export const errors: typeof Errors;
export const migrations: import("./types").Migration[];
export type Migration = import('./types').Migration;
export type MigrationOptions = import('./types').MigrationOptions;
export type ProgressCallback = import('./types').ProgressCallback;
export type MigrationProgressCallback = import('./types').MigrationProgressCallback;
import * as repoVersion from "./repo/version.js";
import * as Errors from "./errors.js";
//# sourceMappingURL=index.d.ts.map