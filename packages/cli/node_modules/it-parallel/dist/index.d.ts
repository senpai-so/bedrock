export = parallel;
/**
 * @template T
 * @typedef {object} Operation
 * @property {boolean} done
 * @property {boolean} ok
 * @property {Error} err
 * @property {T} value
 */
/**
 * Takes an (async) iterator that emits promise-returning functions,
 * invokes them in parallel and emits the results as they become available but
 * in the same order as the input
 *
 * @template T
 * @param {Iterable<() => Promise<T>> | AsyncIterable<() => Promise<T>>} source
 * @param {object} [options]
 * @param {number} [options.concurrency=Infinity]
 * @param {boolean} [options.ordered=false]
 * @returns {AsyncIterable<T>}
 */
declare function parallel<T>(source: Iterable<() => Promise<T>> | AsyncIterable<() => Promise<T>>, options?: {
    concurrency?: number | undefined;
    ordered?: boolean | undefined;
} | undefined): AsyncIterable<T>;
declare namespace parallel {
    export { Operation };
}
type Operation<T> = {
    done: boolean;
    ok: boolean;
    err: Error;
    value: T;
};
//# sourceMappingURL=index.d.ts.map