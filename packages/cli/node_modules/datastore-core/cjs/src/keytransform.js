'use strict';

Object.defineProperty(exports, '__esModule', { value: true });

var base = require('./base.js');
var map = require('it-map');
var itPipe = require('it-pipe');

function _interopDefaultLegacy (e) { return e && typeof e === 'object' && 'default' in e ? e : { 'default': e }; }

var map__default = /*#__PURE__*/_interopDefaultLegacy(map);

class KeyTransformDatastore extends base.BaseDatastore {
  constructor(child, transform) {
    super();
    this.child = child;
    this.transform = transform;
  }
  open() {
    return this.child.open();
  }
  put(key, val, options) {
    return this.child.put(this.transform.convert(key), val, options);
  }
  get(key, options) {
    return this.child.get(this.transform.convert(key), options);
  }
  has(key, options) {
    return this.child.has(this.transform.convert(key), options);
  }
  delete(key, options) {
    return this.child.delete(this.transform.convert(key), options);
  }
  async *putMany(source, options = {}) {
    const transform = this.transform;
    const child = this.child;
    yield* itPipe.pipe(source, async function* (source) {
      yield* map__default['default'](source, ({key, value}) => ({
        key: transform.convert(key),
        value
      }));
    }, async function* (source) {
      yield* child.putMany(source, options);
    }, async function* (source) {
      yield* map__default['default'](source, ({key, value}) => ({
        key: transform.invert(key),
        value
      }));
    });
  }
  async *getMany(source, options = {}) {
    const transform = this.transform;
    const child = this.child;
    yield* itPipe.pipe(source, async function* (source) {
      yield* map__default['default'](source, key => transform.convert(key));
    }, async function* (source) {
      yield* child.getMany(source, options);
    });
  }
  async *deleteMany(source, options = {}) {
    const transform = this.transform;
    const child = this.child;
    yield* itPipe.pipe(source, async function* (source) {
      yield* map__default['default'](source, key => transform.convert(key));
    }, async function* (source) {
      yield* child.deleteMany(source, options);
    }, async function* (source) {
      yield* map__default['default'](source, key => transform.invert(key));
    });
  }
  batch() {
    const b = this.child.batch();
    return {
      put: (key, value) => {
        b.put(this.transform.convert(key), value);
      },
      delete: key => {
        b.delete(this.transform.convert(key));
      },
      commit: options => {
        return b.commit(options);
      }
    };
  }
  query(q, options) {
    return map__default['default'](this.child.query(q, options), ({key, value}) => {
      return {
        key: this.transform.invert(key),
        value
      };
    });
  }
  queryKeys(q, options) {
    return map__default['default'](this.child.queryKeys(q, options), key => {
      return this.transform.invert(key);
    });
  }
  close() {
    return this.child.close();
  }
}

exports.KeyTransformDatastore = KeyTransformDatastore;
