'use strict';

Object.defineProperty(exports, '__esModule', { value: true });

var filter = require('it-filter');
var take = require('it-take');
var merge = require('it-merge');
var base = require('./base.js');
var keytransform = require('./keytransform.js');
var errors = require('./errors.js');
var utils = require('./utils.js');
var key = require('interface-datastore/key');

function _interopDefaultLegacy (e) { return e && typeof e === 'object' && 'default' in e ? e : { 'default': e }; }

var filter__default = /*#__PURE__*/_interopDefaultLegacy(filter);
var take__default = /*#__PURE__*/_interopDefaultLegacy(take);
var merge__default = /*#__PURE__*/_interopDefaultLegacy(merge);

class MountDatastore extends base.BaseDatastore {
  constructor(mounts) {
    super();
    this.mounts = mounts.slice();
  }
  async open() {
    await Promise.all(this.mounts.map(m => m.datastore.open()));
  }
  _lookup(key$1) {
    for (const mount of this.mounts) {
      if (mount.prefix.toString() === key$1.toString() || mount.prefix.isAncestorOf(key$1)) {
        const s = utils.replaceStartWith(key$1.toString(), mount.prefix.toString());
        return {
          datastore: mount.datastore,
          mountpoint: mount.prefix,
          rest: new key.Key(s)
        };
      }
    }
  }
  put(key, value, options) {
    const match = this._lookup(key);
    if (match == null) {
      throw errors.dbWriteFailedError(new Error('No datastore mounted for this key'));
    }
    return match.datastore.put(match.rest, value, options);
  }
  get(key, options) {
    const match = this._lookup(key);
    if (match == null) {
      throw errors.notFoundError(new Error('No datastore mounted for this key'));
    }
    return match.datastore.get(match.rest, options);
  }
  has(key, options) {
    const match = this._lookup(key);
    if (match == null) {
      return Promise.resolve(false);
    }
    return match.datastore.has(match.rest, options);
  }
  delete(key, options) {
    const match = this._lookup(key);
    if (match == null) {
      throw errors.dbDeleteFailedError(new Error('No datastore mounted for this key'));
    }
    return match.datastore.delete(match.rest, options);
  }
  async close() {
    await Promise.all(this.mounts.map(m => {
      return m.datastore.close();
    }));
  }
  batch() {
    const batchMounts = {};
    const lookup = key => {
      const match = this._lookup(key);
      if (match == null) {
        throw new Error('No datastore mounted for this key');
      }
      const m = match.mountpoint.toString();
      if (batchMounts[m] == null) {
        batchMounts[m] = match.datastore.batch();
      }
      return {
        batch: batchMounts[m],
        rest: match.rest
      };
    };
    return {
      put: (key, value) => {
        const match = lookup(key);
        match.batch.put(match.rest, value);
      },
      delete: key => {
        const match = lookup(key);
        match.batch.delete(match.rest);
      },
      commit: async options => {
        await Promise.all(Object.keys(batchMounts).map(p => batchMounts[p].commit(options)));
      }
    };
  }
  query(q, options) {
    const qs = this.mounts.map(m => {
      const ks = new keytransform.KeyTransformDatastore(m.datastore, {
        convert: key => {
          throw new Error('should never be called');
        },
        invert: key => {
          return m.prefix.child(key);
        }
      });
      let prefix;
      if (q.prefix != null) {
        prefix = utils.replaceStartWith(q.prefix, m.prefix.toString());
      }
      return ks.query({
        prefix: prefix,
        filters: q.filters
      }, options);
    });
    let it = merge__default['default'](...qs);
    if (q.filters)
      q.filters.forEach(f => {
        it = filter__default['default'](it, f);
      });
    if (q.orders)
      q.orders.forEach(o => {
        it = utils.sortAll(it, o);
      });
    if (q.offset != null) {
      let i = 0;
      it = filter__default['default'](it, () => i++ >= q.offset);
    }
    if (q.limit != null)
      it = take__default['default'](it, q.limit);
    return it;
  }
  queryKeys(q, options) {
    const qs = this.mounts.map(m => {
      const ks = new keytransform.KeyTransformDatastore(m.datastore, {
        convert: key => {
          throw new Error('should never be called');
        },
        invert: key => {
          return m.prefix.child(key);
        }
      });
      let prefix;
      if (q.prefix != null) {
        prefix = utils.replaceStartWith(q.prefix, m.prefix.toString());
      }
      return ks.queryKeys({
        prefix: prefix,
        filters: q.filters
      }, options);
    });
    let it = merge__default['default'](...qs);
    if (q.filters)
      q.filters.forEach(f => {
        it = filter__default['default'](it, f);
      });
    if (q.orders)
      q.orders.forEach(o => {
        it = utils.sortAll(it, o);
      });
    if (q.offset != null) {
      let i = 0;
      it = filter__default['default'](it, () => i++ >= q.offset);
    }
    if (q.limit != null)
      it = take__default['default'](it, q.limit);
    return it;
  }
}

exports.MountDatastore = MountDatastore;
