'use strict';

Object.defineProperty(exports, '__esModule', { value: true });

var base = require('./base.js');
var errors = require('./errors.js');
var debug = require('debug');
var pushable = require('it-pushable');
var drain = require('it-drain');

function _interopDefaultLegacy (e) { return e && typeof e === 'object' && 'default' in e ? e : { 'default': e }; }

var debug__default = /*#__PURE__*/_interopDefaultLegacy(debug);
var pushable__default = /*#__PURE__*/_interopDefaultLegacy(pushable);
var drain__default = /*#__PURE__*/_interopDefaultLegacy(drain);

const log = debug__default['default']('datastore:core:tiered');
class TieredDatastore extends base.BaseDatastore {
  constructor(stores) {
    super();
    this.stores = stores.slice();
  }
  async open() {
    try {
      await Promise.all(this.stores.map(store => store.open()));
    } catch (err) {
      throw errors.dbOpenFailedError();
    }
  }
  async put(key, value) {
    try {
      await Promise.all(this.stores.map(store => store.put(key, value)));
    } catch (err) {
      throw errors.dbWriteFailedError();
    }
  }
  async get(key, options) {
    for (const store of this.stores) {
      try {
        const res = await store.get(key, options);
        if (res)
          return res;
      } catch (err) {
        log(err);
      }
    }
    throw errors.notFoundError();
  }
  async has(key, options) {
    for (const s of this.stores) {
      if (await s.has(key, options)) {
        return true;
      }
    }
    return false;
  }
  async delete(key, options) {
    try {
      await Promise.all(this.stores.map(store => store.delete(key, options)));
    } catch (err) {
      throw errors.dbDeleteFailedError();
    }
  }
  async *putMany(source, options = {}) {
    let error;
    const pushables = this.stores.map(store => {
      const source = pushable__default['default']();
      drain__default['default'](store.putMany(source, options)).catch(err => {
        error = err;
      });
      return source;
    });
    try {
      for await (const pair of source) {
        if (error) {
          throw error;
        }
        pushables.forEach(p => p.push(pair));
        yield pair;
      }
    } finally {
      pushables.forEach(p => p.end());
    }
  }
  async *deleteMany(source, options = {}) {
    let error;
    const pushables = this.stores.map(store => {
      const source = pushable__default['default']();
      drain__default['default'](store.deleteMany(source, options)).catch(err => {
        error = err;
      });
      return source;
    });
    try {
      for await (const key of source) {
        if (error) {
          throw error;
        }
        pushables.forEach(p => p.push(key));
        yield key;
      }
    } finally {
      pushables.forEach(p => p.end());
    }
  }
  async close() {
    await Promise.all(this.stores.map(store => store.close()));
  }
  batch() {
    const batches = this.stores.map(store => store.batch());
    return {
      put: (key, value) => {
        batches.forEach(b => b.put(key, value));
      },
      delete: key => {
        batches.forEach(b => b.delete(key));
      },
      commit: async options => {
        for (const batch of batches) {
          await batch.commit(options);
        }
      }
    };
  }
  query(q, options) {
    return this.stores[this.stores.length - 1].query(q, options);
  }
  queryKeys(q, options) {
    return this.stores[this.stores.length - 1].queryKeys(q, options);
  }
}

exports.TieredDatastore = TieredDatastore;
