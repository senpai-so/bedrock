import { BaseDatastore } from './base.js';
import * as Errors from './errors.js';
import debug from 'debug';
import pushable from 'it-pushable';
import drain from 'it-drain';
const log = debug('datastore:core:tiered');
export class TieredDatastore extends BaseDatastore {
  constructor(stores) {
    super();
    this.stores = stores.slice();
  }
  async open() {
    try {
      await Promise.all(this.stores.map(store => store.open()));
    } catch (err) {
      throw Errors.dbOpenFailedError();
    }
  }
  async put(key, value) {
    try {
      await Promise.all(this.stores.map(store => store.put(key, value)));
    } catch (err) {
      throw Errors.dbWriteFailedError();
    }
  }
  async get(key, options) {
    for (const store of this.stores) {
      try {
        const res = await store.get(key, options);
        if (res)
          return res;
      } catch (err) {
        log(err);
      }
    }
    throw Errors.notFoundError();
  }
  async has(key, options) {
    for (const s of this.stores) {
      if (await s.has(key, options)) {
        return true;
      }
    }
    return false;
  }
  async delete(key, options) {
    try {
      await Promise.all(this.stores.map(store => store.delete(key, options)));
    } catch (err) {
      throw Errors.dbDeleteFailedError();
    }
  }
  async *putMany(source, options = {}) {
    let error;
    const pushables = this.stores.map(store => {
      const source = pushable();
      drain(store.putMany(source, options)).catch(err => {
        error = err;
      });
      return source;
    });
    try {
      for await (const pair of source) {
        if (error) {
          throw error;
        }
        pushables.forEach(p => p.push(pair));
        yield pair;
      }
    } finally {
      pushables.forEach(p => p.end());
    }
  }
  async *deleteMany(source, options = {}) {
    let error;
    const pushables = this.stores.map(store => {
      const source = pushable();
      drain(store.deleteMany(source, options)).catch(err => {
        error = err;
      });
      return source;
    });
    try {
      for await (const key of source) {
        if (error) {
          throw error;
        }
        pushables.forEach(p => p.push(key));
        yield key;
      }
    } finally {
      pushables.forEach(p => p.end());
    }
  }
  async close() {
    await Promise.all(this.stores.map(store => store.close()));
  }
  batch() {
    const batches = this.stores.map(store => store.batch());
    return {
      put: (key, value) => {
        batches.forEach(b => b.put(key, value));
      },
      delete: key => {
        batches.forEach(b => b.delete(key));
      },
      commit: async options => {
        for (const batch of batches) {
          await batch.commit(options);
        }
      }
    };
  }
  query(q, options) {
    return this.stores[this.stores.length - 1].query(q, options);
  }
  queryKeys(q, options) {
    return this.stores[this.stores.length - 1].queryKeys(q, options);
  }
}