import filter from 'it-filter';
import take from 'it-take';
import merge from 'it-merge';
import { BaseDatastore } from './base.js';
import { KeyTransformDatastore } from './keytransform.js';
import * as Errors from './errors.js';
import {
  sortAll,
  replaceStartWith
} from './utils.js';
import { Key } from 'interface-datastore/key';
export class MountDatastore extends BaseDatastore {
  constructor(mounts) {
    super();
    this.mounts = mounts.slice();
  }
  async open() {
    await Promise.all(this.mounts.map(m => m.datastore.open()));
  }
  _lookup(key) {
    for (const mount of this.mounts) {
      if (mount.prefix.toString() === key.toString() || mount.prefix.isAncestorOf(key)) {
        const s = replaceStartWith(key.toString(), mount.prefix.toString());
        return {
          datastore: mount.datastore,
          mountpoint: mount.prefix,
          rest: new Key(s)
        };
      }
    }
  }
  put(key, value, options) {
    const match = this._lookup(key);
    if (match == null) {
      throw Errors.dbWriteFailedError(new Error('No datastore mounted for this key'));
    }
    return match.datastore.put(match.rest, value, options);
  }
  get(key, options) {
    const match = this._lookup(key);
    if (match == null) {
      throw Errors.notFoundError(new Error('No datastore mounted for this key'));
    }
    return match.datastore.get(match.rest, options);
  }
  has(key, options) {
    const match = this._lookup(key);
    if (match == null) {
      return Promise.resolve(false);
    }
    return match.datastore.has(match.rest, options);
  }
  delete(key, options) {
    const match = this._lookup(key);
    if (match == null) {
      throw Errors.dbDeleteFailedError(new Error('No datastore mounted for this key'));
    }
    return match.datastore.delete(match.rest, options);
  }
  async close() {
    await Promise.all(this.mounts.map(m => {
      return m.datastore.close();
    }));
  }
  batch() {
    const batchMounts = {};
    const lookup = key => {
      const match = this._lookup(key);
      if (match == null) {
        throw new Error('No datastore mounted for this key');
      }
      const m = match.mountpoint.toString();
      if (batchMounts[m] == null) {
        batchMounts[m] = match.datastore.batch();
      }
      return {
        batch: batchMounts[m],
        rest: match.rest
      };
    };
    return {
      put: (key, value) => {
        const match = lookup(key);
        match.batch.put(match.rest, value);
      },
      delete: key => {
        const match = lookup(key);
        match.batch.delete(match.rest);
      },
      commit: async options => {
        await Promise.all(Object.keys(batchMounts).map(p => batchMounts[p].commit(options)));
      }
    };
  }
  query(q, options) {
    const qs = this.mounts.map(m => {
      const ks = new KeyTransformDatastore(m.datastore, {
        convert: key => {
          throw new Error('should never be called');
        },
        invert: key => {
          return m.prefix.child(key);
        }
      });
      let prefix;
      if (q.prefix != null) {
        prefix = replaceStartWith(q.prefix, m.prefix.toString());
      }
      return ks.query({
        prefix: prefix,
        filters: q.filters
      }, options);
    });
    let it = merge(...qs);
    if (q.filters)
      q.filters.forEach(f => {
        it = filter(it, f);
      });
    if (q.orders)
      q.orders.forEach(o => {
        it = sortAll(it, o);
      });
    if (q.offset != null) {
      let i = 0;
      it = filter(it, () => i++ >= q.offset);
    }
    if (q.limit != null)
      it = take(it, q.limit);
    return it;
  }
  queryKeys(q, options) {
    const qs = this.mounts.map(m => {
      const ks = new KeyTransformDatastore(m.datastore, {
        convert: key => {
          throw new Error('should never be called');
        },
        invert: key => {
          return m.prefix.child(key);
        }
      });
      let prefix;
      if (q.prefix != null) {
        prefix = replaceStartWith(q.prefix, m.prefix.toString());
      }
      return ks.queryKeys({
        prefix: prefix,
        filters: q.filters
      }, options);
    });
    let it = merge(...qs);
    if (q.filters)
      q.filters.forEach(f => {
        it = filter(it, f);
      });
    if (q.orders)
      q.orders.forEach(o => {
        it = sortAll(it, o);
      });
    if (q.offset != null) {
      let i = 0;
      it = filter(it, () => i++ >= q.offset);
    }
    if (q.limit != null)
      it = take(it, q.limit);
    return it;
  }
}