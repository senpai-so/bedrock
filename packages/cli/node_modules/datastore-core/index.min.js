(function (root, factory) {(typeof module === 'object' && module.exports) ? module.exports = factory() : root.DatastoreCore = factory()}(typeof self !== 'undefined' ? self : this, function () {
var DatastoreCore=(()=>{var hr=Object.create;var le=Object.defineProperty;var dr=Object.getOwnPropertyDescriptor;var pr=Object.getOwnPropertyNames;var mr=Object.getPrototypeOf,yr=Object.prototype.hasOwnProperty;var ut=r=>le(r,"__esModule",{value:!0});var v=(r,e)=>()=>(e||r((e={exports:{}}).exports,e),e.exports),C=(r,e)=>{ut(r);for(var t in e)le(r,t,{get:e[t],enumerable:!0})},br=(r,e,t)=>{if(e&&typeof e=="object"||typeof e=="function")for(let s of pr(e))!yr.call(r,s)&&s!=="default"&&le(r,s,{get:()=>e[s],enumerable:!(t=dr(e,s))||t.enumerable});return r},F=r=>br(ut(le(r!=null?hr(mr(r)):{},"default",r&&r.__esModule&&"default"in r?{get:()=>r.default,enumerable:!0}:{value:r,enumerable:!0})),r);var dt=v((Zs,ht)=>{"use strict";function lt(r,e){for(let t in e)Object.defineProperty(r,t,{value:e[t],enumerable:!0,configurable:!0});return r}function gr(r,e,t){if(!r||typeof r=="string")throw new TypeError("Please pass an Error to err-code");t||(t={}),typeof e=="object"&&(t=e,e=""),e&&(t.code=e);try{return lt(r,t)}catch(s){t.message=r.message,t.stack=r.stack;let n=function(){};return n.prototype=Object.create(Object.getPrototypeOf(r)),lt(new n,t)}}ht.exports=gr});var Bt=v((to,zt)=>{"use strict";var js=async r=>{let e=[];for await(let t of r)e.push(t);return e};zt.exports=js});var He=v((so,Vt)=>{"use strict";var As=async r=>{for await(let e of r);};Vt.exports=As});var Xe=v((no,Wt)=>{"use strict";var Ds=async function*(r,e){for await(let t of r)await e(t)&&(yield t)};Wt.exports=Ds});var Ye=v((oo,Jt)=>{"use strict";var Is=async function*(r,e){let t=0;if(!(e<1)){for await(let s of r)if(yield s,t++,t===e)return}};Jt.exports=Is});var Ht=v((ho,Gt)=>{"use strict";var ks=async function*(r,e){for await(let t of r)yield e(t)};Gt.exports=ks});var Zt=v((po,X)=>{var Xt=(...r)=>{let e;for(;r.length;)e=r.shift()(e);return e},et=r=>r&&(typeof r[Symbol.asyncIterator]=="function"||typeof r[Symbol.iterator]=="function"||typeof r.next=="function"),Se=r=>r&&typeof r.sink=="function"&&et(r.source),Ms=r=>e=>(r.sink(e),r.source),Yt=(...r)=>{if(Se(r[0])){let e=r[0];r[0]=()=>e.source}else if(et(r[0])){let e=r[0];r[0]=()=>e}if(r.length>1&&Se(r[r.length-1])&&(r[r.length-1]=r[r.length-1].sink),r.length>2)for(let e=1;e<r.length-1;e++)Se(r[e])&&(r[e]=Ms(r[e]));return Xt(...r)};X.exports=Yt;X.exports.pipe=Yt;X.exports.rawPipe=Xt;X.exports.isIterable=et;X.exports.isDuplex=Se});var qt=v((jo,Qt)=>{Qt.exports=class{constructor(e){if(!(e>0)||(e-1&e)!=0)throw new Error("Max size for a FixedFIFO should be a power of two");this.buffer=new Array(e),this.mask=e-1,this.top=0,this.btm=0,this.next=null}push(e){return this.buffer[this.top]!==void 0?!1:(this.buffer[this.top]=e,this.top=this.top+1&this.mask,!0)}shift(){let e=this.buffer[this.btm];if(e!==void 0)return this.buffer[this.btm]=void 0,this.btm=this.btm+1&this.mask,e}isEmpty(){return this.buffer[this.btm]===void 0}}});var rr=v((Do,tr)=>{var er=qt();tr.exports=class{constructor(e){this.hwm=e||16,this.head=new er(this.hwm),this.tail=this.head}push(e){if(!this.head.push(e)){let t=this.head;this.head=t.next=new er(2*this.head.buffer.length),this.head.push(e)}}shift(){let e=this.tail.shift();if(e===void 0&&this.tail.next){let t=this.tail.next;return this.tail.next=null,this.tail=t,this.tail.shift()}return e}isEmpty(){return this.head.isEmpty()}}});var rt=v((Io,sr)=>{var tt=rr();sr.exports=r=>{r=r||{};let e;typeof r=="function"?(e=r,r={}):e=r.onEnd;let t=new tt,s,n,o,i=()=>{if(!t.isEmpty()){if(r.writev){let h,d=[];for(;!t.isEmpty();){if(h=t.shift(),h.error)throw h.error;d.push(h.value)}return{done:h.done,value:d}}let a=t.shift();if(a.error)throw a.error;return a}return o?{done:!0}:new Promise((a,h)=>{n=d=>(n=null,d.error?h(d.error):r.writev&&!d.done?a({done:d.done,value:[d.value]}):a(d),s)})},f=a=>n?n(a):(t.push(a),s),l=a=>(t=new tt,n?n({error:a}):(t.push({error:a}),s)),E=a=>o?s:f({done:!1,value:a}),c=a=>o?s:(o=!0,a?l(a):f({done:!0})),u=()=>(t=new tt,c(),{done:!0}),m=a=>(c(a),{done:!0});if(s={[Symbol.asyncIterator](){return this},next:i,return:u,throw:m,push:E,end:c},!e)return s;let M=s;return s={[Symbol.asyncIterator](){return this},next(){return M.next()},throw(a){return M.throw(a),e&&(e(a),e=null),{done:!0}},return(){return M.return(),e&&(e(),e=null),{done:!0}},push:E,end(a){return M.end(a),e&&(e(a),e=null),s}},s}});var or=v((ko,nr)=>{"use strict";var _s=rt(),Ns=async function*(...r){let e=_s();setTimeout(async()=>{try{await Promise.all(r.map(async t=>{for await(let s of t)e.push(s)})),e.end()}catch(t){e.end(t)}},0),yield*e};nr.exports=Ns});var ar=v((Lo,ir)=>{var Z=1e3,Q=Z*60,q=Q*60,B=q*24,Os=B*7,Rs=B*365.25;ir.exports=function(r,e){e=e||{};var t=typeof r;if(t==="string"&&r.length>0)return Us(r);if(t==="number"&&isFinite(r))return e.long?Ts(r):Ls(r);throw new Error("val is not a non-empty string or a valid number. val="+JSON.stringify(r))};function Us(r){if(r=String(r),!(r.length>100)){var e=/^(-?(?:\d+)?\.?\d+) *(milliseconds?|msecs?|ms|seconds?|secs?|s|minutes?|mins?|m|hours?|hrs?|h|days?|d|weeks?|w|years?|yrs?|y)?$/i.exec(r);if(!!e){var t=parseFloat(e[1]),s=(e[2]||"ms").toLowerCase();switch(s){case"years":case"year":case"yrs":case"yr":case"y":return t*Rs;case"weeks":case"week":case"w":return t*Os;case"days":case"day":case"d":return t*B;case"hours":case"hour":case"hrs":case"hr":case"h":return t*q;case"minutes":case"minute":case"mins":case"min":case"m":return t*Q;case"seconds":case"second":case"secs":case"sec":case"s":return t*Z;case"milliseconds":case"millisecond":case"msecs":case"msec":case"ms":return t;default:return}}}}function Ls(r){var e=Math.abs(r);return e>=B?Math.round(r/B)+"d":e>=q?Math.round(r/q)+"h":e>=Q?Math.round(r/Q)+"m":e>=Z?Math.round(r/Z)+"s":r+"ms"}function Ts(r){var e=Math.abs(r);return e>=B?je(r,e,B,"day"):e>=q?je(r,e,q,"hour"):e>=Q?je(r,e,Q,"minute"):e>=Z?je(r,e,Z,"second"):r+" ms"}function je(r,e,t,s){var n=e>=t*1.5;return Math.round(r/t)+" "+s+(n?"s":"")}});var fr=v((To,cr)=>{function Ps(r){t.debug=t,t.default=t,t.coerce=l,t.disable=o,t.enable=n,t.enabled=i,t.humanize=ar(),t.destroy=E,Object.keys(r).forEach(c=>{t[c]=r[c]}),t.names=[],t.skips=[],t.formatters={};function e(c){let u=0;for(let m=0;m<c.length;m++)u=(u<<5)-u+c.charCodeAt(m),u|=0;return t.colors[Math.abs(u)%t.colors.length]}t.selectColor=e;function t(c){let u,m=null,M,a;function h(...d){if(!h.enabled)return;let b=h,x=Number(new Date),D=x-(u||x);b.diff=D,b.prev=u,b.curr=x,u=x,d[0]=t.coerce(d[0]),typeof d[0]!="string"&&d.unshift("%O");let w=0;d[0]=d[0].replace(/%([a-zA-Z%])/g,(I,S)=>{if(I==="%%")return"%";w++;let k=t.formatters[S];if(typeof k=="function"){let $=d[w];I=k.call(b,$),d.splice(w,1),w--}return I}),t.formatArgs.call(b,d),(b.log||t.log).apply(b,d)}return h.namespace=c,h.useColors=t.useColors(),h.color=t.selectColor(c),h.extend=s,h.destroy=t.destroy,Object.defineProperty(h,"enabled",{enumerable:!0,configurable:!1,get:()=>m!==null?m:(M!==t.namespaces&&(M=t.namespaces,a=t.enabled(c)),a),set:d=>{m=d}}),typeof t.init=="function"&&t.init(h),h}function s(c,u){let m=t(this.namespace+(typeof u=="undefined"?":":u)+c);return m.log=this.log,m}function n(c){t.save(c),t.namespaces=c,t.names=[],t.skips=[];let u,m=(typeof c=="string"?c:"").split(/[\s,]+/),M=m.length;for(u=0;u<M;u++)!m[u]||(c=m[u].replace(/\*/g,".*?"),c[0]==="-"?t.skips.push(new RegExp("^"+c.substr(1)+"$")):t.names.push(new RegExp("^"+c+"$")))}function o(){let c=[...t.names.map(f),...t.skips.map(f).map(u=>"-"+u)].join(",");return t.enable(""),c}function i(c){if(c[c.length-1]==="*")return!0;let u,m;for(u=0,m=t.skips.length;u<m;u++)if(t.skips[u].test(c))return!1;for(u=0,m=t.names.length;u<m;u++)if(t.names[u].test(c))return!0;return!1}function f(c){return c.toString().substring(2,c.toString().length-2).replace(/\.\*\?$/,"*")}function l(c){return c instanceof Error?c.stack||c.message:c}function E(){console.warn("Instance method `debug.destroy()` is deprecated and no longer does anything. It will be removed in the next major version of `debug`.")}return t.enable(t.load()),t}cr.exports=Ps});var ur=v((A,Ae)=>{A.formatArgs=zs;A.save=Bs;A.load=$s;A.useColors=Ks;A.storage=Vs();A.destroy=(()=>{let r=!1;return()=>{r||(r=!0,console.warn("Instance method `debug.destroy()` is deprecated and no longer does anything. It will be removed in the next major version of `debug`."))}})();A.colors=["#0000CC","#0000FF","#0033CC","#0033FF","#0066CC","#0066FF","#0099CC","#0099FF","#00CC00","#00CC33","#00CC66","#00CC99","#00CCCC","#00CCFF","#3300CC","#3300FF","#3333CC","#3333FF","#3366CC","#3366FF","#3399CC","#3399FF","#33CC00","#33CC33","#33CC66","#33CC99","#33CCCC","#33CCFF","#6600CC","#6600FF","#6633CC","#6633FF","#66CC00","#66CC33","#9900CC","#9900FF","#9933CC","#9933FF","#99CC00","#99CC33","#CC0000","#CC0033","#CC0066","#CC0099","#CC00CC","#CC00FF","#CC3300","#CC3333","#CC3366","#CC3399","#CC33CC","#CC33FF","#CC6600","#CC6633","#CC9900","#CC9933","#CCCC00","#CCCC33","#FF0000","#FF0033","#FF0066","#FF0099","#FF00CC","#FF00FF","#FF3300","#FF3333","#FF3366","#FF3399","#FF33CC","#FF33FF","#FF6600","#FF6633","#FF9900","#FF9933","#FFCC00","#FFCC33"];function Ks(){return typeof window!="undefined"&&window.process&&(window.process.type==="renderer"||window.process.__nwjs)?!0:typeof navigator!="undefined"&&navigator.userAgent&&navigator.userAgent.toLowerCase().match(/(edge|trident)\/(\d+)/)?!1:typeof document!="undefined"&&document.documentElement&&document.documentElement.style&&document.documentElement.style.WebkitAppearance||typeof window!="undefined"&&window.console&&(window.console.firebug||window.console.exception&&window.console.table)||typeof navigator!="undefined"&&navigator.userAgent&&navigator.userAgent.toLowerCase().match(/firefox\/(\d+)/)&&parseInt(RegExp.$1,10)>=31||typeof navigator!="undefined"&&navigator.userAgent&&navigator.userAgent.toLowerCase().match(/applewebkit\/(\d+)/)}function zs(r){if(r[0]=(this.useColors?"%c":"")+this.namespace+(this.useColors?" %c":" ")+r[0]+(this.useColors?"%c ":" ")+"+"+Ae.exports.humanize(this.diff),!this.useColors)return;let e="color: "+this.color;r.splice(1,0,e,"color: inherit");let t=0,s=0;r[0].replace(/%[a-zA-Z%]/g,n=>{n!=="%%"&&(t++,n==="%c"&&(s=t))}),r.splice(s,0,e)}A.log=console.debug||console.log||(()=>{});function Bs(r){try{r?A.storage.setItem("debug",r):A.storage.removeItem("debug")}catch(e){}}function $s(){let r;try{r=A.storage.getItem("debug")}catch(e){}return!r&&typeof process!="undefined"&&"env"in process&&(r=process.env.DEBUG),r}function Vs(){try{return localStorage}catch(r){}}Ae.exports=fr()(A);var{formatters:Ws}=Ae.exports;Ws.j=function(r){try{return JSON.stringify(r)}catch(e){return"[UnexpectedJSONParseError]: "+e.message}}});var Xs={};C(Xs,{BaseDatastore:()=>j,Errors:()=>Gs,KeyTransformDatastore:()=>O,MemoryDatastore:()=>qe,MountDatastore:()=>ot,NamespaceDatastore:()=>ft,ShardingDatastore:()=>P,TieredDatastore:()=>ct,shard:()=>Hs});var De={};C(De,{abortedError:()=>wr,dbDeleteFailedError:()=>te,dbOpenFailedError:()=>ee,dbWriteFailedError:()=>re,notFoundError:()=>K});var V=F(dt());function ee(r){return r=r||new Error("Cannot open database"),(0,V.default)(r,"ERR_DB_OPEN_FAILED")}function te(r){return r=r||new Error("Delete failed"),(0,V.default)(r,"ERR_DB_DELETE_FAILED")}function re(r){return r=r||new Error("Write failed"),(0,V.default)(r,"ERR_DB_WRITE_FAILED")}function K(r){return r=r||new Error("Not Found"),(0,V.default)(r,"ERR_NOT_FOUND")}function wr(r){return r=r||new Error("Aborted"),(0,V.default)(r,"ERR_ABORTED")}var Ge={};C(Ge,{NextToLast:()=>Je,PREFIX:()=>xe,Prefix:()=>Ve,README_FN:()=>$e,SHARDING_FN:()=>ve,ShardBase:()=>ce,Suffix:()=>We,parseShardFun:()=>Kt,readShardFun:()=>Ce,readme:()=>we});var pt=(r=21)=>{let e="",t=crypto.getRandomValues(new Uint8Array(r));for(;r--;){let s=t[r]&63;s<36?e+=s.toString(36):s<62?e+=(s-26).toString(36).toUpperCase():s<63?e+="_":e+="-"}return e};var Ie={};C(Ie,{identity:()=>Fr});function xr(r,e){if(r.length>=255)throw new TypeError("Alphabet too long");for(var t=new Uint8Array(256),s=0;s<t.length;s++)t[s]=255;for(var n=0;n<r.length;n++){var o=r.charAt(n),i=o.charCodeAt(0);if(t[i]!==255)throw new TypeError(o+" is ambiguous");t[i]=n}var f=r.length,l=r.charAt(0),E=Math.log(f)/Math.log(256),c=Math.log(256)/Math.log(f);function u(a){if(a instanceof Uint8Array||(ArrayBuffer.isView(a)?a=new Uint8Array(a.buffer,a.byteOffset,a.byteLength):Array.isArray(a)&&(a=Uint8Array.from(a))),!(a instanceof Uint8Array))throw new TypeError("Expected Uint8Array");if(a.length===0)return"";for(var h=0,d=0,b=0,x=a.length;b!==x&&a[b]===0;)b++,h++;for(var D=(x-b)*c+1>>>0,w=new Uint8Array(D);b!==x;){for(var _=a[b],I=0,S=D-1;(_!==0||I<d)&&S!==-1;S--,I++)_+=256*w[S]>>>0,w[S]=_%f>>>0,_=_/f>>>0;if(_!==0)throw new Error("Non-zero carry");d=I,b++}for(var k=D-d;k!==D&&w[k]===0;)k++;for(var $=l.repeat(h);k<D;++k)$+=r.charAt(w[k]);return $}function m(a){if(typeof a!="string")throw new TypeError("Expected String");if(a.length===0)return new Uint8Array;var h=0;if(a[h]!==" "){for(var d=0,b=0;a[h]===l;)d++,h++;for(var x=(a.length-h)*E+1>>>0,D=new Uint8Array(x);a[h];){var w=t[a.charCodeAt(h)];if(w===255)return;for(var _=0,I=x-1;(w!==0||_<b)&&I!==-1;I--,_++)w+=f*D[I]>>>0,D[I]=w%256>>>0,w=w/256>>>0;if(w!==0)throw new Error("Non-zero carry");b=_,h++}if(a[h]!==" "){for(var S=x-b;S!==x&&D[S]===0;)S++;for(var k=new Uint8Array(d+(x-S)),$=d;S!==x;)k[$++]=D[S++];return k}}}function M(a){var h=m(a);if(h)return h;throw new Error(`Non-${e} character`)}return{encode:u,decodeUnsafe:m,decode:M}}var vr=xr,Cr=vr,mt=Cr;var sn=new Uint8Array(0);var yt=(r,e)=>{if(r===e)return!0;if(r.byteLength!==e.byteLength)return!1;for(let t=0;t<r.byteLength;t++)if(r[t]!==e[t])return!1;return!0},R=r=>{if(r instanceof Uint8Array&&r.constructor.name==="Uint8Array")return r;if(r instanceof ArrayBuffer)return new Uint8Array(r);if(ArrayBuffer.isView(r))return new Uint8Array(r.buffer,r.byteOffset,r.byteLength);throw new Error("Unknown type, must be binary type")};var bt=r=>new TextEncoder().encode(r),gt=r=>new TextDecoder().decode(r);var xt=class{constructor(e,t,s){this.name=e,this.prefix=t,this.baseEncode=s}encode(e){if(e instanceof Uint8Array)return`${this.prefix}${this.baseEncode(e)}`;throw Error("Unknown type, must be binary type")}},vt=class{constructor(e,t,s){this.name=e,this.prefix=t,this.baseDecode=s}decode(e){if(typeof e=="string")switch(e[0]){case this.prefix:return this.baseDecode(e.slice(1));default:throw Error(`Unable to decode multibase string ${JSON.stringify(e)}, ${this.name} decoder only supports inputs prefixed with ${this.prefix}`)}else throw Error("Can only multibase decode strings")}or(e){let t={[this.prefix]:this,...e.decoders||{[e.prefix]:e}};return new he(t)}},he=class{constructor(e){this.decoders=e}or(e){let t=e.decoders||{[e.prefix]:e};return new he({...this.decoders,...t})}decode(e){let t=e[0],s=this.decoders[t];if(s)return s.decode(e);throw RangeError(`Unable to decode multibase string ${JSON.stringify(e)}, only inputs prefixed with ${Object.keys(this.decoders)} are supported`)}},Ct=class{constructor(e,t,s,n){this.name=e,this.prefix=t,this.baseEncode=s,this.baseDecode=n,this.encoder=new xt(e,t,s),this.decoder=new vt(e,t,n)}encode(e){return this.encoder.encode(e)}decode(e){return this.decoder.decode(e)}},de=({name:r,prefix:e,encode:t,decode:s})=>new Ct(r,e,t,s),L=({prefix:r,name:e,alphabet:t})=>{let{encode:s,decode:n}=mt(t,e);return de({prefix:r,name:e,encode:s,decode:o=>R(n(o))})},Er=(r,e,t,s)=>{let n={};for(let c=0;c<e.length;++c)n[e[c]]=c;let o=r.length;for(;r[o-1]==="=";)--o;let i=new Uint8Array(o*t/8|0),f=0,l=0,E=0;for(let c=0;c<o;++c){let u=n[r[c]];if(u===void 0)throw new SyntaxError(`Non-${s} character`);l=l<<t|u,f+=t,f>=8&&(f-=8,i[E++]=255&l>>f)}if(f>=t||255&l<<8-f)throw new SyntaxError("Unexpected end of data");return i},Sr=(r,e,t)=>{let s=e[e.length-1]==="=",n=(1<<t)-1,o="",i=0,f=0;for(let l=0;l<r.length;++l)for(f=f<<8|r[l],i+=8;i>t;)i-=t,o+=e[n&f>>i];if(i&&(o+=e[n&f<<t-i]),s)for(;o.length*t&7;)o+="=";return o},y=({name:r,prefix:e,bitsPerChar:t,alphabet:s})=>de({prefix:e,name:r,encode(n){return Sr(n,s,t)},decode(n){return Er(n,s,t,r)}});var Fr=de({prefix:"\0",name:"identity",encode:r=>gt(r),decode:r=>bt(r)});var ke={};C(ke,{base2:()=>jr});var jr=y({prefix:"0",name:"base2",alphabet:"01",bitsPerChar:1});var Me={};C(Me,{base8:()=>Ar});var Ar=y({prefix:"7",name:"base8",alphabet:"01234567",bitsPerChar:3});var _e={};C(_e,{base10:()=>Dr});var Dr=L({prefix:"9",name:"base10",alphabet:"0123456789"});var Ne={};C(Ne,{base16:()=>Ir,base16upper:()=>kr});var Ir=y({prefix:"f",name:"base16",alphabet:"0123456789abcdef",bitsPerChar:4}),kr=y({prefix:"F",name:"base16upper",alphabet:"0123456789ABCDEF",bitsPerChar:4});var Oe={};C(Oe,{base32:()=>W,base32hex:()=>Or,base32hexpad:()=>Ur,base32hexpadupper:()=>Lr,base32hexupper:()=>Rr,base32pad:()=>_r,base32padupper:()=>Nr,base32upper:()=>Mr,base32z:()=>Tr});var W=y({prefix:"b",name:"base32",alphabet:"abcdefghijklmnopqrstuvwxyz234567",bitsPerChar:5}),Mr=y({prefix:"B",name:"base32upper",alphabet:"ABCDEFGHIJKLMNOPQRSTUVWXYZ234567",bitsPerChar:5}),_r=y({prefix:"c",name:"base32pad",alphabet:"abcdefghijklmnopqrstuvwxyz234567=",bitsPerChar:5}),Nr=y({prefix:"C",name:"base32padupper",alphabet:"ABCDEFGHIJKLMNOPQRSTUVWXYZ234567=",bitsPerChar:5}),Or=y({prefix:"v",name:"base32hex",alphabet:"0123456789abcdefghijklmnopqrstuv",bitsPerChar:5}),Rr=y({prefix:"V",name:"base32hexupper",alphabet:"0123456789ABCDEFGHIJKLMNOPQRSTUV",bitsPerChar:5}),Ur=y({prefix:"t",name:"base32hexpad",alphabet:"0123456789abcdefghijklmnopqrstuv=",bitsPerChar:5}),Lr=y({prefix:"T",name:"base32hexpadupper",alphabet:"0123456789ABCDEFGHIJKLMNOPQRSTUV=",bitsPerChar:5}),Tr=y({prefix:"h",name:"base32z",alphabet:"ybndrfg8ejkmcpqxot1uwisza345h769",bitsPerChar:5});var Re={};C(Re,{base36:()=>Pr,base36upper:()=>Kr});var Pr=L({prefix:"k",name:"base36",alphabet:"0123456789abcdefghijklmnopqrstuvwxyz"}),Kr=L({prefix:"K",name:"base36upper",alphabet:"0123456789ABCDEFGHIJKLMNOPQRSTUVWXYZ"});var Ue={};C(Ue,{base58btc:()=>N,base58flickr:()=>zr});var N=L({name:"base58btc",prefix:"z",alphabet:"123456789ABCDEFGHJKLMNPQRSTUVWXYZabcdefghijkmnopqrstuvwxyz"}),zr=L({name:"base58flickr",prefix:"Z",alphabet:"123456789abcdefghijkmnopqrstuvwxyzABCDEFGHJKLMNPQRSTUVWXYZ"});var Le={};C(Le,{base64:()=>Br,base64pad:()=>$r,base64url:()=>Vr,base64urlpad:()=>Wr});var Br=y({prefix:"m",name:"base64",alphabet:"ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/",bitsPerChar:6}),$r=y({prefix:"M",name:"base64pad",alphabet:"ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/=",bitsPerChar:6}),Vr=y({prefix:"u",name:"base64url",alphabet:"ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789-_",bitsPerChar:6}),Wr=y({prefix:"U",name:"base64urlpad",alphabet:"ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789-_=",bitsPerChar:6});var Pe={};C(Pe,{sha256:()=>us,sha512:()=>ls});var Jr=St,Et=128,Gr=127,Hr=~Gr,Xr=Math.pow(2,31);function St(r,e,t){e=e||[],t=t||0;for(var s=t;r>=Xr;)e[t++]=r&255|Et,r/=128;for(;r&Hr;)e[t++]=r&255|Et,r>>>=7;return e[t]=r|0,St.bytes=t-s+1,e}var Yr=Te,Zr=128,Ft=127;function Te(r,e){var t=0,e=e||0,s=0,n=e,o,i=r.length;do{if(n>=i)throw Te.bytes=0,new RangeError("Could not decode varint");o=r[n++],t+=s<28?(o&Ft)<<s:(o&Ft)*Math.pow(2,s),s+=7}while(o>=Zr);return Te.bytes=n-e,t}var Qr=Math.pow(2,7),qr=Math.pow(2,14),es=Math.pow(2,21),ts=Math.pow(2,28),rs=Math.pow(2,35),ss=Math.pow(2,42),ns=Math.pow(2,49),os=Math.pow(2,56),is=Math.pow(2,63),as=function(r){return r<Qr?1:r<qr?2:r<es?3:r<ts?4:r<rs?5:r<ss?6:r<ns?7:r<os?8:r<is?9:10},cs={encode:Jr,decode:Yr,encodingLength:as},fs=cs,se=fs;var ne=r=>[se.decode(r),se.decode.bytes],J=(r,e,t=0)=>(se.encode(r,e,t),e),G=r=>se.encodingLength(r);var pe=(r,e)=>{let t=e.byteLength,s=G(r),n=s+G(t),o=new Uint8Array(n+t);return J(r,o,0),J(t,o,s),o.set(e,n),new oe(r,t,e,o)},At=r=>{let e=R(r),[t,s]=ne(e),[n,o]=ne(e.subarray(s)),i=e.subarray(s+o);if(i.byteLength!==n)throw new Error("Incorrect length");return new oe(t,n,i,e)},Dt=(r,e)=>r===e?!0:r.code===e.code&&r.size===e.size&&yt(r.bytes,e.bytes),oe=class{constructor(e,t,s,n){this.code=e,this.size=t,this.digest=s,this.bytes=n}};var ie=({name:r,code:e,encode:t})=>new kt(r,e,t),kt=class{constructor(e,t,s){this.name=e,this.code=t,this.encode=s}async digest(e){if(e instanceof Uint8Array){let t=await this.encode(e);return pe(this.code,t)}else throw Error("Unknown type, must be binary type")}};var _t=r=>async e=>new Uint8Array(await crypto.subtle.digest(r,e)),us=ie({name:"sha2-256",code:18,encode:_t("SHA-256")}),ls=ie({name:"sha2-512",code:19,encode:_t("SHA-512")});var Ke={};C(Ke,{identity:()=>hs});var hs=ie({name:"identity",code:0,encode:r=>R(r)});var An=new TextEncoder,Dn=new TextDecoder;var g=class{constructor(e,t,s,n){this.code=t,this.version=e,this.multihash=s,this.bytes=n,this.byteOffset=n.byteOffset,this.byteLength=n.byteLength,this.asCID=this,this._baseCache=new Map,Object.defineProperties(this,{byteOffset:ye,byteLength:ye,code:me,version:me,multihash:me,bytes:me,_baseCache:ye,asCID:ye})}toV0(){switch(this.version){case 0:return this;default:{let{code:e,multihash:t}=this;if(e!==ae)throw new Error("Cannot convert a non dag-pb CID to CIDv0");if(t.code!==gs)throw new Error("Cannot convert non sha2-256 multihash CID to CIDv0");return g.createV0(t)}}}toV1(){switch(this.version){case 0:{let{code:e,digest:t}=this.multihash,s=pe(e,t);return g.createV1(this.code,s)}case 1:return this;default:throw Error(`Can not convert CID version ${this.version} to version 0. This is a bug please report`)}}equals(e){return e&&this.code===e.code&&this.version===e.version&&Dt(this.multihash,e.multihash)}toString(e){let{bytes:t,version:s,_baseCache:n}=this;switch(s){case 0:return ys(t,n,e||N.encoder);default:return bs(t,n,e||W.encoder)}}toJSON(){return{code:this.code,version:this.version,hash:this.multihash.bytes}}get[Symbol.toStringTag](){return"CID"}[Symbol.for("nodejs.util.inspect.custom")](){return"CID("+this.toString()+")"}static isCID(e){return xs(/^0\.0/,vs),!!(e&&(e[Ot]||e.asCID===e))}get toBaseEncodedString(){throw new Error("Deprecated, use .toString()")}get codec(){throw new Error('"codec" property is deprecated, use integer "code" property instead')}get buffer(){throw new Error("Deprecated .buffer property, use .bytes to get Uint8Array instead")}get multibaseName(){throw new Error('"multibaseName" property is deprecated')}get prefix(){throw new Error('"prefix" property is deprecated')}static asCID(e){if(e instanceof g)return e;if(e!=null&&e.asCID===e){let{version:t,code:s,multihash:n,bytes:o}=e;return new g(t,s,n,o||Nt(t,s,n.bytes))}else if(e!=null&&e[Ot]===!0){let{version:t,multihash:s,code:n}=e,o=At(s);return g.create(t,n,o)}else return null}static create(e,t,s){if(typeof t!="number")throw new Error("String codecs are no longer supported");switch(e){case 0:{if(t!==ae)throw new Error(`Version 0 CID must use dag-pb (code: ${ae}) block encoding`);return new g(e,t,s,s.bytes)}case 1:{let n=Nt(e,t,s.bytes);return new g(e,t,s,n)}default:throw new Error("Invalid version")}}static createV0(e){return g.create(0,ae,e)}static createV1(e,t){return g.create(1,e,t)}static decode(e){let[t,s]=g.decodeFirst(e);if(s.length)throw new Error("Incorrect length");return t}static decodeFirst(e){let t=g.inspectBytes(e),s=t.size-t.multihashSize,n=R(e.subarray(s,s+t.multihashSize));if(n.byteLength!==t.multihashSize)throw new Error("Incorrect length");let o=n.subarray(t.multihashSize-t.digestSize),i=new oe(t.multihashCode,t.digestSize,o,n);return[t.version===0?g.createV0(i):g.createV1(t.codec,i),e.subarray(t.size)]}static inspectBytes(e){let t=0,s=()=>{let[u,m]=ne(e.subarray(t));return t+=m,u},n=s(),o=ae;if(n===18?(n=0,t=0):n===1&&(o=s()),n!==0&&n!==1)throw new RangeError(`Invalid CID version ${n}`);let i=t,f=s(),l=s(),E=t+l,c=E-i;return{version:n,codec:o,multihashCode:f,digestSize:l,multihashSize:c,size:E}}static parse(e,t){let[s,n]=ms(e,t),o=g.decode(n);return o._baseCache.set(s,e),o}},ms=(r,e)=>{switch(r[0]){case"Q":{let t=e||N;return[N.prefix,t.decode(`${N.prefix}${r}`)]}case N.prefix:{let t=e||N;return[N.prefix,t.decode(r)]}case W.prefix:{let t=e||W;return[W.prefix,t.decode(r)]}default:{if(e==null)throw Error("To parse non base32 or base58btc encoded CID multibase decoder must be provided");return[r[0],e.decode(r)]}}},ys=(r,e,t)=>{let{prefix:s}=t;if(s!==N.prefix)throw Error(`Cannot string encode V0 in ${t.name} encoding`);let n=e.get(s);if(n==null){let o=t.encode(r).slice(1);return e.set(s,o),o}else return n},bs=(r,e,t)=>{let{prefix:s}=t,n=e.get(s);if(n==null){let o=t.encode(r);return e.set(s,o),o}else return n},ae=112,gs=18,Nt=(r,e,t)=>{let s=G(r),n=s+G(e),o=new Uint8Array(n+t.byteLength);return J(r,o,0),J(e,o,s),o.set(t,n),o},Ot=Symbol.for("@ipld/js-cid/CID"),me={writable:!1,configurable:!1,enumerable:!0},ye={writable:!1,enumerable:!1,configurable:!1},ws="0.0.0-dev",xs=(r,e)=>{if(r.test(ws))console.warn(e);else throw new Error(e)},vs=`CID.isCID(v) is deprecated and will be removed in the next major release.
Following code pattern:

if (CID.isCID(value)) {
  doSomethingWithCID(value)
}

Is replaced with:

const cid = CID.asCID(value)
if (cid) {
  // Make sure to use cid instead of value
  doSomethingWithCID(cid)
}
`;var ze={...Ie,...ke,...Me,..._e,...Ne,...Oe,...Re,...Ue,...Le},Tn={...Pe,...Ke};function Rt(r,e,t,s){return{name:r,prefix:e,encoder:{name:r,prefix:e,encode:t},decoder:{decode:s}}}var Ut=Rt("utf8","u",r=>{let e=new TextDecoder("utf8");return"u"+e.decode(r)},r=>new TextEncoder().encode(r.substring(1))),Be=Rt("ascii","a",r=>{let e="a";for(let t=0;t<r.length;t++)e+=String.fromCharCode(r[t]);return e},r=>{r=r.substring(1);let e=new Uint8Array(r.length);for(let t=0;t<r.length;t++)e[t]=r.charCodeAt(t);return e}),Cs={utf8:Ut,"utf-8":Ut,hex:ze.base16,latin1:Be,ascii:Be,binary:Be,...ze},be=Cs;function Lt(r,e="utf8"){let t=be[e];if(!t)throw new Error(`Unsupported encoding "${e}"`);return t.encoder.encode(r).substring(1)}function Tt(r,e="utf8"){let t=be[e];if(!t)throw new Error(`Unsupported encoding "${e}"`);return t.decoder.decode(`${t.prefix}${r}`)}var U="/",Pt=new TextEncoder().encode(U),ge=Pt[0],p=class{constructor(e,t){if(typeof e=="string")this._buf=Tt(e);else if(e instanceof Uint8Array)this._buf=e;else throw new Error("Invalid key, should be String of Uint8Array");if(t==null&&(t=!0),t&&this.clean(),this._buf.byteLength===0||this._buf[0]!==ge)throw new Error("Invalid key")}toString(e="utf8"){return Lt(this._buf,e)}uint8Array(){return this._buf}get[Symbol.toStringTag](){return`Key(${this.toString()})`}static withNamespaces(e){return new p(e.join(U))}static random(){return new p(pt().replace(/-/g,""))}clean(){if((!this._buf||this._buf.byteLength===0)&&(this._buf=Pt),this._buf[0]!==ge){let e=new Uint8Array(this._buf.byteLength+1);e.fill(ge,0,1),e.set(this._buf,1),this._buf=e}for(;this._buf.byteLength>1&&this._buf[this._buf.byteLength-1]===ge;)this._buf=this._buf.subarray(0,-1)}less(e){let t=this.list(),s=e.list();for(let n=0;n<t.length;n++){if(s.length<n+1)return!1;let o=t[n],i=s[n];if(o<i)return!0;if(o>i)return!1}return t.length<s.length}reverse(){return p.withNamespaces(this.list().slice().reverse())}namespaces(){return this.list()}baseNamespace(){let e=this.namespaces();return e[e.length-1]}list(){return this.toString().split(U).slice(1)}type(){return Es(this.baseNamespace())}name(){return Ss(this.baseNamespace())}instance(e){return new p(this.toString()+":"+e)}path(){let e=this.parent().toString();return e.endsWith(U)||(e+=U),e+=this.type(),new p(e)}parent(){let e=this.list();return e.length===1?new p(U):new p(e.slice(0,-1).join(U))}child(e){return this.toString()===U?e:e.toString()===U?this:new p(this.toString()+e.toString(),!1)}isAncestorOf(e){return e.toString()===this.toString()?!1:e.toString().startsWith(this.toString())}isDecendantOf(e){return e.toString()===this.toString()?!1:this.toString().startsWith(e.toString())}isTopLevel(){return this.list().length===1}concat(...e){return p.withNamespaces([...this.namespaces(),...Fs(e.map(t=>t.namespaces()))])}};function Es(r){let e=r.split(":");return e.length<2?"":e.slice(0,-1).join(":")}function Ss(r){let e=r.split(":");return e[e.length-1]}function Fs(r){return[].concat(...r)}var we=`This is a repository of IPLD objects. Each IPLD object is in a single file,
named <base32 encoding of cid>.data. Where <base32 encoding of cid> is the
"base32" encoding of the CID (as specified in
https://github.com/multiformats/multibase) without the 'B' prefix.
All the object files are placed in a tree of directories, based on a
function of the CID. This is a form of sharding similar to
the objects directory in git repositories. Previously, we used
prefixes, we now use the next-to-last two charters.
    func NextToLast(base32cid string) {
      nextToLastLen := 2
      offset := len(base32cid) - nextToLastLen - 1
      return str[offset : offset+nextToLastLen]
    }
For example, an object with a base58 CIDv1 of
    zb2rhYSxw4ZjuzgCnWSt19Q94ERaeFhu9uSqRgjSdx9bsgM6f
has a base32 CIDv1 of
    BAFKREIA22FLID5AJ2KU7URG47MDLROZIH6YF2KALU2PWEFPVI37YLKRSCA
and will be placed at
    SC/AFKREIA22FLID5AJ2KU7URG47MDLROZIH6YF2KALU2PWEFPVI37YLKRSCA.data
with 'SC' being the last-to-next two characters and the 'B' at the
beginning of the CIDv1 string is the multibase prefix that is not
stored in the filename.
`;var xe="/repo/flatfs/shard/",ve="SHARDING",$e="_README",ce=class{constructor(e){this.param=e,this.name="base",this._padding=""}fun(e){return"implement me"}toString(){return`${xe}v1/${this.name}/${this.param}`}},Ve=class extends ce{constructor(e){super(e);this._padding="".padStart(e,"_"),this.name="prefix"}fun(e){return(e+this._padding).slice(0,this.param)}},We=class extends ce{constructor(e){super(e);this._padding="".padStart(e,"_"),this.name="suffix"}fun(e){let t=this._padding+e;return t.slice(t.length-this.param)}},Je=class extends ce{constructor(e){super(e);this._padding="".padStart(e+1,"_"),this.name="next-to-last"}fun(e){let t=this._padding+e,s=t.length-this.param-1;return t.slice(s,s+this.param)}};function Kt(r){if(r=r.trim(),r.length===0)throw new Error("empty shard string");if(!r.startsWith(xe))throw new Error(`invalid or no path prefix: ${r}`);let e=r.slice(xe.length).split("/"),t=e[0];if(t!=="v1")throw new Error(`expect 'v1' version, got '${t}'`);let s=e[1];if(!e[2])throw new Error("missing param");let n=parseInt(e[2],10);switch(s){case"prefix":return new Ve(n);case"suffix":return new We(n);case"next-to-last":return new Je(n);default:throw new Error(`unkown sharding function: ${s}`)}}var Ce=async(r,e)=>{let t=new p(r).child(new p(ve)),n=await(typeof e.getRaw=="function"?e.getRaw.bind(e):e.get.bind(e))(t);return Kt(new TextDecoder().decode(n||"").trim())};var $t=F(Bt()),H=(r,e)=>async function*(){yield*(await(0,$t.default)(r)).sort(e)}(),Ee=(r,e)=>{let t=new RegExp("^"+e);return r.replace(t,"")};var Ze=F(He()),z=F(Xe()),Qe=F(Ye()),j=class{open(){return Promise.reject(new Error(".open is not implemented"))}close(){return Promise.reject(new Error(".close is not implemented"))}put(e,t,s){return Promise.reject(new Error(".put is not implemented"))}get(e,t){return Promise.reject(new Error(".get is not implemented"))}has(e,t){return Promise.reject(new Error(".has is not implemented"))}delete(e,t){return Promise.reject(new Error(".delete is not implemented"))}async*putMany(e,t={}){for await(let{key:s,value:n}of e)await this.put(s,n,t),yield{key:s,value:n}}async*getMany(e,t={}){for await(let s of e)yield this.get(s,t)}async*deleteMany(e,t={}){for await(let s of e)await this.delete(s,t),yield s}batch(){let e=[],t=[];return{put(s,n){e.push({key:s,value:n})},delete(s){t.push(s)},commit:async s=>{await(0,Ze.default)(this.putMany(e,s)),e=[],await(0,Ze.default)(this.deleteMany(t,s)),t=[]}}}async*_all(e,t){throw new Error("._all is not implemented")}async*_allKeys(e,t){throw new Error("._allKeys is not implemented")}query(e,t){let s=this._all(e,t);if(e.prefix!=null&&(s=(0,z.default)(s,n=>n.key.toString().startsWith(e.prefix))),Array.isArray(e.filters)&&(s=e.filters.reduce((n,o)=>(0,z.default)(n,o),s)),Array.isArray(e.orders)&&(s=e.orders.reduce((n,o)=>H(n,o),s)),e.offset!=null){let n=0;s=(0,z.default)(s,()=>n++>=e.offset)}return e.limit!=null&&(s=(0,Qe.default)(s,e.limit)),s}queryKeys(e,t){let s=this._allKeys(e,t);if(e.prefix!=null&&(s=(0,z.default)(s,n=>n.toString().startsWith(e.prefix))),Array.isArray(e.filters)&&(s=e.filters.reduce((n,o)=>(0,z.default)(n,o),s)),Array.isArray(e.orders)&&(s=e.orders.reduce((n,o)=>H(n,o),s)),e.offset!=null){let n=0;s=(0,z.default)(s,()=>n++>=e.offset)}return e.limit!=null&&(s=(0,Qe.default)(s,e.limit)),s}};var qe=class extends j{constructor(){super();this.data={}}open(){return Promise.resolve()}close(){return Promise.resolve()}async put(e,t){this.data[e.toString()]=t}async get(e){if(!await this.has(e))throw K();return this.data[e.toString()]}async has(e){return this.data[e.toString()]!==void 0}async delete(e){delete this.data[e.toString()]}async*_all(){yield*Object.entries(this.data).map(([e,t])=>({key:new p(e),value:t}))}async*_allKeys(){yield*Object.entries(this.data).map(([e])=>new p(e))}};var T=F(Ht()),Fe=F(Zt()),O=class extends j{constructor(e,t){super();this.child=e,this.transform=t}open(){return this.child.open()}put(e,t,s){return this.child.put(this.transform.convert(e),t,s)}get(e,t){return this.child.get(this.transform.convert(e),t)}has(e,t){return this.child.has(this.transform.convert(e),t)}delete(e,t){return this.child.delete(this.transform.convert(e),t)}async*putMany(e,t={}){let s=this.transform,n=this.child;yield*(0,Fe.pipe)(e,async function*(o){yield*(0,T.default)(o,({key:i,value:f})=>({key:s.convert(i),value:f}))},async function*(o){yield*n.putMany(o,t)},async function*(o){yield*(0,T.default)(o,({key:i,value:f})=>({key:s.invert(i),value:f}))})}async*getMany(e,t={}){let s=this.transform,n=this.child;yield*(0,Fe.pipe)(e,async function*(o){yield*(0,T.default)(o,i=>s.convert(i))},async function*(o){yield*n.getMany(o,t)})}async*deleteMany(e,t={}){let s=this.transform,n=this.child;yield*(0,Fe.pipe)(e,async function*(o){yield*(0,T.default)(o,i=>s.convert(i))},async function*(o){yield*n.deleteMany(o,t)},async function*(o){yield*(0,T.default)(o,i=>s.invert(i))})}batch(){let e=this.child.batch();return{put:(t,s)=>{e.put(this.transform.convert(t),s)},delete:t=>{e.delete(this.transform.convert(t))},commit:t=>e.commit(t)}}query(e,t){return(0,T.default)(this.child.query(e,t),({key:s,value:n})=>({key:this.transform.invert(s),value:n}))}queryKeys(e,t){return(0,T.default)(this.child.queryKeys(e,t),s=>this.transform.invert(s))}close(){return this.child.close()}};var Y=new p(ve),fe=new p($e),P=class extends j{constructor(e,t){super();this.child=new O(e,{convert:this._convertKey.bind(this),invert:this._invertKey.bind(this)}),this.shard=t}async open(){await this.child.open(),this.shard=await P.create(this.child,this.shard)}_convertKey(e){let t=e.toString();return t===Y.toString()||t===fe.toString()?e:new p(this.shard.fun(t)).child(e)}_invertKey(e){let t=e.toString();return t===Y.toString()||t===fe.toString()?e:p.withNamespaces(e.list().slice(1))}static async createOrOpen(e,t){try{await P.create(e,t)}catch(s){if(s&&s.message!=="datastore exists")throw s}return P.open(e)}static async open(e){let t=await Ce("/",e);return new P(e,t)}static async create(e,t){let s=await e.has(Y);if(!s&&!t)throw ee(Error("Shard is required when datastore doesn't have a shard key already."));if(!s){let f=typeof e.putRaw=="function"?e.putRaw.bind(e):e.put.bind(e);return await Promise.all([f(Y,new TextEncoder().encode(t.toString()+`
`)),f(fe,new TextEncoder().encode(we))]),t}let n=await Ce("/",e),o=(n||"").toString(),i=t.toString();if(o!==i)throw new Error(`specified fun ${i} does not match repo shard fun ${o}`);return n}put(e,t,s){return this.child.put(e,t,s)}get(e,t){return this.child.get(e,t)}has(e,t){return this.child.has(e,t)}delete(e,t){return this.child.delete(e,t)}async*putMany(e,t={}){yield*this.child.putMany(e,t)}async*getMany(e,t={}){yield*this.child.getMany(e,t)}async*deleteMany(e,t={}){yield*this.child.deleteMany(e,t)}batch(){return this.child.batch()}query(e,t){let s={offset:e.offset,limit:e.limit,orders:[],filters:[o=>o.key.toString()!==Y.toString(),o=>o.key.toString()!==fe.toString()]},{prefix:n}=e;if(n!=null&&s.filters.push(o=>this._invertKey(o.key).toString().startsWith(n)),e.filters!=null){let o=e.filters.map(i=>({key:l,value:E})=>i({key:this._invertKey(l),value:E}));s.filters=s.filters.concat(o)}return e.orders!=null&&(s.orders=e.orders.map(o=>(f,l)=>o({key:this._invertKey(f.key),value:f.value},{key:this._invertKey(l.key),value:l.value}))),this.child.query(s,t)}queryKeys(e,t){let s={offset:e.offset,limit:e.limit,orders:[],filters:[o=>o.toString()!==Y.toString(),o=>o.toString()!==fe.toString()]},{prefix:n}=e;if(n!=null&&s.filters.push(o=>this._invertKey(o).toString().startsWith(n)),e.filters!=null){let o=e.filters.map(i=>l=>i(this._invertKey(l)));s.filters=s.filters.concat(o)}return e.orders!=null&&(s.orders=e.orders.map(o=>(f,l)=>o(this._invertKey(f),this._invertKey(l)))),this.child.queryKeys(s,t)}close(){return this.child.close()}};var ue=F(Xe()),st=F(Ye()),nt=F(or());var ot=class extends j{constructor(e){super();this.mounts=e.slice()}async open(){await Promise.all(this.mounts.map(e=>e.datastore.open()))}_lookup(e){for(let t of this.mounts)if(t.prefix.toString()===e.toString()||t.prefix.isAncestorOf(e)){let s=Ee(e.toString(),t.prefix.toString());return{datastore:t.datastore,mountpoint:t.prefix,rest:new p(s)}}}put(e,t,s){let n=this._lookup(e);if(n==null)throw re(new Error("No datastore mounted for this key"));return n.datastore.put(n.rest,t,s)}get(e,t){let s=this._lookup(e);if(s==null)throw K(new Error("No datastore mounted for this key"));return s.datastore.get(s.rest,t)}has(e,t){let s=this._lookup(e);return s==null?Promise.resolve(!1):s.datastore.has(s.rest,t)}delete(e,t){let s=this._lookup(e);if(s==null)throw te(new Error("No datastore mounted for this key"));return s.datastore.delete(s.rest,t)}async close(){await Promise.all(this.mounts.map(e=>e.datastore.close()))}batch(){let e={},t=s=>{let n=this._lookup(s);if(n==null)throw new Error("No datastore mounted for this key");let o=n.mountpoint.toString();return e[o]==null&&(e[o]=n.datastore.batch()),{batch:e[o],rest:n.rest}};return{put:(s,n)=>{let o=t(s);o.batch.put(o.rest,n)},delete:s=>{let n=t(s);n.batch.delete(n.rest)},commit:async s=>{await Promise.all(Object.keys(e).map(n=>e[n].commit(s)))}}}query(e,t){let s=this.mounts.map(o=>{let i=new O(o.datastore,{convert:l=>{throw new Error("should never be called")},invert:l=>o.prefix.child(l)}),f;return e.prefix!=null&&(f=Ee(e.prefix,o.prefix.toString())),i.query({prefix:f,filters:e.filters},t)}),n=(0,nt.default)(...s);if(e.filters&&e.filters.forEach(o=>{n=(0,ue.default)(n,o)}),e.orders&&e.orders.forEach(o=>{n=H(n,o)}),e.offset!=null){let o=0;n=(0,ue.default)(n,()=>o++>=e.offset)}return e.limit!=null&&(n=(0,st.default)(n,e.limit)),n}queryKeys(e,t){let s=this.mounts.map(o=>{let i=new O(o.datastore,{convert:l=>{throw new Error("should never be called")},invert:l=>o.prefix.child(l)}),f;return e.prefix!=null&&(f=Ee(e.prefix,o.prefix.toString())),i.queryKeys({prefix:f,filters:e.filters},t)}),n=(0,nt.default)(...s);if(e.filters&&e.filters.forEach(o=>{n=(0,ue.default)(n,o)}),e.orders&&e.orders.forEach(o=>{n=H(n,o)}),e.offset!=null){let o=0;n=(0,ue.default)(n,()=>o++>=e.offset)}return e.limit!=null&&(n=(0,st.default)(n,e.limit)),n}};var lr=F(ur()),it=F(rt()),at=F(He()),Js=(0,lr.default)("datastore:core:tiered"),ct=class extends j{constructor(e){super();this.stores=e.slice()}async open(){try{await Promise.all(this.stores.map(e=>e.open()))}catch(e){throw ee()}}async put(e,t){try{await Promise.all(this.stores.map(s=>s.put(e,t)))}catch(s){throw re()}}async get(e,t){for(let s of this.stores)try{let n=await s.get(e,t);if(n)return n}catch(n){Js(n)}throw K()}async has(e,t){for(let s of this.stores)if(await s.has(e,t))return!0;return!1}async delete(e,t){try{await Promise.all(this.stores.map(s=>s.delete(e,t)))}catch(s){throw te()}}async*putMany(e,t={}){let s,n=this.stores.map(o=>{let i=(0,it.default)();return(0,at.default)(o.putMany(i,t)).catch(f=>{s=f}),i});try{for await(let o of e){if(s)throw s;n.forEach(i=>i.push(o)),yield o}}finally{n.forEach(o=>o.end())}}async*deleteMany(e,t={}){let s,n=this.stores.map(o=>{let i=(0,it.default)();return(0,at.default)(o.deleteMany(i,t)).catch(f=>{s=f}),i});try{for await(let o of e){if(s)throw s;n.forEach(i=>i.push(o)),yield o}}finally{n.forEach(o=>o.end())}}async close(){await Promise.all(this.stores.map(e=>e.close()))}batch(){let e=this.stores.map(t=>t.batch());return{put:(t,s)=>{e.forEach(n=>n.put(t,s))},delete:t=>{e.forEach(s=>s.delete(t))},commit:async t=>{for(let s of e)await s.commit(t)}}}query(e,t){return this.stores[this.stores.length-1].query(e,t)}queryKeys(e,t){return this.stores[this.stores.length-1].queryKeys(e,t)}};var ft=class extends O{constructor(e,t){super(e,{convert(s){return t.child(s)},invert(s){if(t.toString()==="/")return s;if(!t.isAncestorOf(s))throw new Error(`Expected prefix: (${t.toString()}) in key: ${s.toString()}`);return new p(s.toString().slice(t.toString().length),!1)}});this.prefix=t}query(e,t){return e.prefix&&this.prefix.toString()!=="/"?super.query(Object.assign({},e,{prefix:this.prefix.child(new p(e.prefix)).toString()})):super.query(e,t)}queryKeys(e,t){return e.prefix&&this.prefix.toString()!=="/"?super.queryKeys(Object.assign({},e,{prefix:this.prefix.child(new p(e.prefix)).toString()})):super.queryKeys(e,t)}};var Gs={...De},Hs={...Ge};return Xs;})();
return DatastoreCore}));
