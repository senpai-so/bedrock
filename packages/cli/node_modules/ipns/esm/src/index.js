import NanoDate from 'timestamp-nano';
import { Key } from 'interface-datastore/key';
import crypto from 'libp2p-crypto';
import PeerId from 'peer-id';
import * as Digest from 'multiformats/hashes/digest';
import { identity } from 'multiformats/hashes/identity';
import errCode from 'err-code';
import { base32upper } from 'multiformats/bases/base32';
import { fromString as uint8ArrayFromString } from 'uint8arrays/from-string';
import { toString as uint8ArrayToString } from 'uint8arrays/to-string';
import { concat as uint8ArrayConcat } from 'uint8arrays/concat';
import { equals as uint8ArrayEquals } from 'uint8arrays/equals';
import * as cborg from 'cborg';
import Long from 'long';
import debug from 'debug';
import { IpnsEntry as ipnsEntryProto } from './pb/ipns.js';
import { parseRFC3339 } from './utils.js';
import * as ERRORS from './errors.js';
const log = Object.assign(debug('jsipns'), { error: debug('jsipns:error') });
const ID_MULTIHASH_CODE = identity.code;
const IPNS_PREFIX = uint8ArrayFromString('/ipns/');
export const namespace = '/ipns/';
export const namespaceLength = namespace.length;
export const create = (privateKey, value, seq, lifetime) => {
  const expirationDate = new NanoDate(Date.now() + Number(lifetime));
  const validityType = ipnsEntryProto.ValidityType.EOL;
  const [ms, ns] = lifetime.toString().split('.');
  const lifetimeNs = BigInt(ms) * BigInt(100000) + BigInt(ns || 0);
  return _create(privateKey, value, seq, validityType, expirationDate, lifetimeNs);
};
export const createWithExpiration = (privateKey, value, seq, expiration) => {
  const expirationDate = NanoDate.fromString(expiration);
  const validityType = ipnsEntryProto.ValidityType.EOL;
  const ttlMs = expirationDate.toDate().getTime() - Date.now();
  const ttlNs = BigInt(ttlMs) * BigInt(100000) + BigInt(expirationDate.getNano());
  return _create(privateKey, value, seq, validityType, expirationDate, ttlNs);
};
const _create = async (privateKey, value, seq, validityType, expirationDate, ttl) => {
  seq = BigInt(seq);
  const isoValidity = uint8ArrayFromString(expirationDate.toString());
  const signatureV1 = await sign(privateKey, value, validityType, isoValidity);
  const data = createCborData(value, isoValidity, validityType, seq, ttl);
  const sigData = ipnsEntryDataForV2Sig(data);
  const signatureV2 = await privateKey.sign(sigData);
  const entry = {
    value,
    signature: signatureV1,
    validityType: validityType,
    validity: isoValidity,
    sequence: seq,
    ttl,
    signatureV2,
    data
  };
  log(`ipns entry for ${ value } created`);
  return entry;
};
const createCborData = (value, validity, validityType, sequence, ttl) => {
  const data = {
    Value: value,
    Validity: validity,
    ValidityType: validityType,
    Sequence: sequence,
    TTL: ttl
  };
  return cborg.encode(data);
};
export const validate = async (publicKey, entry) => {
  const {value, validityType, validity} = entry;
  let dataForSignature;
  let signature;
  if (entry.signatureV2 && entry.data) {
    signature = entry.signatureV2;
    dataForSignature = ipnsEntryDataForV2Sig(entry.data);
    validateCborDataMatchesPbData(entry);
  } else {
    signature = entry.signature;
    dataForSignature = ipnsEntryDataForV1Sig(value, validityType, validity);
  }
  let isValid;
  try {
    isValid = await publicKey.verify(dataForSignature, signature);
  } catch (err) {
    isValid = false;
  }
  if (!isValid) {
    log.error('record signature verification failed');
    throw errCode(new Error('record signature verification failed'), ERRORS.ERR_SIGNATURE_VERIFICATION);
  }
  if (validityType === ipnsEntryProto.ValidityType.EOL) {
    let validityDate;
    try {
      validityDate = parseRFC3339(uint8ArrayToString(validity));
    } catch (e) {
      log.error('unrecognized validity format (not an rfc3339 format)');
      throw errCode(new Error('unrecognized validity format (not an rfc3339 format)'), ERRORS.ERR_UNRECOGNIZED_FORMAT);
    }
    if (validityDate.getTime() < Date.now()) {
      log.error('record has expired');
      throw errCode(new Error('record has expired'), ERRORS.ERR_IPNS_EXPIRED_RECORD);
    }
  } else if (validityType) {
    log.error('unrecognized validity type');
    throw errCode(new Error('unrecognized validity type'), ERRORS.ERR_UNRECOGNIZED_VALIDITY);
  }
  log(`ipns entry for ${ value } is valid`);
};
const validateCborDataMatchesPbData = entry => {
  if (!entry.data) {
    throw errCode(new Error('Record data is missing'), ERRORS.ERR_INVALID_RECORD_DATA);
  }
  const data = cborg.decode(entry.data);
  if (Number.isInteger(data.Sequence)) {
    data.Sequence = BigInt(data.Sequence);
  }
  if (Number.isInteger(data.TTL)) {
    data.TTL = BigInt(data.TTL);
  }
  if (!uint8ArrayEquals(data.Value, entry.value)) {
    throw errCode(new Error('Field "value" did not match between protobuf and CBOR'), ERRORS.ERR_SIGNATURE_VERIFICATION);
  }
  if (!uint8ArrayEquals(data.Validity, entry.validity)) {
    throw errCode(new Error('Field "validity" did not match between protobuf and CBOR'), ERRORS.ERR_SIGNATURE_VERIFICATION);
  }
  if (data.ValidityType !== entry.validityType) {
    throw errCode(new Error('Field "validityType" did not match between protobuf and CBOR'), ERRORS.ERR_SIGNATURE_VERIFICATION);
  }
  if (data.Sequence !== entry.sequence) {
    throw errCode(new Error('Field "sequence" did not match between protobuf and CBOR'), ERRORS.ERR_SIGNATURE_VERIFICATION);
  }
  if (data.TTL !== entry.ttl) {
    throw errCode(new Error('Field "ttl" did not match between protobuf and CBOR'), ERRORS.ERR_SIGNATURE_VERIFICATION);
  }
};
export const embedPublicKey = async (publicKey, entry) => {
  if (!publicKey || !publicKey.bytes || !entry) {
    const error = new Error('one or more of the provided parameters are not defined');
    log.error(error);
    throw errCode(error, ERRORS.ERR_UNDEFINED_PARAMETER);
  }
  let peerId;
  try {
    peerId = await PeerId.createFromPubKey(publicKey.bytes);
  } catch (err) {
    throw errCode(err, ERRORS.ERR_PEER_ID_FROM_PUBLIC_KEY);
  }
  let extractedPublicKey;
  try {
    extractedPublicKey = extractPublicKeyFromId(peerId);
  } catch (err) {
    log.error(err);
    throw errCode(err, ERRORS.ERR_PUBLIC_KEY_FROM_ID);
  }
  if (extractedPublicKey) {
    return null;
  }
  try {
    entry.pubKey = crypto.keys.marshalPublicKey(publicKey);
  } catch (err) {
    log.error(err);
    throw err;
  }
  return entry;
};
export const extractPublicKey = async (peerId, entry) => {
  if (!entry || !peerId) {
    const error = new Error('one or more of the provided parameters are not defined');
    log.error(error);
    throw errCode(error, ERRORS.ERR_UNDEFINED_PARAMETER);
  }
  let pubKey;
  if (entry.pubKey) {
    try {
      pubKey = crypto.keys.unmarshalPublicKey(entry.pubKey);
    } catch (err) {
      log.error(err);
      throw err;
    }
    const otherId = await PeerId.createFromPubKey(entry.pubKey);
    if (!otherId.equals(peerId)) {
      throw errCode(new Error('Embedded public key did not match PeerID'), ERRORS.ERR_INVALID_EMBEDDED_KEY);
    }
  } else if (peerId.pubKey) {
    pubKey = peerId.pubKey;
  }
  if (pubKey) {
    return pubKey;
  }
  throw errCode(new Error('no public key is available'), ERRORS.ERR_UNDEFINED_PARAMETER);
};
const rawStdEncoding = key => base32upper.encode(key).slice(1);
export const getLocalKey = key => new Key(`/ipns/${ rawStdEncoding(key) }`);
export const getIdKeys = pid => {
  const pkBuffer = uint8ArrayFromString('/pk/');
  const ipnsBuffer = uint8ArrayFromString('/ipns/');
  return {
    routingPubKey: new Key(uint8ArrayConcat([
      pkBuffer,
      pid
    ]), false),
    pkKey: new Key(rawStdEncoding(uint8ArrayConcat([
      pkBuffer,
      pid
    ]))),
    routingKey: new Key(uint8ArrayConcat([
      ipnsBuffer,
      pid
    ]), false),
    ipnsKey: new Key(rawStdEncoding(uint8ArrayConcat([
      ipnsBuffer,
      pid
    ])))
  };
};
const sign = (privateKey, value, validityType, validity) => {
  try {
    const dataForSignature = ipnsEntryDataForV1Sig(value, validityType, validity);
    return privateKey.sign(dataForSignature);
  } catch (error) {
    log.error('record signature creation failed');
    throw errCode(new Error('record signature creation failed: ' + error.message), ERRORS.ERR_SIGNATURE_CREATION);
  }
};
const getValidityType = validityType => {
  if (validityType.toString() === '0') {
    return 'EOL';
  }
  const error = new Error(`unrecognized validity type ${ validityType.toString() }`);
  log.error(error);
  throw errCode(error, ERRORS.ERR_UNRECOGNIZED_VALIDITY);
};
const ipnsEntryDataForV1Sig = (value, validityType, validity) => {
  const validityTypeBuffer = uint8ArrayFromString(getValidityType(validityType));
  return uint8ArrayConcat([
    value,
    validity,
    validityTypeBuffer
  ]);
};
const ipnsEntryDataForV2Sig = data => {
  const entryData = uint8ArrayFromString('ipns-signature:');
  return uint8ArrayConcat([
    entryData,
    data
  ]);
};
const extractPublicKeyFromId = peerId => {
  const digest = Digest.decode(peerId.id);
  if (digest.code !== ID_MULTIHASH_CODE) {
    return null;
  }
  return crypto.keys.unmarshalPublicKey(digest.digest);
};
export const marshal = obj => {
  return ipnsEntryProto.encode({
    ...obj,
    sequence: Long.fromString(obj.sequence.toString()),
    ttl: obj.ttl == null ? undefined : Long.fromString(obj.ttl.toString())
  }).finish();
};
export const unmarshal = buf => {
  const message = ipnsEntryProto.decode(buf);
  const object = ipnsEntryProto.toObject(message, {
    defaults: false,
    arrays: true,
    objects: false
  });
  return {
    value: object.value,
    signature: object.signature,
    validityType: object.validityType,
    validity: object.validity,
    sequence: Object.hasOwnProperty.call(object, 'sequence') ? BigInt(`${ object.sequence }`) : 0,
    pubKey: object.pubKey,
    ttl: Object.hasOwnProperty.call(object, 'ttl') ? BigInt(`${ object.ttl }`) : undefined,
    signatureV2: object.signatureV2,
    data: object.data
  };
};
export const validator = {
  validate: async (marshalledData, key) => {
    const receivedEntry = unmarshal(marshalledData);
    const bufferId = key.slice(IPNS_PREFIX.length);
    const peerId = PeerId.createFromBytes(bufferId);
    const pubKey = await extractPublicKey(peerId, receivedEntry);
    await validate(pubKey, receivedEntry);
  },
  select: (dataA, dataB) => {
    const entryA = unmarshal(dataA);
    const entryB = unmarshal(dataB);
    if (entryA.signatureV2 && !entryB.signatureV2) {
      return 0;
    } else if (entryB.signatureV2 && !entryA.signatureV2) {
      return 1;
    }
    if (entryA.sequence > entryB.sequence) {
      return 0;
    } else if (entryA.sequence < entryB.sequence) {
      return 1;
    }
    const entryAValidityDate = parseRFC3339(uint8ArrayToString(entryA.validity));
    const entryBValidityDate = parseRFC3339(uint8ArrayToString(entryB.validity));
    return entryBValidityDate.getTime() > entryAValidityDate.getTime() ? 1 : 0;
  }
};