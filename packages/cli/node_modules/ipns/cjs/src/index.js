'use strict';

Object.defineProperty(exports, '__esModule', { value: true });

var NanoDate = require('timestamp-nano');
var key = require('interface-datastore/key');
var crypto = require('libp2p-crypto');
var PeerId = require('peer-id');
var Digest = require('multiformats/hashes/digest');
var identity = require('multiformats/hashes/identity');
var errCode = require('err-code');
var base32 = require('multiformats/bases/base32');
var fromString = require('uint8arrays/from-string');
var toString = require('uint8arrays/to-string');
var concat = require('uint8arrays/concat');
var equals = require('uint8arrays/equals');
var cborg = require('cborg');
var Long = require('long');
var debug = require('debug');
var ipns = require('./pb/ipns.js');
var utils = require('./utils.js');
var errors = require('./errors.js');

function _interopDefaultLegacy (e) { return e && typeof e === 'object' && 'default' in e ? e : { 'default': e }; }

function _interopNamespace(e) {
  if (e && e.__esModule) return e;
  var n = Object.create(null);
  if (e) {
    Object.keys(e).forEach(function (k) {
      if (k !== 'default') {
        var d = Object.getOwnPropertyDescriptor(e, k);
        Object.defineProperty(n, k, d.get ? d : {
          enumerable: true,
          get: function () { return e[k]; }
        });
      }
    });
  }
  n["default"] = e;
  return Object.freeze(n);
}

var NanoDate__default = /*#__PURE__*/_interopDefaultLegacy(NanoDate);
var crypto__default = /*#__PURE__*/_interopDefaultLegacy(crypto);
var PeerId__default = /*#__PURE__*/_interopDefaultLegacy(PeerId);
var Digest__namespace = /*#__PURE__*/_interopNamespace(Digest);
var errCode__default = /*#__PURE__*/_interopDefaultLegacy(errCode);
var cborg__namespace = /*#__PURE__*/_interopNamespace(cborg);
var Long__default = /*#__PURE__*/_interopDefaultLegacy(Long);
var debug__default = /*#__PURE__*/_interopDefaultLegacy(debug);

const log = Object.assign(debug__default["default"]('jsipns'), { error: debug__default["default"]('jsipns:error') });
const ID_MULTIHASH_CODE = identity.identity.code;
const IPNS_PREFIX = fromString.fromString('/ipns/');
const namespace = '/ipns/';
const namespaceLength = namespace.length;
const create = (privateKey, value, seq, lifetime) => {
  const expirationDate = new NanoDate__default["default"](Date.now() + Number(lifetime));
  const validityType = ipns.IpnsEntry.ValidityType.EOL;
  const [ms, ns] = lifetime.toString().split('.');
  const lifetimeNs = BigInt(ms) * BigInt(100000) + BigInt(ns || 0);
  return _create(privateKey, value, seq, validityType, expirationDate, lifetimeNs);
};
const createWithExpiration = (privateKey, value, seq, expiration) => {
  const expirationDate = NanoDate__default["default"].fromString(expiration);
  const validityType = ipns.IpnsEntry.ValidityType.EOL;
  const ttlMs = expirationDate.toDate().getTime() - Date.now();
  const ttlNs = BigInt(ttlMs) * BigInt(100000) + BigInt(expirationDate.getNano());
  return _create(privateKey, value, seq, validityType, expirationDate, ttlNs);
};
const _create = async (privateKey, value, seq, validityType, expirationDate, ttl) => {
  seq = BigInt(seq);
  const isoValidity = fromString.fromString(expirationDate.toString());
  const signatureV1 = await sign(privateKey, value, validityType, isoValidity);
  const data = createCborData(value, isoValidity, validityType, seq, ttl);
  const sigData = ipnsEntryDataForV2Sig(data);
  const signatureV2 = await privateKey.sign(sigData);
  const entry = {
    value,
    signature: signatureV1,
    validityType: validityType,
    validity: isoValidity,
    sequence: seq,
    ttl,
    signatureV2,
    data
  };
  log(`ipns entry for ${ value } created`);
  return entry;
};
const createCborData = (value, validity, validityType, sequence, ttl) => {
  const data = {
    Value: value,
    Validity: validity,
    ValidityType: validityType,
    Sequence: sequence,
    TTL: ttl
  };
  return cborg__namespace.encode(data);
};
const validate = async (publicKey, entry) => {
  const {value, validityType, validity} = entry;
  let dataForSignature;
  let signature;
  if (entry.signatureV2 && entry.data) {
    signature = entry.signatureV2;
    dataForSignature = ipnsEntryDataForV2Sig(entry.data);
    validateCborDataMatchesPbData(entry);
  } else {
    signature = entry.signature;
    dataForSignature = ipnsEntryDataForV1Sig(value, validityType, validity);
  }
  let isValid;
  try {
    isValid = await publicKey.verify(dataForSignature, signature);
  } catch (err) {
    isValid = false;
  }
  if (!isValid) {
    log.error('record signature verification failed');
    throw errCode__default["default"](new Error('record signature verification failed'), errors.ERR_SIGNATURE_VERIFICATION);
  }
  if (validityType === ipns.IpnsEntry.ValidityType.EOL) {
    let validityDate;
    try {
      validityDate = utils.parseRFC3339(toString.toString(validity));
    } catch (e) {
      log.error('unrecognized validity format (not an rfc3339 format)');
      throw errCode__default["default"](new Error('unrecognized validity format (not an rfc3339 format)'), errors.ERR_UNRECOGNIZED_FORMAT);
    }
    if (validityDate.getTime() < Date.now()) {
      log.error('record has expired');
      throw errCode__default["default"](new Error('record has expired'), errors.ERR_IPNS_EXPIRED_RECORD);
    }
  } else if (validityType) {
    log.error('unrecognized validity type');
    throw errCode__default["default"](new Error('unrecognized validity type'), errors.ERR_UNRECOGNIZED_VALIDITY);
  }
  log(`ipns entry for ${ value } is valid`);
};
const validateCborDataMatchesPbData = entry => {
  if (!entry.data) {
    throw errCode__default["default"](new Error('Record data is missing'), errors.ERR_INVALID_RECORD_DATA);
  }
  const data = cborg__namespace.decode(entry.data);
  if (Number.isInteger(data.Sequence)) {
    data.Sequence = BigInt(data.Sequence);
  }
  if (Number.isInteger(data.TTL)) {
    data.TTL = BigInt(data.TTL);
  }
  if (!equals.equals(data.Value, entry.value)) {
    throw errCode__default["default"](new Error('Field "value" did not match between protobuf and CBOR'), errors.ERR_SIGNATURE_VERIFICATION);
  }
  if (!equals.equals(data.Validity, entry.validity)) {
    throw errCode__default["default"](new Error('Field "validity" did not match between protobuf and CBOR'), errors.ERR_SIGNATURE_VERIFICATION);
  }
  if (data.ValidityType !== entry.validityType) {
    throw errCode__default["default"](new Error('Field "validityType" did not match between protobuf and CBOR'), errors.ERR_SIGNATURE_VERIFICATION);
  }
  if (data.Sequence !== entry.sequence) {
    throw errCode__default["default"](new Error('Field "sequence" did not match between protobuf and CBOR'), errors.ERR_SIGNATURE_VERIFICATION);
  }
  if (data.TTL !== entry.ttl) {
    throw errCode__default["default"](new Error('Field "ttl" did not match between protobuf and CBOR'), errors.ERR_SIGNATURE_VERIFICATION);
  }
};
const embedPublicKey = async (publicKey, entry) => {
  if (!publicKey || !publicKey.bytes || !entry) {
    const error = new Error('one or more of the provided parameters are not defined');
    log.error(error);
    throw errCode__default["default"](error, errors.ERR_UNDEFINED_PARAMETER);
  }
  let peerId;
  try {
    peerId = await PeerId__default["default"].createFromPubKey(publicKey.bytes);
  } catch (err) {
    throw errCode__default["default"](err, errors.ERR_PEER_ID_FROM_PUBLIC_KEY);
  }
  let extractedPublicKey;
  try {
    extractedPublicKey = extractPublicKeyFromId(peerId);
  } catch (err) {
    log.error(err);
    throw errCode__default["default"](err, errors.ERR_PUBLIC_KEY_FROM_ID);
  }
  if (extractedPublicKey) {
    return null;
  }
  try {
    entry.pubKey = crypto__default["default"].keys.marshalPublicKey(publicKey);
  } catch (err) {
    log.error(err);
    throw err;
  }
  return entry;
};
const extractPublicKey = async (peerId, entry) => {
  if (!entry || !peerId) {
    const error = new Error('one or more of the provided parameters are not defined');
    log.error(error);
    throw errCode__default["default"](error, errors.ERR_UNDEFINED_PARAMETER);
  }
  let pubKey;
  if (entry.pubKey) {
    try {
      pubKey = crypto__default["default"].keys.unmarshalPublicKey(entry.pubKey);
    } catch (err) {
      log.error(err);
      throw err;
    }
    const otherId = await PeerId__default["default"].createFromPubKey(entry.pubKey);
    if (!otherId.equals(peerId)) {
      throw errCode__default["default"](new Error('Embedded public key did not match PeerID'), errors.ERR_INVALID_EMBEDDED_KEY);
    }
  } else if (peerId.pubKey) {
    pubKey = peerId.pubKey;
  }
  if (pubKey) {
    return pubKey;
  }
  throw errCode__default["default"](new Error('no public key is available'), errors.ERR_UNDEFINED_PARAMETER);
};
const rawStdEncoding = key => base32.base32upper.encode(key).slice(1);
const getLocalKey = key$1 => new key.Key(`/ipns/${ rawStdEncoding(key$1) }`);
const getIdKeys = pid => {
  const pkBuffer = fromString.fromString('/pk/');
  const ipnsBuffer = fromString.fromString('/ipns/');
  return {
    routingPubKey: new key.Key(concat.concat([
      pkBuffer,
      pid
    ]), false),
    pkKey: new key.Key(rawStdEncoding(concat.concat([
      pkBuffer,
      pid
    ]))),
    routingKey: new key.Key(concat.concat([
      ipnsBuffer,
      pid
    ]), false),
    ipnsKey: new key.Key(rawStdEncoding(concat.concat([
      ipnsBuffer,
      pid
    ])))
  };
};
const sign = (privateKey, value, validityType, validity) => {
  try {
    const dataForSignature = ipnsEntryDataForV1Sig(value, validityType, validity);
    return privateKey.sign(dataForSignature);
  } catch (error) {
    log.error('record signature creation failed');
    throw errCode__default["default"](new Error('record signature creation failed: ' + error.message), errors.ERR_SIGNATURE_CREATION);
  }
};
const getValidityType = validityType => {
  if (validityType.toString() === '0') {
    return 'EOL';
  }
  const error = new Error(`unrecognized validity type ${ validityType.toString() }`);
  log.error(error);
  throw errCode__default["default"](error, errors.ERR_UNRECOGNIZED_VALIDITY);
};
const ipnsEntryDataForV1Sig = (value, validityType, validity) => {
  const validityTypeBuffer = fromString.fromString(getValidityType(validityType));
  return concat.concat([
    value,
    validity,
    validityTypeBuffer
  ]);
};
const ipnsEntryDataForV2Sig = data => {
  const entryData = fromString.fromString('ipns-signature:');
  return concat.concat([
    entryData,
    data
  ]);
};
const extractPublicKeyFromId = peerId => {
  const digest = Digest__namespace.decode(peerId.id);
  if (digest.code !== ID_MULTIHASH_CODE) {
    return null;
  }
  return crypto__default["default"].keys.unmarshalPublicKey(digest.digest);
};
const marshal = obj => {
  return ipns.IpnsEntry.encode({
    ...obj,
    sequence: Long__default["default"].fromString(obj.sequence.toString()),
    ttl: obj.ttl == null ? undefined : Long__default["default"].fromString(obj.ttl.toString())
  }).finish();
};
const unmarshal = buf => {
  const message = ipns.IpnsEntry.decode(buf);
  const object = ipns.IpnsEntry.toObject(message, {
    defaults: false,
    arrays: true,
    objects: false
  });
  return {
    value: object.value,
    signature: object.signature,
    validityType: object.validityType,
    validity: object.validity,
    sequence: Object.hasOwnProperty.call(object, 'sequence') ? BigInt(`${ object.sequence }`) : 0,
    pubKey: object.pubKey,
    ttl: Object.hasOwnProperty.call(object, 'ttl') ? BigInt(`${ object.ttl }`) : undefined,
    signatureV2: object.signatureV2,
    data: object.data
  };
};
const validator = {
  validate: async (marshalledData, key) => {
    const receivedEntry = unmarshal(marshalledData);
    const bufferId = key.slice(IPNS_PREFIX.length);
    const peerId = PeerId__default["default"].createFromBytes(bufferId);
    const pubKey = await extractPublicKey(peerId, receivedEntry);
    await validate(pubKey, receivedEntry);
  },
  select: (dataA, dataB) => {
    const entryA = unmarshal(dataA);
    const entryB = unmarshal(dataB);
    if (entryA.signatureV2 && !entryB.signatureV2) {
      return 0;
    } else if (entryB.signatureV2 && !entryA.signatureV2) {
      return 1;
    }
    if (entryA.sequence > entryB.sequence) {
      return 0;
    } else if (entryA.sequence < entryB.sequence) {
      return 1;
    }
    const entryAValidityDate = utils.parseRFC3339(toString.toString(entryA.validity));
    const entryBValidityDate = utils.parseRFC3339(toString.toString(entryB.validity));
    return entryBValidityDate.getTime() > entryAValidityDate.getTime() ? 1 : 0;
  }
};

exports.create = create;
exports.createWithExpiration = createWithExpiration;
exports.embedPublicKey = embedPublicKey;
exports.extractPublicKey = extractPublicKey;
exports.getIdKeys = getIdKeys;
exports.getLocalKey = getLocalKey;
exports.marshal = marshal;
exports.namespace = namespace;
exports.namespaceLength = namespaceLength;
exports.unmarshal = unmarshal;
exports.validate = validate;
exports.validator = validator;
